{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"BlockDiagrams","text":"<p>BlockDiagrams is a Python library for drawing signal processing and control system block diagrams using Matplotlib.</p> <p>Developed by Miguel \u00c1. Mart\u00edn-Fern\u00e1ndez, the goal of this package is to make it easy to create publication-ready block diagrams with a minimal and intuitive API.</p>"},{"location":"#installation","title":"\ud83d\ude80 Installation","text":"<p>You can install the library using <code>pip</code> (once published):</p> <pre><code>pip install blockdiagrams\n</code></pre> <p>If you're working locally with the repository:</p> <pre><code>pip install -e .\n</code></pre>"},{"location":"#features","title":"\ud83d\udce6 Features","text":"<ul> <li>Draw basic blocks, summing junctions, arrows, and multipliers</li> <li>Horizontal/vertical or any angle layout support</li> <li>Customizable labels and positions</li> <li>Easy integration with Jupyter notebooks</li> <li>Thread for several lines in diagrams</li> <li>Feedback branches</li> </ul>"},{"location":"#basic-example","title":"\ud83e\uddf0 Basic Example","text":"<pre><code>from blockdiagrams import DiagramBuilder\n\ndb = DiagramBuilder(block_length=1, fontsize=16)\n\n# Diagram drawing\ndb.add(\"x(t)\", kind=\"input\")\ndb.add(\"h_{aa}(t)\", kind=\"block\")\ndb.add(\"x_c(t)\", kind=\"arrow\")\ndb.add(\"mult\", kind=\"combiner\", input_text=\"p(t)\", operation='mult', input_side='bottom')\ndb.add(\"x_p(t)\", kind=\"arrow\")\ndb.add(\"C/D\", kind=\"block\", input_text=\"T_s\", input_side='bottom')\ndb.add(\"x_d[n]\", kind=\"arrow\")\ndb.add(\"D/C\", kind=\"block\")\ndb.add(\"x_p(t)\", kind=\"arrow\")\ndb.add(\"h_r(t)\", kind=\"block\")\ndb.add(\"x_r(t)\", kind=\"output\")\n\n#db.show()\ndb.show(savepath = \"diag1.png\")\n</code></pre> <p>This will generate a basic sample and interpolation diagram.</p> <p></p>"},{"location":"#additional-examples","title":"\ud83e\uddf0 Additional examples","text":"<p>Additional examples notebook 1 Additional examples notebook 2</p>"},{"location":"#documentation","title":"\ud83d\udcda Documentation","text":"<p>See the API Documentation for full reference of all available drawing functions and parameters.</p>"},{"location":"#contributing","title":"\ud83d\udee0\ufe0f Contributing","text":"<p>Feel free to open issues or pull requests on GitHub if you'd like to contribute or report bugs.</p>"},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>This project is licensed under the MIT License.</p>"},{"location":"reference/","title":"API Reference","text":""},{"location":"reference/#blockdiagrams","title":"BlockDiagrams","text":""},{"location":"reference/#blockdiagrams.DiagramBuilder.DiagramBuilder","title":"<code>DiagramBuilder</code>","text":"<p>A helper class for incrementally building signal processing diagrams using Matplotlib.</p> <p>This class provides high-level methods to add standard diagram components like blocks, arrows, combiners, and input/output labels, keeping track of layout and threading.</p> <p>Parameters:</p> Name Type Description Default <code>block_length</code> <code>float</code> <p>Default horizontal size of blocks.</p> <code>1.0</code> <code>block_height</code> <code>float</code> <p>Default vertical size of blocks.</p> <code>1.0</code> <code>fontsize</code> <code>int</code> <p>Default font size for all text.</p> <code>20</code> <p>Returns:</p> Type Description <code>DiagramBuilder</code> <p>created object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from blockdiagrams import DiagramBuilder\n&gt;&gt;&gt; db1 = DiagramBuilder()\n&gt;&gt;&gt; db2 = DiagramBuilder(block_length=2, fontsize=16)\n</code></pre> Source code in <code>blockdiagrams\\DiagramBuilder.py</code> <pre><code>class DiagramBuilder:\n    \"\"\"\n    A helper class for incrementally building signal processing diagrams using Matplotlib.\n\n    This class provides high-level methods to add standard diagram components like blocks, arrows,\n    combiners, and input/output labels, keeping track of layout and threading.\n\n    Args:\n        block_length (float, optional): Default horizontal size of blocks.\n        block_height (float, optional): Default vertical size of blocks.\n        fontsize (int, optional): Default font size for all text.\n\n    Returns:\n        (DiagramBuilder): created object.\n\n    Examples:\n        &gt;&gt;&gt; from blockdiagrams import DiagramBuilder\n        &gt;&gt;&gt; db1 = DiagramBuilder()\n        &gt;&gt;&gt; db2 = DiagramBuilder(block_length=2, fontsize=16)\n    \"\"\"\n    def __init__(self, block_length=1.0, block_height=1.0, fontsize=20):\n        \"\"\"\n        (Private) Creator of the DiagramBuilder class.\n        \"\"\"\n        self.fig, self.ax = plt.subplots()\n        self.ax.axis('off')  # Hide axes\n        self.fontsize = fontsize\n        self.block_length = block_length\n        self.block_height = block_height\n        self.thread_positions = {}\n        self.thread_positions['main'] = [0, 0]\n        # Dictionary to store element positions: input_pos, output_pos, feedback_pos\n        self.element_positions = {}\n        # Counter for current element\n        self.current_element = -1\n\n    def print_threads(self):\n        \"\"\"\n        Prints name of each thread in diagram and actual position.\n\n        Examples:\n            &gt;&gt;&gt; from blockdiagrams import DiagramBuilder\n            &gt;&gt;&gt; db = DiagramBuilder(block_length=1, fontsize=16)\n            &gt;&gt;&gt; # Upper thread\n            &gt;&gt;&gt; db.add(\"x_1(t)\", kind=\"input\", thread='upper', position=(0, 1))\n            &gt;&gt;&gt; db.add(\"mult\", kind=\"combiner\", thread='upper', input_text=\"e^{-j\\\\omega_0 t}\", input_side='top', operation='mult')\n            &gt;&gt;&gt; db.add(\"\", kind=\"line\", thread='upper')\n            &gt;&gt;&gt; # Lower thread\n            &gt;&gt;&gt; db.add(\"x_2(t)\", kind=\"input\", thread='lower', position=(0, -1))\n            &gt;&gt;&gt; db.add(\"mult\", kind=\"combiner\", input_text=\"e^{j\\\\omega_0 t}\", input_side='bottom', operation='mult', thread='lower')\n            &gt;&gt;&gt; db.add(\"\", kind=\"line\", thread='lower')\n            &gt;&gt;&gt; input_threads = ['upper', 'lower']\n            &gt;&gt;&gt; # Adder\n            &gt;&gt;&gt; db.add(\"\", kind=\"mult_combiner\", inputs=input_threads, position=\"auto\", operation='sum')\n            &gt;&gt;&gt; # Rest of the diagram (main thread)\n            &gt;&gt;&gt; db.add(\"x(t)\", kind=\"output\")\n            &gt;&gt;&gt; db.show()\n            &gt;&gt;&gt; db.print_threads()\n        \"\"\"\n        for thread in self.thread_positions:\n            print(thread, \": \", self.thread_positions[thread])\n\n\n    # --- Helper functions ---\n\n    def __get_bbox__(self):\n        return self.ax.dataLim\n\n    def __get_rotated_pos__(self, init_pos, outvector, angle):\n        \"\"\"\n        Inner method.\n        Compute rotated point init_pos + outvector.\n\n        Args:\n            init_pos (Numpy.NDArray or list): Initial position of the block (relative origin of coordinates).\n            outvector (Numpy.NDArray or list): Output vector before rotation (relative position with respect to init_pos).\n            angle (float): Rotation angle in degrees.\n\n        Returns:\n            (Numpy.NDArray): Rotated position of vector init_pos + outvector.\n        \"\"\"\n\n        # Output point respect to input point (before rotation)\n        out_vector = np.array(outvector)\n        # Rotation matrix (without translation)\n        rotation_matrix = transforms.Affine2D().rotate_deg(angle).get_matrix()[:2, :2]\n        # Apply rotation to the output vector\n        dx, dy = rotation_matrix @ out_vector\n        # Add the rotated output vector to the initial position\n        return np.array([init_pos[0] + dx, init_pos[1] + dy])\n\n    def __add_element_position__(self, input_pos: Tuple[float, float], \n                                 output_pos: Tuple[float, float], \n                                 feedback_pos: Tuple[float, float]):\n        \"\"\"\n        Inner method.\n        Adds a new element with the given input, output and feedback positions.\n\n        Args:\n            input_pos (Numpy.NDArray or list): Input position of the block.\n            output_pos (Numpy.NDArray or list): Output position of the block.\n            feedback_pos (Numpy.NDArray or list): Feedback port position of the block.\n        \"\"\"\n        self.current_element += 1\n\n        self.element_positions[self.current_element] = ElementPosition(\n            input_pos=input_pos,\n            output_pos=output_pos,\n            feedback_pos=feedback_pos\n        )\n\n    # --- Drawing functions ---\n\n    def __draw_rotated_text__(self, anchor_point, text, angle, rotate_text = True,\n                      ha='center', va='center', fontsize=16, offset=(0, 0)):\n        \"\"\"\n        Inner method.\n        Draws text rotated around the anchor point with optional offset. \n        Text position: rotation(anchor_point + offset)\n\n        Args:\n            anchor_point (Numpy.NDArray or list): Coordinates of the anchor point.\n            text (string): String to display. LaTeX math accepted (without $...$).\n            angle (float): Rotation angle in degrees.\n            rotate_text (bool, optional): Indicates if text must be rotated or not.\n            ha (string, optional): Horizontal alignment: {'center', 'left', 'right'}.\n            va (string, optional): Vertical alignment: {'center', 'bottom', 'top'}.\n            fontsize (int, optional): Font size.\n            offset (Numpy.NDArray or list): Coordinates of texr position respect to anchor point, before rotation.\n        \"\"\"\n        # Apply rotation to the offset vector\n        dx, dy = offset\n        offset_vec = np.array([dx, dy])\n        rot_matrix = transforms.Affine2D().rotate_deg(angle).get_matrix()[:2, :2]\n        dx_rot, dy_rot = rot_matrix @ offset_vec\n\n        # Compute final position\n        tx = anchor_point[0] + dx_rot\n        ty = anchor_point[1] + dy_rot\n\n        if rotate_text is False:\n            text_angle = 0\n        else:\n            text_angle = angle\n\n        # Draw text with angle, rotating around anchor point\n        self.ax.text(tx, ty, f\"${text}$\", ha=ha, va=va, fontsize=fontsize,\n                rotation=text_angle, rotation_mode='anchor', transform=self.ax.transData)\n\n\n    def __draw_block__(self, initial_position, text=None, text_below=None, \n                       text_above=None, text_offset=0.1, input_text=None, \n                       input_side=None, length=1.5, height=1, fontsize=14, \n                       linestyle='-', orientation='horizontal'):\n        \"\"\"\n        Inner method.\n        Draws a rectangular block with centered text, optional texts below and/or above and optional input arrow with text.\n\n        Args:\n            initial_position (Numpy.NDarray or list): Coordinates of the center position of the input edge of the block.\n            text (string, optional): Label to display in the block.\n            text_below (string, optional): Label to display below the block.\n            text_above (string, optional): Label to display above the block.\n            text_offset (float, optional): Vertical offset for the text position.\n            input_text (string, optional): Label for the optional input arrow (below or above the block).\n            input_side (string, optional): Side to place the input arrow: {'bottom', 'top', None}\n            length (float, optional): Horizontal length of the block. If not entered, default `block_length` is used.\n            height (float, optional): Vertical height of the block. If not entered, default `block_height` is used.\n            fontsize (int, optional): font size of the text inside the block. If not entered, default `fontsize` is used.\n            linestyle (string, optional): linestyle of the block edge: {'-, '--, ':', '-.'}.\n            orientation (string or float, optional): Direction of the block: {'horizontal', 'vertical', 'up', 'down', 'left', 'right', angle}.\n\n        Returns:\n            (Numpy.NDArray): Coordinates of the center position of the output edge of the block.\n        \"\"\"\n        # Parameters validation\n        if input_side not in (None, 'top', 'bottom'):\n            raise ValueError(f\"Invalid input_side: {input_side}. Use 'top' or 'bottom'.\")\n        if orientation not in (None, 'horizontal', 'vertical', 'up', 'down', 'left', 'right'):\n            if isinstance(orientation, (int, float)):\n                pass\n            else:\n                raise ValueError(f\"Invalid orientation: {orientation}. Use 'horizontal', 'vertical', 'up', 'down', 'left', or 'right'.\")\n        if linestyle not in (None, '-', '--', ':', '-.', 'solid', 'dashed', 'dotted', 'dashdot'):\n            raise ValueError(f\"Invalid linestyle: {linestyle}. Use '-', '--', ':', '-.', 'solid', 'dashed', 'dotted', or 'dashdot'.\")\n        if not isinstance(length, (int, float)) or length &lt;= 0:\n            raise ValueError(f\"Invalid length: {length}. Length must be a positive number.\")\n        if not isinstance(height, (int, float)) or height &lt;= 0:\n            raise ValueError(f\"Invalid height: {height}. Height must be a positive number.\")\n        if not isinstance(text_offset, (int, float)):\n            raise ValueError(f\"Invalid text_offset: {text_offset}. Text offset must be a number.\")\n        if not isinstance(fontsize, (int, float)):\n            raise ValueError(f\"Invalid fontsize: {fontsize}. Font size must be a number.\")\n\n\n        # Determine rotation angle based on orientation\n        if orientation in ['horizontal', 'right']:\n            angle = 0\n        elif orientation == 'left':\n            angle = 180\n        elif orientation in ['vertical', 'down']:\n            angle = -90\n        elif orientation == 'up':\n            angle = 90\n        elif isinstance(orientation, (int, float)):\n            angle = orientation\n        else:\n            angle = 0\n\n        x_in, y_in = initial_position\n\n        # Bottom-left corner of the block (before rotation)\n        x0 = x_in\n        y0 = y_in - height / 2\n\n        # Center of the block (before rotation)\n        cx = x_in + length / 2\n        cy = y_in\n\n        # Apply the rotation around the connection point (x_ini, y_ini)\n        trans = transforms.Affine2D().rotate_deg_around(x_in, y_in, angle) + self.ax.transData   \n\n        self.ax.add_patch(Rectangle((x0, y0), length, height, \n                                    edgecolor='black', facecolor='none', \n                                    linestyle=linestyle, transform=trans))\n        # Don't rotate text if orientation is vertical, down or up\n        rotate_text = False if orientation in ['vertical', 'down', 'up', 'left'] else True\n\n        # Draw text inside the block\n        if text is not None:\n            offset_vector = np.array([length / 2, 0])\n            self.__draw_rotated_text__(initial_position, text, \n                                       angle=angle, rotate_text=rotate_text,\n                                       ha='center', va='center', \n                                       fontsize=fontsize, offset=offset_vector)\n\n        # Draw text above the block\n        if text_above is not None:\n            if orientation in ['vertical', 'down']:\n                ha = 'left'\n                va = 'center'\n            elif orientation in ['up']:\n                ha = 'right'\n                va = 'center'\n            else:\n                ha = 'center'\n                va = 'bottom'\n            offset_vector = np.array([length / 2, height / 2 + text_offset])\n            self.__draw_rotated_text__(initial_position, text_above, \n                                       angle=angle, rotate_text=rotate_text,\n                                       ha=ha, va=va, \n                                       fontsize=fontsize, offset=offset_vector)\n\n        # Draw text below the block\n        if text_below is not None:\n            if orientation in ['vertical', 'down']:\n                ha = 'right'\n                va = 'center'\n            elif orientation in ['up']:\n                ha = 'left'\n                va = 'center'\n            else:\n                ha = 'center'\n                va = 'top'\n            offset_vector = np.array([length / 2, - height / 2 - text_offset])\n            self.__draw_rotated_text__(initial_position, text_below, \n                                       angle=angle, rotate_text=rotate_text,\n                                       ha=ha, va=va, \n                                       fontsize=fontsize, offset=offset_vector)\n\n        if input_side is not None:\n            if input_side == 'bottom':\n                arrow_height = 0.75 * height\n                y_init = y0 - arrow_height\n                offset_vector = np.array([length / 2, - height /2 - arrow_height - text_offset])\n                va = 'top'\n                ha = 'center'\n                if orientation in ['vertical', 'down']:\n                    ha = 'right'\n                    va = 'center'\n                elif orientation in ['up']:\n                    ha = 'left'\n                    va = 'center'\n                elif orientation in ['left']:\n                    ha = 'center'\n                    va = 'bottom'\n            elif input_side == 'top':\n                arrow_height = - 0.75 * height\n                y_init = y0 + height - arrow_height\n                offset_vector = np.array([length / 2, height /2 - arrow_height + text_offset])\n                va = 'bottom'\n                ha = 'center'\n                if orientation in ['vertical', 'down']:\n                    ha = 'left'\n                    va = 'center'\n                elif orientation in ['up']:\n                    ha = 'right'\n                    va = 'center'\n                elif orientation in ['left']:\n                    ha = 'center'\n                    va = 'top'\n            else:\n                raise ValueError(f\"Unknown input side: {input_side}. Use 'bottom' or 'top'.\")   \n\n            self.ax.add_patch(FancyArrow(cx, y_init, 0, arrow_height, width=0.01,\n                                    length_includes_head=True, head_width=0.15, \n                                    color='black', transform=trans))\n            if input_text is not None:\n\n                self.__draw_rotated_text__(initial_position, input_text, \n                                           angle=angle, rotate_text=rotate_text,\n                                           ha=ha, va=va, \n                                           fontsize=fontsize, offset=offset_vector)\n\n        # Compute rotated output point\n        output_pos = self.__get_rotated_pos__(initial_position, [length, 0], angle)\n        # Compute feedback point\n        feedback_pos = self.__get_rotated_pos__(initial_position, [length/2, -height/2], angle)\n        # Add element position to the dictionary\n        self.__add_element_position__(input_pos=[x_in,y_in], output_pos=output_pos,\n                                      feedback_pos=feedback_pos)\n        return output_pos\n\n    def __draw_arrow__(self, initial_position, length, text=None, \n                       text_position = 'above', text_offset=0.2, arrow = True,\n                       fontsize=14, orientation='horizontal'):\n        \"\"\"\n        Inner method.\n        Draws a horizontal arrow with optional label.\n\n        Args:\n            initial_position (Numpy.NDarray or list): Coordinates of the starting point of the arrow.\n            length (float, optional): Horizontal length of the block. If not entered, default `block_length` is used.\n            text (string, optional): Label to display in the block.\n            text_position (string, optional): Position of the optional text: {'before', 'after', 'above'}\n            text_offset (float, optional): Vertical offset for the text position.\n            arrow (bool, optional): Indicated if an line mush finish or not in an arrow.\n            fontsize (int, optional): font size of the text inside the block. If not entered, default `fontsize` is used.\n            orientation (string or float, optional): Direction of the block: {'horizontal', 'vertical', 'up', 'down', 'left', 'right', angle}.\n\n        Returns:\n            (Numpy.NDArray): Coordinates of output point of the arrow.\n        \"\"\"\n        # end = (initial_position[0] + length, initial_position[1])\n        head_width = 0.15 if arrow else 0\n\n        angle = 0\n        # Determine rotation angle based on orientation\n        if orientation in ['horizontal', 'right']:\n            angle = 0\n        elif orientation == 'left':\n            angle = 180\n        elif orientation in ['vertical', 'down']:\n            angle = -90\n        elif orientation == 'up':\n            angle = 90\n        elif isinstance(orientation, (int, float)):\n            angle = orientation\n        else:\n            angle = 0\n\n        x_in, y_in = initial_position\n\n        # Apply rotation around the connection point (x_ini, y_ini)\n        trans = transforms.Affine2D().rotate_deg_around(x_in, y_in, angle) + self.ax.transData   \n\n\n        self.ax.add_patch(FancyArrow(x_in, y_in, length, 0, width=0.01,\n                                length_includes_head=True, head_width=head_width, \n                                color='black', transform=trans))\n\n        # Don't rotate text if orientation is vertical, down or up\n        rotate_text = False if orientation in ['vertical', 'down', 'up', 'left'] else True\n\n        if text:\n            # Calculate offset vector based on orientation in non-rotated coordinates\n            if text_position == 'before':\n                ha, va = 'right', 'center'\n                offset_vector = np.array([-text_offset, 0])\n                if orientation in ['vertical', 'down']:\n                    ha = 'center'\n                    va = 'bottom'\n                elif orientation in ['up']:\n                    ha = 'center'\n                    va = 'top'\n            elif text_position == 'after':\n                ha, va = 'left', 'center'\n                offset_vector = np.array([length + text_offset, 0])\n                if orientation in ['vertical', 'down']:\n                    ha = 'center'\n                    va = 'top'\n                elif orientation in ['up']:\n                    ha = 'center'\n                    va = 'bottom'\n            elif text_position == 'above':\n                ha, va = 'center', 'bottom'\n                offset_vector = np.array([length / 2, text_offset])\n                if orientation in ['vertical', 'down',]:\n                    ha = 'left'\n                    va = 'bottom'\n                elif orientation in ['up']:\n                    ha = 'right'\n                    va = 'top'\n            else:\n                raise ValueError(f\"Unknown text_position: {text_position}\")\n\n            self.__draw_rotated_text__(initial_position, text, \n                                       angle=angle, rotate_text=rotate_text,\n                                       ha=ha, va=va, offset=offset_vector,\n                                       fontsize=fontsize)\n\n        # Compute rotated output point\n        output_pos = self.__get_rotated_pos__(initial_position, [length, 0], angle)\n        # Compute feedback point\n        feedback_pos = self.__get_rotated_pos__(initial_position, [length/2, 0], angle)\n        # Add element position to the dictionary\n        self.__add_element_position__(input_pos=[x_in,y_in], output_pos=output_pos,\n                                      feedback_pos=feedback_pos)\n        return output_pos\n\n    def __draw_angled_arrow__(self, initial_position, final_position, \n                            text=None, text_offset=0.2, arrow = True, fontsize=14,\n                            first_segment='horizontal', orientation='horizontal'):\n        \"\"\"\n        Inner method.\n        Draws a right-angled arrow composed of two segments, with a specified first segment orientation and optional label.\n\n        Args:\n            initial_position (Numpy.NDarray or list): Coordinates of the starting point of the arrow.\n            final_position (Numpy.NDarray or list): Coordinates of the ending point of the arrow.\n            text (string, optional): Label to display in the block.\n            text_offset (float, optional): Vertical offset for the text position.\n            arrow (bool, optional): Indicates if it must finish or not in an arrow.\n            fontsize (int, optional): font size of the text inside the block. If not entered, default `fontsize` is used.\n            first_segment (string, optional): Drawing order: {'horizontal', 'vertical'}\n            orientation (string or float, optional): Direction of the block: {'horizontal', 'vertical', 'up', 'down', 'left', 'right', angle}.\n\n        Returns:\n            (Numpy.NDArray): Coordinates of output point of the arrow.\n        \"\"\"\n        head_width = 0.15 if arrow else 0\n\n        angle = 0\n        # Determine rotation angle based on orientation\n        if orientation in ['horizontal', 'right']:\n            angle = 0\n        elif orientation == 'left':\n            angle = 180\n        elif orientation in ['vertical', 'down']:\n            angle = -90\n        elif orientation == 'up':\n            angle = 90\n        elif isinstance(orientation, (int, float)):\n            angle = orientation\n        else:\n            angle = 0\n\n        x_in, y_in = initial_position\n        x_out, y_out = final_position\n        dx = x_out - x_in\n        dy = y_out - y_in\n\n        # Apply rotation around the connection point (x_ini, y_ini)\n        trans = transforms.Affine2D().rotate_deg_around(x_in, y_in, angle) + self.ax.transData   \n\n        if first_segment == 'horizontal':\n            corner = (x_out, y_in)\n        elif first_segment == 'vertical':\n            corner = (x_in, y_out)\n        else:\n            raise ValueError(\"first_segment must be either 'horizontal' or 'vertical'\")\n\n        # Draw segments\n        if first_segment == 'horizontal':\n            if dx != 0:\n                self.ax.add_patch(FancyArrow(x_in, y_in, dx, 0, width=0.01,\n                        length_includes_head=True, head_width=0, \n                        color='black', transform=trans))\n            if dy != 0:\n                self.ax.add_patch(FancyArrow(corner[0], corner[1], 0, dy, width=0.01,\n                        length_includes_head=True, head_width=head_width, \n                        color='black', transform=trans))\n        else:  # first vertical\n            if dy != 0:\n                self.ax.add_patch(FancyArrow(x_in, y_in, 0, dy, width=0.01,\n                        length_includes_head=True, head_width=0, \n                        color='black', transform=trans))\n            if dx != 0:\n                self.ax.add_patch(FancyArrow(corner[0], corner[1], dx, 0, width=0.01,\n                        length_includes_head=True, head_width=head_width, \n                        color='black', transform=trans))\n\n        # Don't rotate text if orientation is vertical, down or up\n        rotate_text = False if orientation in ['vertical', 'down', 'up', 'left'] else True\n\n        # Optional text near the corner\n        if text:\n            # Calculate offset vector based on orientation in non-rotated coordinates\n            if first_segment == 'horizontal':\n                offset_vector = np.array([dx/2, text_offset])    \n            else: # first vertical\n                offset_vector = np.array([dx/2, dy + text_offset])    \n\n            self.__draw_rotated_text__(initial_position, text, \n                                       angle=angle, rotate_text=rotate_text,\n                                       ha='center', va='bottom', offset=offset_vector,\n                                       fontsize=fontsize)\n\n        # Compute rotated output point\n        output_pos = self.__get_rotated_pos__(final_position, [0, 0], angle)\n        # Compute feedback point\n        feedback_pos = self.__get_rotated_pos__(corner, [0, 0], angle)\n        # Save element position\n        self.__add_element_position__(input_pos=initial_position, output_pos=output_pos, feedback_pos=feedback_pos)\n\n        return output_pos\n\n    def __draw_combiner__(self, initial_position, height=1,\n                        input_text=None, input_side='bottom', operation='mult', \n                        text_offset=0.1, signs=[None, None], fontsize=14, orientation='horizontal'):\n        \"\"\"\n        Inner method.\n        Draws a combiner block: a circle with a multiplication sign (\u00d7), sum sign (+) \n        or substraction sign (-) inside, with optional signs on each input.\n\n        Args:\n            initial_position (Numpy.NDarray or list): Coordinates of the starting point of the arrow.\n            height (float, optional): Vertical height of the block. If not entered, default `block_height` is used.\n            input_text (string, optional): Label for the input arrow (below or above the arrow).\n            input_side (string, optional): Side of the lateral input: {'bottom', 'top'}.\n            operation (string, optional): Operation of the combiner: {'mult', 'sum', 'dif'}.\n            text_offset (float, optional): Vertical offset for the text position.\n            signs (list, optional): Sign to be shown on the horizontal (signs[0]) and vertical (signs[1]) inputs.\n            fontsize (int, optional): font size of the text inside the block. If not entered, default `fontsize` is used.\n            orientation (string or float, optional): Direction of the block: {'horizontal', 'vertical', 'up', 'down', 'left', 'right', angle}.\n\n        Returns:\n            (Numpy.NDArray): Coordinates of output point of the combiner.\n        \"\"\"\n        angle = 0\n        # Determine rotation angle based on orientation\n        if orientation in ['horizontal', 'right']:\n            angle = 0\n        elif orientation == 'left':\n            angle = 180\n        elif orientation in ['vertical', 'down']:\n            angle = -90\n        elif orientation == 'up':\n            angle = 90\n        elif isinstance(orientation, (int, float)):\n            angle = orientation\n        else:\n            angle = 0\n\n        x_in, y_in = initial_position\n\n        radius = height / 4\n        # Center of the block (before rotation)\n        cx = x_in + radius\n        cy = y_in\n\n        # Apply rotation around the connection point (x_ini, y_ini)\n        trans = transforms.Affine2D().rotate_deg_around(x_in, y_in, angle) + self.ax.transData  \n\n        circle = plt.Circle((cx, cy), radius, edgecolor='black', \n                            facecolor='white', transform=trans, zorder=2)\n        self.ax.add_patch(circle)\n\n        rel_size = 0.7\n        if operation == 'mult':\n            # L\u00edneas diagonales (forma de \"X\") dentro del c\u00edrculo\n            dx = radius * rel_size * np.cos(np.pi / 4)  # Escalamos un poco para que quepa dentro del c\u00edrculo\n            dy = radius * rel_size * np.sin(np.pi / 4)\n            # L\u00ednea de 45\u00b0\n            self.ax.plot([cx - dx, cx + dx], [cy - dy, cy + dy], color='black', \n                         linewidth=2, transform=trans, zorder=3)\n            # L\u00ednea de 135\u00b0\n            self.ax.plot([cx - dx, cx + dx], [cy + dy, cy - dy], color='black', \n                         linewidth=2, transform=trans, zorder=3)\n\n        elif operation == 'sum':\n            dx = radius * rel_size\n            dy = radius * rel_size\n            # L\u00edneas horizontales y verticales (forma de \"+\") dentro del c\u00edrculo\n            self.ax.plot([cx - dx, cx + dx], [cy, cy], color='black', \n                         linewidth=2, transform=trans, zorder=3)\n            self.ax.plot([cx, cx], [cy - dy, cy + dy], color='black', \n                         linewidth=2, transform=trans, zorder=3)\n        elif operation == 'dif':\n            dx = radius * rel_size\n            # L\u00ednea horizontal (forma de \"-\") dentro del c\u00edrculo\n            self.ax.plot([cx - dx, cx + dx], [cy, cy], color='black', \n                         linewidth=2, transform=trans, zorder=3)\n        else:\n            raise ValueError(f\"Unknown operation: {operation}. 'operation' must be 'mult', 'sum' or 'dif'.\")\n\n        # Don't rotate text if orientation is vertical, down or up\n        rotate_text = False if orientation in ['vertical', 'down', 'up', 'left'] else True\n\n        # Side input\n        if input_side == 'bottom':\n            arrow_height = height - radius\n            y_init = y_in - radius - arrow_height\n            offset_vector = np.array([radius, - (height + text_offset)])\n            va = 'top'\n            ha = 'center'\n            if orientation in ['vertical', 'down']:\n                ha = 'right'\n                va = 'center'\n            elif orientation in ['up']:\n                ha = 'left'\n                va = 'center'\n        elif input_side == 'top':\n            arrow_height = - (height - radius)\n            y_init = y_in + radius - arrow_height\n            offset_vector = np.array([radius, height + text_offset])\n            va = 'bottom'\n            ha = 'center'\n            if orientation in ['vertical', 'down']:\n                ha = 'left'\n                va = 'center'\n            elif orientation in ['up']:\n                ha = 'right'\n                va = 'center'\n        else:\n            raise ValueError(f\"Unknown input_side: {input_side}. 'input_side' must be 'bottom' or 'top'.\")\n\n        # Show signs on each input if not None\n        if signs[0] is not None:\n            self.__draw_rotated_text__(initial_position, signs[0], \n                                    angle=angle, rotate_text=rotate_text,\n                                    ha=ha, va=va, \n                                    fontsize=fontsize, offset=[-radius, 1.5*radius])\n        if signs[1] is not None:\n            self.__draw_rotated_text__(initial_position, signs[1], \n                                    angle=angle, rotate_text=rotate_text,\n                                    ha=ha, va=va, \n                                    fontsize=fontsize, offset=[0, -1.5*radius])\n\n        self.ax.add_patch(FancyArrow(cx, y_init, 0, arrow_height, width=0.01,\n                                length_includes_head=True, head_width=0.15, \n                                color='black', transform=trans))\n        if input_text is not None:\n            self.__draw_rotated_text__(initial_position, input_text, \n                                       angle=angle, rotate_text=rotate_text,\n                                       ha=ha, va=va, \n                                       fontsize=fontsize, offset=offset_vector)\n\n        # Compute rotated output point\n        output_pos = self.__get_rotated_pos__(initial_position, [2 * radius, 0], angle)\n        # Compute feedback point\n        feedback_pos = self.__get_rotated_pos__(initial_position, [radius, y_init - y_in + arrow_height], angle)\n        # Add element position to the dictionary\n        self.__add_element_position__(input_pos=[x_in,y_in], output_pos=output_pos,\n                                      feedback_pos=feedback_pos)\n        return output_pos\n\n    def __draw_mult_combiner__(self, initial_position, length, inputs, \n                               operation='sum', orientation='horizontal'):\n        \"\"\"\n        Inner method.\n        Draws a summation or multiplication block with multiple inputs distributed \n        along the left edge of a circle, from pi/2 to 3*pi/2. Inputs can have a sign.\n\n        Args:\n            initial_position (Numpy.NDarray or list): Coordinates of the starting point of the arrow.\n            length (float, optional): Horizontal length of the block. If not entered, default `block_length` is used.\n            inputs (list of str): Thread names to combine.\n            operation (string, optional): Operation of the combiner: {'mult', 'sum'}.\n            orientation (string or float, optional): Direction of the block: {'horizontal', 'vertical', 'up', 'down', 'left', 'right', angle}.\n\n        Returns:\n            (Numpy.NDArray): Coordinates of output point of the combiner.\n        \"\"\"\n        angle = 0\n        # Determine rotation angle based on orientation\n        if orientation in ['horizontal', 'right']:\n            angle = 0\n        elif orientation == 'left':\n            angle = 180\n        elif orientation in ['vertical', 'down']:\n            angle = -90\n        elif orientation == 'up':\n            angle = 90\n        elif isinstance(orientation, (int, float)):\n            angle = orientation\n        else:\n            angle = 0\n\n        # If position is 'auto', obtain head position\n        if isinstance(initial_position, str) and initial_position == 'auto':\n            # Get head positions of input threads\n            thread_input_pos = np.array([self.thread_positions[key] for key in inputs])\n            x_in = np.max(thread_input_pos[:, 0])\n            y_in = np.mean(thread_input_pos[:,1])\n            initial_position = [x_in, y_in]\n        # If position is given, use it\n        else:\n            x_in, y_in = initial_position\n\n        radius = length / 4\n        cx = x_in + length - radius\n        cy = y_in\n\n        # Apply rotation around the connection point (x_ini, y_ini)\n        trans = transforms.Affine2D().rotate_deg_around(x_in, y_in, angle) + self.ax.transData  \n\n        # Circle\n        circle = plt.Circle((cx, cy), radius, edgecolor='black', \n                            facecolor='white', transform=trans, zorder=2)\n        self.ax.add_patch(circle)\n\n        # Draw symbol inside circle depending on operation\n        rel_size = 0.7\n        if operation == 'mult':\n            # \"X\" inside circle\n            dx = radius * rel_size * np.cos(np.pi / 4)  # Escalamos un poco para que quepa dentro del c\u00edrculo\n            dy = radius * rel_size * np.sin(np.pi / 4)\n            #  45\u00b0 line\n            self.ax.plot([cx - dx, cx + dx], [cy - dy, cy + dy], color='black', \n                         linewidth=2, transform=trans, zorder=3)\n            # 135\u00b0 line\n            self.ax.plot([cx - dx, cx + dx], [cy + dy, cy - dy], color='black', \n                         linewidth=2, transform=trans, zorder=3)\n        elif operation == 'sum':\n            dx = radius * rel_size\n            dy = radius * rel_size\n            # \"+\" inside circle\n            self.ax.plot([cx - dx, cx + dx], [cy, cy], color='black', \n                         linewidth=2, transform=trans, zorder=3)\n            self.ax.plot([cx, cx], [cy - dy, cy + dy], color='black', \n                         linewidth=2, transform=trans, zorder=3)\n        else:\n            raise ValueError(f\"Unknown operation: {operation}. Use 'sum' or 'mult'.\")\n\n        # Get rotation matrix\n        rot_matrix = transforms.Affine2D().rotate_deg(angle).get_matrix()[:2, :2]\n\n        n = len(thread_input_pos)\n        angles = np.linspace(5* np.pi / 8, 11 * np.pi / 8, n)\n\n        arrow_width = 0.01\n        arrow_head_width = 0.15\n\n        # Input arrows\n        for i, inp in enumerate(thread_input_pos):\n            xi, yi = inp[:2]\n\n            x_edge = cx + radius * np.cos(angles[i])\n            y_edge = cy + radius * np.sin(angles[i])\n\n            dx = x_edge - x_in\n            dy = y_edge - y_in\n            offset_vec = [dx, dy]\n\n            # Rotated offset vector with respect to initial_position of element\n            dx_rot, dy_rot = rot_matrix @ offset_vec\n            # Rotated offset vector with respect to initial position of arrow\n            dx_rot_rel = dx_rot - xi + x_in\n            dy_rot_rel = dy_rot - yi + y_in\n\n            self.ax.add_patch(FancyArrow(\n                xi, yi, dx_rot_rel, dy_rot_rel,\n                width=arrow_width,\n                length_includes_head=True,\n                head_width=arrow_head_width,\n                color='black', transform=self.ax.transData, zorder=1\n            ))\n\n        # Compute rotated output point\n        output_pos = self.__get_rotated_pos__(initial_position, [length, 0], angle)\n        # Compute feedback point\n        feedback_pos = self.__get_rotated_pos__(initial_position, [length - radius, -radius], angle)\n        # Add element position to the dictionary\n        self.__add_element_position__(input_pos=[x_in,y_in], output_pos=output_pos,\n                                      feedback_pos=feedback_pos)\n        return output_pos\n\n    def add(self,name, kind='block', thread='main', position=None, debug=False, **kwargs):\n        \"\"\"\n        Adds an element to the block diagram at the current or specified position of a given thread.\n\n        This is the main interface for constructing diagrams by adding components such as blocks, arrows,\n        inputs, outputs, combiners, and connectors. The `kind` parameter determines the type of element,\n        and each type accepts specific keyword arguments listed below.\n\n        Args:\n            name (str): Main label or identifier for the element.\n            kind (str, optional): Type of element. One of:\n                - 'block': Rectangular block.\n                - 'arrow': Straight line with ending arrow.\n                - 'angled_arrow': Rect angle line with or without ending arrow.\n                - 'input': Arrow with text before it.\n                - 'output': Arrow with text after it.\n                - 'line': Straight line without arrow ending.\n                - 'combiner': Circle with (x), (+) or (-) and additional input.\n                - 'mult_combiner': Combiner with multiple inputs.\n            thread (str, optional): Thread identifier.\n            position (tuple or str or None, optional): (x, y) position, 'auto' (for mult_combiner), or None to use current thread position.\n            debug (bool, optional): If True, prints thread positions after placing the element.\n\n        The `**kwargs` vary depending on the `kind`:\n\n        - **kind = 'block'**:\n            - text (str, optional): Label inside the block (defaults to `name`).\n            - text_above (str, optional): Text above the block.\n            - text_below (str, optional): Text below the block.\n            - text_offset (float, optional): Offset for above/below text (defaults to 0.1).\n            - input_text (str, optional): Label for input arrow.\n            - input_side (str, optional): Side of a second optional input: {'top', 'bottom'} (defaults to `None`)\n            - length (float, optional): Block length (defaults to `self.block_length`).\n            - height (float, optional): Block height (defaults to `self.block_height`)..\n            - linestyle (str, optional): Block border line style (defaults to `-`).\n            - orientation (str or float, optional): Orientation of the block: {'horizontal', 'vertical', 'up', 'down' 'right', left' or angle in degrees} (defaults to 'horizontal').\n            - fontsize (int, optional): Text font size (defaults to `self.fontsize`).\n\n        - **kind = 'arrow'**, **'input'**, **'output'** or **'line'**:\n            - text (str, optional): Text on the arrow or line (defaults to `name`).\n            - text_position (str, optional): 'above', 'below', 'before', or 'after' (defaults to 'above' for 'arrow' and 'line', 'before' for 'input', and 'after' for 'output').\n            - text_offset (float, optional): Offset for text (defaults to 0.1).\n            - length (float, optional): Arrow or line length (defaults to `self.block_length`).\n            - orientation (str or float, optional): Orientation of the block: {'horizontal', 'vertical', 'up', 'down' 'right', left' or angle in degrees} (defaults to 'horizontal').\n            - fontsize (int, optional): Text font size (defaults to `self.fontsize`).\n\n        - **kind = 'angled_arrow'**:\n            - text (str, optional): Text on the arrow or line (defaults to `name`).\n            - final_pos (Numpy.NDarray or list): Coordinates of the ending point of the arrow.\n            - text_position (str, optional): 'above', 'below', 'before', or 'after' (defaults to 'above' for 'arrow' and 'line', 'before' for 'input', and 'after' for 'output').\n            - text_offset (float, optional): Offset for text (defaults to 0.1).\n            - arrow (bool, optional): Indicates if it must finish or not in an arrow.\n            - first_segment (string, optional): Drawing order: {'horizontal', 'vertical'}\n            - orientation (str or float, optional): Orientation of the block: {'horizontal', 'vertical', 'up', 'down' 'right', left' or angle in degrees} (defaults to 'horizontal').\n            - fontsize (int, optional): Text font size (defaults to `self.fontsize`).\n\n        - **kind = 'combiner'**:\n            - operation (string, optional): Operation of the combiner: {'mult', 'sum', 'dif'} (defaultds to 'mult').\n            - height (float, optional): Vertical height of the block. (defaults to `self.block_height`).\n            - input_side (string, optional): Side of the lateral input: {'bottom', 'top'} (defaults to 'bottom').\n            - input_text (string, optional): Label for the input arrow (below or above the arrow).\n            - text_offset (float, optional): Offset for text (defaults to 0.1).\n            - signs (list, optional): Sign to be shown on the horizontal (signs[0]) and vertical (signs[1]) inputs.\n            - orientation (str or float, optional): Orientation of the block: {'horizontal', 'vertical', 'up', 'down' 'right', left' or angle in degrees} (defaults to 'horizontal').\n            - fontsize (int, optional): Text font size (defaults to `self.fontsize`).\n\n        - **kind = 'mult_combiner'**:\n            - operation (string, optional): Operation of the combiner: {'mult', 'sum', 'dif'} (defaults to 'mult').\n            - length (float, optional): Total element length (defaults to `self.block_length`).\n            - inputs (list of str): Thread names to combine.\n            - operation (string, optional): Operation of the combiner: {'mult', 'sum'} (defaults to 'sum').\n            - orientation (str or float, optional): Orientation of the block: {'horizontal', 'vertical', 'up', 'down' 'right', left' or angle in degrees} (defaults to 'horizontal').\n            - fontsize (int, optional): Text font size (defaults to `self.fontsize`).\n\n        Examples:\n            &gt;&gt;&gt; db = DiagramBuilder()\n            &gt;&gt;&gt; db.add(\"x(t)\", kind=\"input\")\n            &gt;&gt;&gt; db.add(\"H(s)\", kind=\"block\")\n            &gt;&gt;&gt; db.add(\"y(t)\", kind=\"output\")\n        \"\"\"\n\n        # If position is 'auto' (draw_mult_combiner), position is calculated inside that method\n        if isinstance(position, str) and position == 'auto':\n            initial_pos = 'auto'\n        # If input argument position is given and not 'auto', element position is asigned to position argument value\n        elif position is not None:\n            initial_pos = list(position)\n        # If not given\n        else:\n            # If thread already exists, element position is asigned from thread head\n            if thread in self.thread_positions:\n                initial_pos = self.thread_positions[thread]\n            # If doesn't exist\n            else:\n                initial_pos = [0, 0]\n\n        if kind == 'arrow':\n            # Default arguments\n            default_kwargs = {\n                'text': name,\n                'text_position': 'above',\n                'arrow': True,\n                'text_offset': 0.1,\n                'length': self.block_length,\n                'fontsize': self.fontsize,\n                'orientation': 'horizontal'\n            }\n            # Overrides default arguments with provided ones\n            block_args = {**default_kwargs, **kwargs}\n            # Function call\n            final_pos = self.__draw_arrow__(initial_pos, **block_args)\n\n        elif kind == 'angled_arrow':\n            # Default arguments\n            default_kwargs = {\n                'text': name,\n                'text_offset': 0.1,\n                'fontsize': self.fontsize,\n                'orientation': 'horizontal',\n            }\n            # Overrides default arguments with provided ones\n            block_args = {**default_kwargs, **kwargs}\n            # Function call\n            final_pos = self.__draw_angled_arrow__(initial_pos, **block_args)\n\n        elif kind == 'input':\n            # Default arguments\n            default_kwargs = {\n                'text': name,\n                'text_position': 'before',\n                'arrow': True,\n                'text_offset': 0.1,\n                'length': self.block_length,\n                'fontsize': self.fontsize,\n                'orientation': 'horizontal'\n            }\n            # Overrides default arguments with provided ones\n            block_args = {**default_kwargs, **kwargs}\n            # Function call\n            final_pos = self.__draw_arrow__(initial_pos, **block_args)\n\n        elif kind == 'output':\n            # Default arguments\n            default_kwargs = {\n                'text': name,\n                'text_position': 'after',\n                'arrow': True,\n                'text_offset': 0.1,\n                'length': self.block_length,\n                'fontsize': self.fontsize,\n                'orientation': 'horizontal'\n            }\n            # Overrides default arguments with provided ones\n            block_args = {**default_kwargs, **kwargs}\n            # Function call\n            final_pos = self.__draw_arrow__(initial_pos, **block_args)\n\n        elif kind == 'line':\n            # Default arguments\n            default_kwargs = {\n                'text': name,\n                'text_position': 'above',\n                'arrow': False,\n                'text_offset': 0.1,\n                'length': self.block_length,\n                'fontsize': self.fontsize,\n                'orientation': 'horizontal'\n            }\n            # Overrides default arguments with provided ones\n            block_args = {**default_kwargs, **kwargs}\n            # Function call\n            final_pos = self.__draw_arrow__(initial_pos, **block_args)\n\n        elif kind == 'block':\n            # Default arguments\n            default_kwargs = {\n                'text': name,\n                'text_above': None,\n                'text_below': None,\n                'text_offset': 0.1,\n                'input_text': None,\n                'input_side': None,\n                'length': self.block_length,\n                'height': self.block_height,\n                'fontsize': self.fontsize,\n                'linestyle': '-',\n                'orientation': 'horizontal'\n            }\n            # Overrides default arguments with provided ones\n            block_args = {**default_kwargs, **kwargs}\n            # Function call\n            final_pos = self.__draw_block__(initial_pos, **block_args)\n\n        elif kind == 'combiner':\n            # Default arguments\n            default_kwargs = {\n                'height': self.block_height,\n                'fontsize': self.fontsize,\n                'operation': 'mult',\n                'input_side': 'bottom',\n                'orientation': 'horizontal'\n            }\n            # Overrides default arguments with provided ones\n            block_args = {**default_kwargs, **kwargs}\n            # Function call\n            final_pos = self.__draw_combiner__(initial_pos, **block_args)\n\n        elif kind == 'mult_combiner':\n            # Default arguments\n            default_kwargs = {\n                'length': self.block_length,\n                'operation': 'mult',\n                'orientation': 'horizontal'\n            }\n            # Overrides default arguments with provided ones\n            block_args = {**default_kwargs, **kwargs}\n            # Function call\n            final_pos = self.__draw_mult_combiner__(initial_pos, **block_args)\n\n\n        elif kind == 'output':\n            length=kwargs.get('length', self.block_length)\n            final_pos = self.__draw_io_arrow__(initial_pos, length=length, text=kwargs.get('text', name),\n                          io='output', fontsize=self.fontsize)\n\n        else:\n            raise ValueError(f\"Unknown block type: {kind}\")\n\n        # Update head position of thread\n        self.thread_positions[thread] = final_pos\n\n        if debug:\n            self.__print_threads__()\n\n    def get_current_element(self):\n        \"\"\"\n        Returns the current element index (last added).\n\n        Returns:\n            (int): Index of the last added element.\n        \"\"\"\n        return self.current_element\n\n    def get_position(self, element=None):\n        \"\"\"\n        Returns the positions of the specified element index. If no element specified, last added element is used.\n        The return is a dictinoary with coordinates of `input_pos`, `output_pos` and `feedback_pos` (feedback port coordinates).\n\n        Args:\n            element (int, optional): index of the element.\n\n        Returns:\n            (dict of Tuples): Dictionary with three 2-element tuples: `input_pos`, `output_pos` and `feedback_pos`.\n        \"\"\"\n        if element is None:\n            return self.element_positions[self.current_element]\n        elif element &lt;= self.current_element:\n            return self.element_positions[element]\n        else:\n            raise ValueError(f\"Element '{element}' not found.\")\n\n    def get_thread_position(self, thread='main'):\n        \"\"\"\n        Returns the current output position of the specified thread.\n\n        Args:\n            thread (str, optional): Thread identifier.\n        \"\"\"\n        if thread in self.thread_positions:\n            return self.thread_positions[thread]\n        else:\n            raise ValueError(f\"Thread '{thread}' not found.\")\n\n\n    def show(self, margin=0.5, scale=1.0, savepath=None):\n        \"\"\"\n        Displays the current diagram or saves it to a file.\n\n        Adjusts the view to fit the full diagram with an optional margin and scaling factor.\n        If no elements have been drawn, simply displays an empty figure.\n\n        Args:\n            margin (float, optional): Margin to add around the diagram (in data units).\n            scale (float, optional): Scaling factor for the figure size.\n            savepath (str, optional): If provided, saves the figure to the specified path (e.g., 'diagram.png' or 'diagram.pdf').\n                                      If None, the diagram is shown in an interactive window.\n\n        \"\"\"\n        bbox = self.__get_bbox__()\n        if bbox is None:\n            plt.show()\n            return\n\n        x0 = bbox.x0 - margin\n        x1 = bbox.x1 + margin\n        y0 = bbox.y0 - margin\n        y1 = bbox.y1 + margin\n\n        width = x1 - x0\n        height = y1 - y0\n\n        fig_width = width * scale\n        fig_height = height * scale\n        self.fig.set_size_inches(fig_width, fig_height)\n\n        self.ax.set_xlim(x0, x1)\n        self.ax.set_ylim(y0, y1)\n        self.ax.set_aspect(\"equal\", adjustable=\"box\")\n        self.ax.set_position([0, 0, 1, 1])\n        self.ax.axis(\"off\")\n\n        if savepath:\n            self.fig.savefig(savepath, bbox_inches='tight', dpi=self.fig.dpi, transparent=False, facecolor='white')\n            print(f\"Saved in: {savepath}\")\n        else:\n            plt.show()\n</code></pre>"},{"location":"reference/#blockdiagrams.DiagramBuilder.DiagramBuilder.__add_element_position__","title":"<code>__add_element_position__(input_pos, output_pos, feedback_pos)</code>","text":"<p>Inner method. Adds a new element with the given input, output and feedback positions.</p> <p>Parameters:</p> Name Type Description Default <code>input_pos</code> <code>NDArray or list</code> <p>Input position of the block.</p> required <code>output_pos</code> <code>NDArray or list</code> <p>Output position of the block.</p> required <code>feedback_pos</code> <code>NDArray or list</code> <p>Feedback port position of the block.</p> required Source code in <code>blockdiagrams\\DiagramBuilder.py</code> <pre><code>def __add_element_position__(self, input_pos: Tuple[float, float], \n                             output_pos: Tuple[float, float], \n                             feedback_pos: Tuple[float, float]):\n    \"\"\"\n    Inner method.\n    Adds a new element with the given input, output and feedback positions.\n\n    Args:\n        input_pos (Numpy.NDArray or list): Input position of the block.\n        output_pos (Numpy.NDArray or list): Output position of the block.\n        feedback_pos (Numpy.NDArray or list): Feedback port position of the block.\n    \"\"\"\n    self.current_element += 1\n\n    self.element_positions[self.current_element] = ElementPosition(\n        input_pos=input_pos,\n        output_pos=output_pos,\n        feedback_pos=feedback_pos\n    )\n</code></pre>"},{"location":"reference/#blockdiagrams.DiagramBuilder.DiagramBuilder.__draw_angled_arrow__","title":"<code>__draw_angled_arrow__(initial_position, final_position, text=None, text_offset=0.2, arrow=True, fontsize=14, first_segment='horizontal', orientation='horizontal')</code>","text":"<p>Inner method. Draws a right-angled arrow composed of two segments, with a specified first segment orientation and optional label.</p> <p>Parameters:</p> Name Type Description Default <code>initial_position</code> <code>NDarray or list</code> <p>Coordinates of the starting point of the arrow.</p> required <code>final_position</code> <code>NDarray or list</code> <p>Coordinates of the ending point of the arrow.</p> required <code>text</code> <code>string</code> <p>Label to display in the block.</p> <code>None</code> <code>text_offset</code> <code>float</code> <p>Vertical offset for the text position.</p> <code>0.2</code> <code>arrow</code> <code>bool</code> <p>Indicates if it must finish or not in an arrow.</p> <code>True</code> <code>fontsize</code> <code>int</code> <p>font size of the text inside the block. If not entered, default <code>fontsize</code> is used.</p> <code>14</code> <code>first_segment</code> <code>string</code> <p>Drawing order: {'horizontal', 'vertical'}</p> <code>'horizontal'</code> <code>orientation</code> <code>string or float</code> <p>Direction of the block: {'horizontal', 'vertical', 'up', 'down', 'left', 'right', angle}.</p> <code>'horizontal'</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>Coordinates of output point of the arrow.</p> Source code in <code>blockdiagrams\\DiagramBuilder.py</code> <pre><code>def __draw_angled_arrow__(self, initial_position, final_position, \n                        text=None, text_offset=0.2, arrow = True, fontsize=14,\n                        first_segment='horizontal', orientation='horizontal'):\n    \"\"\"\n    Inner method.\n    Draws a right-angled arrow composed of two segments, with a specified first segment orientation and optional label.\n\n    Args:\n        initial_position (Numpy.NDarray or list): Coordinates of the starting point of the arrow.\n        final_position (Numpy.NDarray or list): Coordinates of the ending point of the arrow.\n        text (string, optional): Label to display in the block.\n        text_offset (float, optional): Vertical offset for the text position.\n        arrow (bool, optional): Indicates if it must finish or not in an arrow.\n        fontsize (int, optional): font size of the text inside the block. If not entered, default `fontsize` is used.\n        first_segment (string, optional): Drawing order: {'horizontal', 'vertical'}\n        orientation (string or float, optional): Direction of the block: {'horizontal', 'vertical', 'up', 'down', 'left', 'right', angle}.\n\n    Returns:\n        (Numpy.NDArray): Coordinates of output point of the arrow.\n    \"\"\"\n    head_width = 0.15 if arrow else 0\n\n    angle = 0\n    # Determine rotation angle based on orientation\n    if orientation in ['horizontal', 'right']:\n        angle = 0\n    elif orientation == 'left':\n        angle = 180\n    elif orientation in ['vertical', 'down']:\n        angle = -90\n    elif orientation == 'up':\n        angle = 90\n    elif isinstance(orientation, (int, float)):\n        angle = orientation\n    else:\n        angle = 0\n\n    x_in, y_in = initial_position\n    x_out, y_out = final_position\n    dx = x_out - x_in\n    dy = y_out - y_in\n\n    # Apply rotation around the connection point (x_ini, y_ini)\n    trans = transforms.Affine2D().rotate_deg_around(x_in, y_in, angle) + self.ax.transData   \n\n    if first_segment == 'horizontal':\n        corner = (x_out, y_in)\n    elif first_segment == 'vertical':\n        corner = (x_in, y_out)\n    else:\n        raise ValueError(\"first_segment must be either 'horizontal' or 'vertical'\")\n\n    # Draw segments\n    if first_segment == 'horizontal':\n        if dx != 0:\n            self.ax.add_patch(FancyArrow(x_in, y_in, dx, 0, width=0.01,\n                    length_includes_head=True, head_width=0, \n                    color='black', transform=trans))\n        if dy != 0:\n            self.ax.add_patch(FancyArrow(corner[0], corner[1], 0, dy, width=0.01,\n                    length_includes_head=True, head_width=head_width, \n                    color='black', transform=trans))\n    else:  # first vertical\n        if dy != 0:\n            self.ax.add_patch(FancyArrow(x_in, y_in, 0, dy, width=0.01,\n                    length_includes_head=True, head_width=0, \n                    color='black', transform=trans))\n        if dx != 0:\n            self.ax.add_patch(FancyArrow(corner[0], corner[1], dx, 0, width=0.01,\n                    length_includes_head=True, head_width=head_width, \n                    color='black', transform=trans))\n\n    # Don't rotate text if orientation is vertical, down or up\n    rotate_text = False if orientation in ['vertical', 'down', 'up', 'left'] else True\n\n    # Optional text near the corner\n    if text:\n        # Calculate offset vector based on orientation in non-rotated coordinates\n        if first_segment == 'horizontal':\n            offset_vector = np.array([dx/2, text_offset])    \n        else: # first vertical\n            offset_vector = np.array([dx/2, dy + text_offset])    \n\n        self.__draw_rotated_text__(initial_position, text, \n                                   angle=angle, rotate_text=rotate_text,\n                                   ha='center', va='bottom', offset=offset_vector,\n                                   fontsize=fontsize)\n\n    # Compute rotated output point\n    output_pos = self.__get_rotated_pos__(final_position, [0, 0], angle)\n    # Compute feedback point\n    feedback_pos = self.__get_rotated_pos__(corner, [0, 0], angle)\n    # Save element position\n    self.__add_element_position__(input_pos=initial_position, output_pos=output_pos, feedback_pos=feedback_pos)\n\n    return output_pos\n</code></pre>"},{"location":"reference/#blockdiagrams.DiagramBuilder.DiagramBuilder.__draw_arrow__","title":"<code>__draw_arrow__(initial_position, length, text=None, text_position='above', text_offset=0.2, arrow=True, fontsize=14, orientation='horizontal')</code>","text":"<p>Inner method. Draws a horizontal arrow with optional label.</p> <p>Parameters:</p> Name Type Description Default <code>initial_position</code> <code>NDarray or list</code> <p>Coordinates of the starting point of the arrow.</p> required <code>length</code> <code>float</code> <p>Horizontal length of the block. If not entered, default <code>block_length</code> is used.</p> required <code>text</code> <code>string</code> <p>Label to display in the block.</p> <code>None</code> <code>text_position</code> <code>string</code> <p>Position of the optional text: {'before', 'after', 'above'}</p> <code>'above'</code> <code>text_offset</code> <code>float</code> <p>Vertical offset for the text position.</p> <code>0.2</code> <code>arrow</code> <code>bool</code> <p>Indicated if an line mush finish or not in an arrow.</p> <code>True</code> <code>fontsize</code> <code>int</code> <p>font size of the text inside the block. If not entered, default <code>fontsize</code> is used.</p> <code>14</code> <code>orientation</code> <code>string or float</code> <p>Direction of the block: {'horizontal', 'vertical', 'up', 'down', 'left', 'right', angle}.</p> <code>'horizontal'</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>Coordinates of output point of the arrow.</p> Source code in <code>blockdiagrams\\DiagramBuilder.py</code> <pre><code>def __draw_arrow__(self, initial_position, length, text=None, \n                   text_position = 'above', text_offset=0.2, arrow = True,\n                   fontsize=14, orientation='horizontal'):\n    \"\"\"\n    Inner method.\n    Draws a horizontal arrow with optional label.\n\n    Args:\n        initial_position (Numpy.NDarray or list): Coordinates of the starting point of the arrow.\n        length (float, optional): Horizontal length of the block. If not entered, default `block_length` is used.\n        text (string, optional): Label to display in the block.\n        text_position (string, optional): Position of the optional text: {'before', 'after', 'above'}\n        text_offset (float, optional): Vertical offset for the text position.\n        arrow (bool, optional): Indicated if an line mush finish or not in an arrow.\n        fontsize (int, optional): font size of the text inside the block. If not entered, default `fontsize` is used.\n        orientation (string or float, optional): Direction of the block: {'horizontal', 'vertical', 'up', 'down', 'left', 'right', angle}.\n\n    Returns:\n        (Numpy.NDArray): Coordinates of output point of the arrow.\n    \"\"\"\n    # end = (initial_position[0] + length, initial_position[1])\n    head_width = 0.15 if arrow else 0\n\n    angle = 0\n    # Determine rotation angle based on orientation\n    if orientation in ['horizontal', 'right']:\n        angle = 0\n    elif orientation == 'left':\n        angle = 180\n    elif orientation in ['vertical', 'down']:\n        angle = -90\n    elif orientation == 'up':\n        angle = 90\n    elif isinstance(orientation, (int, float)):\n        angle = orientation\n    else:\n        angle = 0\n\n    x_in, y_in = initial_position\n\n    # Apply rotation around the connection point (x_ini, y_ini)\n    trans = transforms.Affine2D().rotate_deg_around(x_in, y_in, angle) + self.ax.transData   \n\n\n    self.ax.add_patch(FancyArrow(x_in, y_in, length, 0, width=0.01,\n                            length_includes_head=True, head_width=head_width, \n                            color='black', transform=trans))\n\n    # Don't rotate text if orientation is vertical, down or up\n    rotate_text = False if orientation in ['vertical', 'down', 'up', 'left'] else True\n\n    if text:\n        # Calculate offset vector based on orientation in non-rotated coordinates\n        if text_position == 'before':\n            ha, va = 'right', 'center'\n            offset_vector = np.array([-text_offset, 0])\n            if orientation in ['vertical', 'down']:\n                ha = 'center'\n                va = 'bottom'\n            elif orientation in ['up']:\n                ha = 'center'\n                va = 'top'\n        elif text_position == 'after':\n            ha, va = 'left', 'center'\n            offset_vector = np.array([length + text_offset, 0])\n            if orientation in ['vertical', 'down']:\n                ha = 'center'\n                va = 'top'\n            elif orientation in ['up']:\n                ha = 'center'\n                va = 'bottom'\n        elif text_position == 'above':\n            ha, va = 'center', 'bottom'\n            offset_vector = np.array([length / 2, text_offset])\n            if orientation in ['vertical', 'down',]:\n                ha = 'left'\n                va = 'bottom'\n            elif orientation in ['up']:\n                ha = 'right'\n                va = 'top'\n        else:\n            raise ValueError(f\"Unknown text_position: {text_position}\")\n\n        self.__draw_rotated_text__(initial_position, text, \n                                   angle=angle, rotate_text=rotate_text,\n                                   ha=ha, va=va, offset=offset_vector,\n                                   fontsize=fontsize)\n\n    # Compute rotated output point\n    output_pos = self.__get_rotated_pos__(initial_position, [length, 0], angle)\n    # Compute feedback point\n    feedback_pos = self.__get_rotated_pos__(initial_position, [length/2, 0], angle)\n    # Add element position to the dictionary\n    self.__add_element_position__(input_pos=[x_in,y_in], output_pos=output_pos,\n                                  feedback_pos=feedback_pos)\n    return output_pos\n</code></pre>"},{"location":"reference/#blockdiagrams.DiagramBuilder.DiagramBuilder.__draw_block__","title":"<code>__draw_block__(initial_position, text=None, text_below=None, text_above=None, text_offset=0.1, input_text=None, input_side=None, length=1.5, height=1, fontsize=14, linestyle='-', orientation='horizontal')</code>","text":"<p>Inner method. Draws a rectangular block with centered text, optional texts below and/or above and optional input arrow with text.</p> <p>Parameters:</p> Name Type Description Default <code>initial_position</code> <code>NDarray or list</code> <p>Coordinates of the center position of the input edge of the block.</p> required <code>text</code> <code>string</code> <p>Label to display in the block.</p> <code>None</code> <code>text_below</code> <code>string</code> <p>Label to display below the block.</p> <code>None</code> <code>text_above</code> <code>string</code> <p>Label to display above the block.</p> <code>None</code> <code>text_offset</code> <code>float</code> <p>Vertical offset for the text position.</p> <code>0.1</code> <code>input_text</code> <code>string</code> <p>Label for the optional input arrow (below or above the block).</p> <code>None</code> <code>input_side</code> <code>string</code> <p>Side to place the input arrow: {'bottom', 'top', None}</p> <code>None</code> <code>length</code> <code>float</code> <p>Horizontal length of the block. If not entered, default <code>block_length</code> is used.</p> <code>1.5</code> <code>height</code> <code>float</code> <p>Vertical height of the block. If not entered, default <code>block_height</code> is used.</p> <code>1</code> <code>fontsize</code> <code>int</code> <p>font size of the text inside the block. If not entered, default <code>fontsize</code> is used.</p> <code>14</code> <code>linestyle</code> <code>string</code> <p>linestyle of the block edge: {'-, '--, ':', '-.'}.</p> <code>'-'</code> <code>orientation</code> <code>string or float</code> <p>Direction of the block: {'horizontal', 'vertical', 'up', 'down', 'left', 'right', angle}.</p> <code>'horizontal'</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>Coordinates of the center position of the output edge of the block.</p> Source code in <code>blockdiagrams\\DiagramBuilder.py</code> <pre><code>def __draw_block__(self, initial_position, text=None, text_below=None, \n                   text_above=None, text_offset=0.1, input_text=None, \n                   input_side=None, length=1.5, height=1, fontsize=14, \n                   linestyle='-', orientation='horizontal'):\n    \"\"\"\n    Inner method.\n    Draws a rectangular block with centered text, optional texts below and/or above and optional input arrow with text.\n\n    Args:\n        initial_position (Numpy.NDarray or list): Coordinates of the center position of the input edge of the block.\n        text (string, optional): Label to display in the block.\n        text_below (string, optional): Label to display below the block.\n        text_above (string, optional): Label to display above the block.\n        text_offset (float, optional): Vertical offset for the text position.\n        input_text (string, optional): Label for the optional input arrow (below or above the block).\n        input_side (string, optional): Side to place the input arrow: {'bottom', 'top', None}\n        length (float, optional): Horizontal length of the block. If not entered, default `block_length` is used.\n        height (float, optional): Vertical height of the block. If not entered, default `block_height` is used.\n        fontsize (int, optional): font size of the text inside the block. If not entered, default `fontsize` is used.\n        linestyle (string, optional): linestyle of the block edge: {'-, '--, ':', '-.'}.\n        orientation (string or float, optional): Direction of the block: {'horizontal', 'vertical', 'up', 'down', 'left', 'right', angle}.\n\n    Returns:\n        (Numpy.NDArray): Coordinates of the center position of the output edge of the block.\n    \"\"\"\n    # Parameters validation\n    if input_side not in (None, 'top', 'bottom'):\n        raise ValueError(f\"Invalid input_side: {input_side}. Use 'top' or 'bottom'.\")\n    if orientation not in (None, 'horizontal', 'vertical', 'up', 'down', 'left', 'right'):\n        if isinstance(orientation, (int, float)):\n            pass\n        else:\n            raise ValueError(f\"Invalid orientation: {orientation}. Use 'horizontal', 'vertical', 'up', 'down', 'left', or 'right'.\")\n    if linestyle not in (None, '-', '--', ':', '-.', 'solid', 'dashed', 'dotted', 'dashdot'):\n        raise ValueError(f\"Invalid linestyle: {linestyle}. Use '-', '--', ':', '-.', 'solid', 'dashed', 'dotted', or 'dashdot'.\")\n    if not isinstance(length, (int, float)) or length &lt;= 0:\n        raise ValueError(f\"Invalid length: {length}. Length must be a positive number.\")\n    if not isinstance(height, (int, float)) or height &lt;= 0:\n        raise ValueError(f\"Invalid height: {height}. Height must be a positive number.\")\n    if not isinstance(text_offset, (int, float)):\n        raise ValueError(f\"Invalid text_offset: {text_offset}. Text offset must be a number.\")\n    if not isinstance(fontsize, (int, float)):\n        raise ValueError(f\"Invalid fontsize: {fontsize}. Font size must be a number.\")\n\n\n    # Determine rotation angle based on orientation\n    if orientation in ['horizontal', 'right']:\n        angle = 0\n    elif orientation == 'left':\n        angle = 180\n    elif orientation in ['vertical', 'down']:\n        angle = -90\n    elif orientation == 'up':\n        angle = 90\n    elif isinstance(orientation, (int, float)):\n        angle = orientation\n    else:\n        angle = 0\n\n    x_in, y_in = initial_position\n\n    # Bottom-left corner of the block (before rotation)\n    x0 = x_in\n    y0 = y_in - height / 2\n\n    # Center of the block (before rotation)\n    cx = x_in + length / 2\n    cy = y_in\n\n    # Apply the rotation around the connection point (x_ini, y_ini)\n    trans = transforms.Affine2D().rotate_deg_around(x_in, y_in, angle) + self.ax.transData   \n\n    self.ax.add_patch(Rectangle((x0, y0), length, height, \n                                edgecolor='black', facecolor='none', \n                                linestyle=linestyle, transform=trans))\n    # Don't rotate text if orientation is vertical, down or up\n    rotate_text = False if orientation in ['vertical', 'down', 'up', 'left'] else True\n\n    # Draw text inside the block\n    if text is not None:\n        offset_vector = np.array([length / 2, 0])\n        self.__draw_rotated_text__(initial_position, text, \n                                   angle=angle, rotate_text=rotate_text,\n                                   ha='center', va='center', \n                                   fontsize=fontsize, offset=offset_vector)\n\n    # Draw text above the block\n    if text_above is not None:\n        if orientation in ['vertical', 'down']:\n            ha = 'left'\n            va = 'center'\n        elif orientation in ['up']:\n            ha = 'right'\n            va = 'center'\n        else:\n            ha = 'center'\n            va = 'bottom'\n        offset_vector = np.array([length / 2, height / 2 + text_offset])\n        self.__draw_rotated_text__(initial_position, text_above, \n                                   angle=angle, rotate_text=rotate_text,\n                                   ha=ha, va=va, \n                                   fontsize=fontsize, offset=offset_vector)\n\n    # Draw text below the block\n    if text_below is not None:\n        if orientation in ['vertical', 'down']:\n            ha = 'right'\n            va = 'center'\n        elif orientation in ['up']:\n            ha = 'left'\n            va = 'center'\n        else:\n            ha = 'center'\n            va = 'top'\n        offset_vector = np.array([length / 2, - height / 2 - text_offset])\n        self.__draw_rotated_text__(initial_position, text_below, \n                                   angle=angle, rotate_text=rotate_text,\n                                   ha=ha, va=va, \n                                   fontsize=fontsize, offset=offset_vector)\n\n    if input_side is not None:\n        if input_side == 'bottom':\n            arrow_height = 0.75 * height\n            y_init = y0 - arrow_height\n            offset_vector = np.array([length / 2, - height /2 - arrow_height - text_offset])\n            va = 'top'\n            ha = 'center'\n            if orientation in ['vertical', 'down']:\n                ha = 'right'\n                va = 'center'\n            elif orientation in ['up']:\n                ha = 'left'\n                va = 'center'\n            elif orientation in ['left']:\n                ha = 'center'\n                va = 'bottom'\n        elif input_side == 'top':\n            arrow_height = - 0.75 * height\n            y_init = y0 + height - arrow_height\n            offset_vector = np.array([length / 2, height /2 - arrow_height + text_offset])\n            va = 'bottom'\n            ha = 'center'\n            if orientation in ['vertical', 'down']:\n                ha = 'left'\n                va = 'center'\n            elif orientation in ['up']:\n                ha = 'right'\n                va = 'center'\n            elif orientation in ['left']:\n                ha = 'center'\n                va = 'top'\n        else:\n            raise ValueError(f\"Unknown input side: {input_side}. Use 'bottom' or 'top'.\")   \n\n        self.ax.add_patch(FancyArrow(cx, y_init, 0, arrow_height, width=0.01,\n                                length_includes_head=True, head_width=0.15, \n                                color='black', transform=trans))\n        if input_text is not None:\n\n            self.__draw_rotated_text__(initial_position, input_text, \n                                       angle=angle, rotate_text=rotate_text,\n                                       ha=ha, va=va, \n                                       fontsize=fontsize, offset=offset_vector)\n\n    # Compute rotated output point\n    output_pos = self.__get_rotated_pos__(initial_position, [length, 0], angle)\n    # Compute feedback point\n    feedback_pos = self.__get_rotated_pos__(initial_position, [length/2, -height/2], angle)\n    # Add element position to the dictionary\n    self.__add_element_position__(input_pos=[x_in,y_in], output_pos=output_pos,\n                                  feedback_pos=feedback_pos)\n    return output_pos\n</code></pre>"},{"location":"reference/#blockdiagrams.DiagramBuilder.DiagramBuilder.__draw_combiner__","title":"<code>__draw_combiner__(initial_position, height=1, input_text=None, input_side='bottom', operation='mult', text_offset=0.1, signs=[None, None], fontsize=14, orientation='horizontal')</code>","text":"<p>Inner method. Draws a combiner block: a circle with a multiplication sign (\u00d7), sum sign (+)  or substraction sign (-) inside, with optional signs on each input.</p> <p>Parameters:</p> Name Type Description Default <code>initial_position</code> <code>NDarray or list</code> <p>Coordinates of the starting point of the arrow.</p> required <code>height</code> <code>float</code> <p>Vertical height of the block. If not entered, default <code>block_height</code> is used.</p> <code>1</code> <code>input_text</code> <code>string</code> <p>Label for the input arrow (below or above the arrow).</p> <code>None</code> <code>input_side</code> <code>string</code> <p>Side of the lateral input: {'bottom', 'top'}.</p> <code>'bottom'</code> <code>operation</code> <code>string</code> <p>Operation of the combiner: {'mult', 'sum', 'dif'}.</p> <code>'mult'</code> <code>text_offset</code> <code>float</code> <p>Vertical offset for the text position.</p> <code>0.1</code> <code>signs</code> <code>list</code> <p>Sign to be shown on the horizontal (signs[0]) and vertical (signs[1]) inputs.</p> <code>[None, None]</code> <code>fontsize</code> <code>int</code> <p>font size of the text inside the block. If not entered, default <code>fontsize</code> is used.</p> <code>14</code> <code>orientation</code> <code>string or float</code> <p>Direction of the block: {'horizontal', 'vertical', 'up', 'down', 'left', 'right', angle}.</p> <code>'horizontal'</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>Coordinates of output point of the combiner.</p> Source code in <code>blockdiagrams\\DiagramBuilder.py</code> <pre><code>def __draw_combiner__(self, initial_position, height=1,\n                    input_text=None, input_side='bottom', operation='mult', \n                    text_offset=0.1, signs=[None, None], fontsize=14, orientation='horizontal'):\n    \"\"\"\n    Inner method.\n    Draws a combiner block: a circle with a multiplication sign (\u00d7), sum sign (+) \n    or substraction sign (-) inside, with optional signs on each input.\n\n    Args:\n        initial_position (Numpy.NDarray or list): Coordinates of the starting point of the arrow.\n        height (float, optional): Vertical height of the block. If not entered, default `block_height` is used.\n        input_text (string, optional): Label for the input arrow (below or above the arrow).\n        input_side (string, optional): Side of the lateral input: {'bottom', 'top'}.\n        operation (string, optional): Operation of the combiner: {'mult', 'sum', 'dif'}.\n        text_offset (float, optional): Vertical offset for the text position.\n        signs (list, optional): Sign to be shown on the horizontal (signs[0]) and vertical (signs[1]) inputs.\n        fontsize (int, optional): font size of the text inside the block. If not entered, default `fontsize` is used.\n        orientation (string or float, optional): Direction of the block: {'horizontal', 'vertical', 'up', 'down', 'left', 'right', angle}.\n\n    Returns:\n        (Numpy.NDArray): Coordinates of output point of the combiner.\n    \"\"\"\n    angle = 0\n    # Determine rotation angle based on orientation\n    if orientation in ['horizontal', 'right']:\n        angle = 0\n    elif orientation == 'left':\n        angle = 180\n    elif orientation in ['vertical', 'down']:\n        angle = -90\n    elif orientation == 'up':\n        angle = 90\n    elif isinstance(orientation, (int, float)):\n        angle = orientation\n    else:\n        angle = 0\n\n    x_in, y_in = initial_position\n\n    radius = height / 4\n    # Center of the block (before rotation)\n    cx = x_in + radius\n    cy = y_in\n\n    # Apply rotation around the connection point (x_ini, y_ini)\n    trans = transforms.Affine2D().rotate_deg_around(x_in, y_in, angle) + self.ax.transData  \n\n    circle = plt.Circle((cx, cy), radius, edgecolor='black', \n                        facecolor='white', transform=trans, zorder=2)\n    self.ax.add_patch(circle)\n\n    rel_size = 0.7\n    if operation == 'mult':\n        # L\u00edneas diagonales (forma de \"X\") dentro del c\u00edrculo\n        dx = radius * rel_size * np.cos(np.pi / 4)  # Escalamos un poco para que quepa dentro del c\u00edrculo\n        dy = radius * rel_size * np.sin(np.pi / 4)\n        # L\u00ednea de 45\u00b0\n        self.ax.plot([cx - dx, cx + dx], [cy - dy, cy + dy], color='black', \n                     linewidth=2, transform=trans, zorder=3)\n        # L\u00ednea de 135\u00b0\n        self.ax.plot([cx - dx, cx + dx], [cy + dy, cy - dy], color='black', \n                     linewidth=2, transform=trans, zorder=3)\n\n    elif operation == 'sum':\n        dx = radius * rel_size\n        dy = radius * rel_size\n        # L\u00edneas horizontales y verticales (forma de \"+\") dentro del c\u00edrculo\n        self.ax.plot([cx - dx, cx + dx], [cy, cy], color='black', \n                     linewidth=2, transform=trans, zorder=3)\n        self.ax.plot([cx, cx], [cy - dy, cy + dy], color='black', \n                     linewidth=2, transform=trans, zorder=3)\n    elif operation == 'dif':\n        dx = radius * rel_size\n        # L\u00ednea horizontal (forma de \"-\") dentro del c\u00edrculo\n        self.ax.plot([cx - dx, cx + dx], [cy, cy], color='black', \n                     linewidth=2, transform=trans, zorder=3)\n    else:\n        raise ValueError(f\"Unknown operation: {operation}. 'operation' must be 'mult', 'sum' or 'dif'.\")\n\n    # Don't rotate text if orientation is vertical, down or up\n    rotate_text = False if orientation in ['vertical', 'down', 'up', 'left'] else True\n\n    # Side input\n    if input_side == 'bottom':\n        arrow_height = height - radius\n        y_init = y_in - radius - arrow_height\n        offset_vector = np.array([radius, - (height + text_offset)])\n        va = 'top'\n        ha = 'center'\n        if orientation in ['vertical', 'down']:\n            ha = 'right'\n            va = 'center'\n        elif orientation in ['up']:\n            ha = 'left'\n            va = 'center'\n    elif input_side == 'top':\n        arrow_height = - (height - radius)\n        y_init = y_in + radius - arrow_height\n        offset_vector = np.array([radius, height + text_offset])\n        va = 'bottom'\n        ha = 'center'\n        if orientation in ['vertical', 'down']:\n            ha = 'left'\n            va = 'center'\n        elif orientation in ['up']:\n            ha = 'right'\n            va = 'center'\n    else:\n        raise ValueError(f\"Unknown input_side: {input_side}. 'input_side' must be 'bottom' or 'top'.\")\n\n    # Show signs on each input if not None\n    if signs[0] is not None:\n        self.__draw_rotated_text__(initial_position, signs[0], \n                                angle=angle, rotate_text=rotate_text,\n                                ha=ha, va=va, \n                                fontsize=fontsize, offset=[-radius, 1.5*radius])\n    if signs[1] is not None:\n        self.__draw_rotated_text__(initial_position, signs[1], \n                                angle=angle, rotate_text=rotate_text,\n                                ha=ha, va=va, \n                                fontsize=fontsize, offset=[0, -1.5*radius])\n\n    self.ax.add_patch(FancyArrow(cx, y_init, 0, arrow_height, width=0.01,\n                            length_includes_head=True, head_width=0.15, \n                            color='black', transform=trans))\n    if input_text is not None:\n        self.__draw_rotated_text__(initial_position, input_text, \n                                   angle=angle, rotate_text=rotate_text,\n                                   ha=ha, va=va, \n                                   fontsize=fontsize, offset=offset_vector)\n\n    # Compute rotated output point\n    output_pos = self.__get_rotated_pos__(initial_position, [2 * radius, 0], angle)\n    # Compute feedback point\n    feedback_pos = self.__get_rotated_pos__(initial_position, [radius, y_init - y_in + arrow_height], angle)\n    # Add element position to the dictionary\n    self.__add_element_position__(input_pos=[x_in,y_in], output_pos=output_pos,\n                                  feedback_pos=feedback_pos)\n    return output_pos\n</code></pre>"},{"location":"reference/#blockdiagrams.DiagramBuilder.DiagramBuilder.__draw_mult_combiner__","title":"<code>__draw_mult_combiner__(initial_position, length, inputs, operation='sum', orientation='horizontal')</code>","text":"<p>Inner method. Draws a summation or multiplication block with multiple inputs distributed  along the left edge of a circle, from pi/2 to 3*pi/2. Inputs can have a sign.</p> <p>Parameters:</p> Name Type Description Default <code>initial_position</code> <code>NDarray or list</code> <p>Coordinates of the starting point of the arrow.</p> required <code>length</code> <code>float</code> <p>Horizontal length of the block. If not entered, default <code>block_length</code> is used.</p> required <code>inputs</code> <code>list of str</code> <p>Thread names to combine.</p> required <code>operation</code> <code>string</code> <p>Operation of the combiner: {'mult', 'sum'}.</p> <code>'sum'</code> <code>orientation</code> <code>string or float</code> <p>Direction of the block: {'horizontal', 'vertical', 'up', 'down', 'left', 'right', angle}.</p> <code>'horizontal'</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>Coordinates of output point of the combiner.</p> Source code in <code>blockdiagrams\\DiagramBuilder.py</code> <pre><code>def __draw_mult_combiner__(self, initial_position, length, inputs, \n                           operation='sum', orientation='horizontal'):\n    \"\"\"\n    Inner method.\n    Draws a summation or multiplication block with multiple inputs distributed \n    along the left edge of a circle, from pi/2 to 3*pi/2. Inputs can have a sign.\n\n    Args:\n        initial_position (Numpy.NDarray or list): Coordinates of the starting point of the arrow.\n        length (float, optional): Horizontal length of the block. If not entered, default `block_length` is used.\n        inputs (list of str): Thread names to combine.\n        operation (string, optional): Operation of the combiner: {'mult', 'sum'}.\n        orientation (string or float, optional): Direction of the block: {'horizontal', 'vertical', 'up', 'down', 'left', 'right', angle}.\n\n    Returns:\n        (Numpy.NDArray): Coordinates of output point of the combiner.\n    \"\"\"\n    angle = 0\n    # Determine rotation angle based on orientation\n    if orientation in ['horizontal', 'right']:\n        angle = 0\n    elif orientation == 'left':\n        angle = 180\n    elif orientation in ['vertical', 'down']:\n        angle = -90\n    elif orientation == 'up':\n        angle = 90\n    elif isinstance(orientation, (int, float)):\n        angle = orientation\n    else:\n        angle = 0\n\n    # If position is 'auto', obtain head position\n    if isinstance(initial_position, str) and initial_position == 'auto':\n        # Get head positions of input threads\n        thread_input_pos = np.array([self.thread_positions[key] for key in inputs])\n        x_in = np.max(thread_input_pos[:, 0])\n        y_in = np.mean(thread_input_pos[:,1])\n        initial_position = [x_in, y_in]\n    # If position is given, use it\n    else:\n        x_in, y_in = initial_position\n\n    radius = length / 4\n    cx = x_in + length - radius\n    cy = y_in\n\n    # Apply rotation around the connection point (x_ini, y_ini)\n    trans = transforms.Affine2D().rotate_deg_around(x_in, y_in, angle) + self.ax.transData  \n\n    # Circle\n    circle = plt.Circle((cx, cy), radius, edgecolor='black', \n                        facecolor='white', transform=trans, zorder=2)\n    self.ax.add_patch(circle)\n\n    # Draw symbol inside circle depending on operation\n    rel_size = 0.7\n    if operation == 'mult':\n        # \"X\" inside circle\n        dx = radius * rel_size * np.cos(np.pi / 4)  # Escalamos un poco para que quepa dentro del c\u00edrculo\n        dy = radius * rel_size * np.sin(np.pi / 4)\n        #  45\u00b0 line\n        self.ax.plot([cx - dx, cx + dx], [cy - dy, cy + dy], color='black', \n                     linewidth=2, transform=trans, zorder=3)\n        # 135\u00b0 line\n        self.ax.plot([cx - dx, cx + dx], [cy + dy, cy - dy], color='black', \n                     linewidth=2, transform=trans, zorder=3)\n    elif operation == 'sum':\n        dx = radius * rel_size\n        dy = radius * rel_size\n        # \"+\" inside circle\n        self.ax.plot([cx - dx, cx + dx], [cy, cy], color='black', \n                     linewidth=2, transform=trans, zorder=3)\n        self.ax.plot([cx, cx], [cy - dy, cy + dy], color='black', \n                     linewidth=2, transform=trans, zorder=3)\n    else:\n        raise ValueError(f\"Unknown operation: {operation}. Use 'sum' or 'mult'.\")\n\n    # Get rotation matrix\n    rot_matrix = transforms.Affine2D().rotate_deg(angle).get_matrix()[:2, :2]\n\n    n = len(thread_input_pos)\n    angles = np.linspace(5* np.pi / 8, 11 * np.pi / 8, n)\n\n    arrow_width = 0.01\n    arrow_head_width = 0.15\n\n    # Input arrows\n    for i, inp in enumerate(thread_input_pos):\n        xi, yi = inp[:2]\n\n        x_edge = cx + radius * np.cos(angles[i])\n        y_edge = cy + radius * np.sin(angles[i])\n\n        dx = x_edge - x_in\n        dy = y_edge - y_in\n        offset_vec = [dx, dy]\n\n        # Rotated offset vector with respect to initial_position of element\n        dx_rot, dy_rot = rot_matrix @ offset_vec\n        # Rotated offset vector with respect to initial position of arrow\n        dx_rot_rel = dx_rot - xi + x_in\n        dy_rot_rel = dy_rot - yi + y_in\n\n        self.ax.add_patch(FancyArrow(\n            xi, yi, dx_rot_rel, dy_rot_rel,\n            width=arrow_width,\n            length_includes_head=True,\n            head_width=arrow_head_width,\n            color='black', transform=self.ax.transData, zorder=1\n        ))\n\n    # Compute rotated output point\n    output_pos = self.__get_rotated_pos__(initial_position, [length, 0], angle)\n    # Compute feedback point\n    feedback_pos = self.__get_rotated_pos__(initial_position, [length - radius, -radius], angle)\n    # Add element position to the dictionary\n    self.__add_element_position__(input_pos=[x_in,y_in], output_pos=output_pos,\n                                  feedback_pos=feedback_pos)\n    return output_pos\n</code></pre>"},{"location":"reference/#blockdiagrams.DiagramBuilder.DiagramBuilder.__draw_rotated_text__","title":"<code>__draw_rotated_text__(anchor_point, text, angle, rotate_text=True, ha='center', va='center', fontsize=16, offset=(0, 0))</code>","text":"<p>Inner method. Draws text rotated around the anchor point with optional offset.  Text position: rotation(anchor_point + offset)</p> <p>Parameters:</p> Name Type Description Default <code>anchor_point</code> <code>NDArray or list</code> <p>Coordinates of the anchor point.</p> required <code>text</code> <code>string</code> <p>String to display. LaTeX math accepted (without $...$).</p> required <code>angle</code> <code>float</code> <p>Rotation angle in degrees.</p> required <code>rotate_text</code> <code>bool</code> <p>Indicates if text must be rotated or not.</p> <code>True</code> <code>ha</code> <code>string</code> <p>Horizontal alignment: {'center', 'left', 'right'}.</p> <code>'center'</code> <code>va</code> <code>string</code> <p>Vertical alignment: {'center', 'bottom', 'top'}.</p> <code>'center'</code> <code>fontsize</code> <code>int</code> <p>Font size.</p> <code>16</code> <code>offset</code> <code>NDArray or list</code> <p>Coordinates of texr position respect to anchor point, before rotation.</p> <code>(0, 0)</code> Source code in <code>blockdiagrams\\DiagramBuilder.py</code> <pre><code>def __draw_rotated_text__(self, anchor_point, text, angle, rotate_text = True,\n                  ha='center', va='center', fontsize=16, offset=(0, 0)):\n    \"\"\"\n    Inner method.\n    Draws text rotated around the anchor point with optional offset. \n    Text position: rotation(anchor_point + offset)\n\n    Args:\n        anchor_point (Numpy.NDArray or list): Coordinates of the anchor point.\n        text (string): String to display. LaTeX math accepted (without $...$).\n        angle (float): Rotation angle in degrees.\n        rotate_text (bool, optional): Indicates if text must be rotated or not.\n        ha (string, optional): Horizontal alignment: {'center', 'left', 'right'}.\n        va (string, optional): Vertical alignment: {'center', 'bottom', 'top'}.\n        fontsize (int, optional): Font size.\n        offset (Numpy.NDArray or list): Coordinates of texr position respect to anchor point, before rotation.\n    \"\"\"\n    # Apply rotation to the offset vector\n    dx, dy = offset\n    offset_vec = np.array([dx, dy])\n    rot_matrix = transforms.Affine2D().rotate_deg(angle).get_matrix()[:2, :2]\n    dx_rot, dy_rot = rot_matrix @ offset_vec\n\n    # Compute final position\n    tx = anchor_point[0] + dx_rot\n    ty = anchor_point[1] + dy_rot\n\n    if rotate_text is False:\n        text_angle = 0\n    else:\n        text_angle = angle\n\n    # Draw text with angle, rotating around anchor point\n    self.ax.text(tx, ty, f\"${text}$\", ha=ha, va=va, fontsize=fontsize,\n            rotation=text_angle, rotation_mode='anchor', transform=self.ax.transData)\n</code></pre>"},{"location":"reference/#blockdiagrams.DiagramBuilder.DiagramBuilder.__get_rotated_pos__","title":"<code>__get_rotated_pos__(init_pos, outvector, angle)</code>","text":"<p>Inner method. Compute rotated point init_pos + outvector.</p> <p>Parameters:</p> Name Type Description Default <code>init_pos</code> <code>NDArray or list</code> <p>Initial position of the block (relative origin of coordinates).</p> required <code>outvector</code> <code>NDArray or list</code> <p>Output vector before rotation (relative position with respect to init_pos).</p> required <code>angle</code> <code>float</code> <p>Rotation angle in degrees.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>Rotated position of vector init_pos + outvector.</p> Source code in <code>blockdiagrams\\DiagramBuilder.py</code> <pre><code>def __get_rotated_pos__(self, init_pos, outvector, angle):\n    \"\"\"\n    Inner method.\n    Compute rotated point init_pos + outvector.\n\n    Args:\n        init_pos (Numpy.NDArray or list): Initial position of the block (relative origin of coordinates).\n        outvector (Numpy.NDArray or list): Output vector before rotation (relative position with respect to init_pos).\n        angle (float): Rotation angle in degrees.\n\n    Returns:\n        (Numpy.NDArray): Rotated position of vector init_pos + outvector.\n    \"\"\"\n\n    # Output point respect to input point (before rotation)\n    out_vector = np.array(outvector)\n    # Rotation matrix (without translation)\n    rotation_matrix = transforms.Affine2D().rotate_deg(angle).get_matrix()[:2, :2]\n    # Apply rotation to the output vector\n    dx, dy = rotation_matrix @ out_vector\n    # Add the rotated output vector to the initial position\n    return np.array([init_pos[0] + dx, init_pos[1] + dy])\n</code></pre>"},{"location":"reference/#blockdiagrams.DiagramBuilder.DiagramBuilder.__init__","title":"<code>__init__(block_length=1.0, block_height=1.0, fontsize=20)</code>","text":"<p>(Private) Creator of the DiagramBuilder class.</p> Source code in <code>blockdiagrams\\DiagramBuilder.py</code> <pre><code>def __init__(self, block_length=1.0, block_height=1.0, fontsize=20):\n    \"\"\"\n    (Private) Creator of the DiagramBuilder class.\n    \"\"\"\n    self.fig, self.ax = plt.subplots()\n    self.ax.axis('off')  # Hide axes\n    self.fontsize = fontsize\n    self.block_length = block_length\n    self.block_height = block_height\n    self.thread_positions = {}\n    self.thread_positions['main'] = [0, 0]\n    # Dictionary to store element positions: input_pos, output_pos, feedback_pos\n    self.element_positions = {}\n    # Counter for current element\n    self.current_element = -1\n</code></pre>"},{"location":"reference/#blockdiagrams.DiagramBuilder.DiagramBuilder.add","title":"<code>add(name, kind='block', thread='main', position=None, debug=False, **kwargs)</code>","text":"<p>Adds an element to the block diagram at the current or specified position of a given thread.</p> <p>This is the main interface for constructing diagrams by adding components such as blocks, arrows, inputs, outputs, combiners, and connectors. The <code>kind</code> parameter determines the type of element, and each type accepts specific keyword arguments listed below.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Main label or identifier for the element.</p> required <code>kind</code> <code>str</code> <p>Type of element. One of: - 'block': Rectangular block. - 'arrow': Straight line with ending arrow. - 'angled_arrow': Rect angle line with or without ending arrow. - 'input': Arrow with text before it. - 'output': Arrow with text after it. - 'line': Straight line without arrow ending. - 'combiner': Circle with (x), (+) or (-) and additional input. - 'mult_combiner': Combiner with multiple inputs.</p> <code>'block'</code> <code>thread</code> <code>str</code> <p>Thread identifier.</p> <code>'main'</code> <code>position</code> <code>tuple or str or None</code> <p>(x, y) position, 'auto' (for mult_combiner), or None to use current thread position.</p> <code>None</code> <code>debug</code> <code>bool</code> <p>If True, prints thread positions after placing the element.</p> <code>False</code> <p>The <code>**kwargs</code> vary depending on the <code>kind</code>:</p> <ul> <li> <p>kind = 'block':</p> <ul> <li>text (str, optional): Label inside the block (defaults to <code>name</code>).</li> <li>text_above (str, optional): Text above the block.</li> <li>text_below (str, optional): Text below the block.</li> <li>text_offset (float, optional): Offset for above/below text (defaults to 0.1).</li> <li>input_text (str, optional): Label for input arrow.</li> <li>input_side (str, optional): Side of a second optional input: {'top', 'bottom'} (defaults to <code>None</code>)</li> <li>length (float, optional): Block length (defaults to <code>self.block_length</code>).</li> <li>height (float, optional): Block height (defaults to <code>self.block_height</code>)..</li> <li>linestyle (str, optional): Block border line style (defaults to <code>-</code>).</li> <li>orientation (str or float, optional): Orientation of the block: {'horizontal', 'vertical', 'up', 'down' 'right', left' or angle in degrees} (defaults to 'horizontal').</li> <li>fontsize (int, optional): Text font size (defaults to <code>self.fontsize</code>).</li> </ul> </li> <li> <p>kind = 'arrow', 'input', 'output' or 'line':</p> <ul> <li>text (str, optional): Text on the arrow or line (defaults to <code>name</code>).</li> <li>text_position (str, optional): 'above', 'below', 'before', or 'after' (defaults to 'above' for 'arrow' and 'line', 'before' for 'input', and 'after' for 'output').</li> <li>text_offset (float, optional): Offset for text (defaults to 0.1).</li> <li>length (float, optional): Arrow or line length (defaults to <code>self.block_length</code>).</li> <li>orientation (str or float, optional): Orientation of the block: {'horizontal', 'vertical', 'up', 'down' 'right', left' or angle in degrees} (defaults to 'horizontal').</li> <li>fontsize (int, optional): Text font size (defaults to <code>self.fontsize</code>).</li> </ul> </li> <li> <p>kind = 'angled_arrow':</p> <ul> <li>text (str, optional): Text on the arrow or line (defaults to <code>name</code>).</li> <li>final_pos (Numpy.NDarray or list): Coordinates of the ending point of the arrow.</li> <li>text_position (str, optional): 'above', 'below', 'before', or 'after' (defaults to 'above' for 'arrow' and 'line', 'before' for 'input', and 'after' for 'output').</li> <li>text_offset (float, optional): Offset for text (defaults to 0.1).</li> <li>arrow (bool, optional): Indicates if it must finish or not in an arrow.</li> <li>first_segment (string, optional): Drawing order: {'horizontal', 'vertical'}</li> <li>orientation (str or float, optional): Orientation of the block: {'horizontal', 'vertical', 'up', 'down' 'right', left' or angle in degrees} (defaults to 'horizontal').</li> <li>fontsize (int, optional): Text font size (defaults to <code>self.fontsize</code>).</li> </ul> </li> <li> <p>kind = 'combiner':</p> <ul> <li>operation (string, optional): Operation of the combiner: {'mult', 'sum', 'dif'} (defaultds to 'mult').</li> <li>height (float, optional): Vertical height of the block. (defaults to <code>self.block_height</code>).</li> <li>input_side (string, optional): Side of the lateral input: {'bottom', 'top'} (defaults to 'bottom').</li> <li>input_text (string, optional): Label for the input arrow (below or above the arrow).</li> <li>text_offset (float, optional): Offset for text (defaults to 0.1).</li> <li>signs (list, optional): Sign to be shown on the horizontal (signs[0]) and vertical (signs[1]) inputs.</li> <li>orientation (str or float, optional): Orientation of the block: {'horizontal', 'vertical', 'up', 'down' 'right', left' or angle in degrees} (defaults to 'horizontal').</li> <li>fontsize (int, optional): Text font size (defaults to <code>self.fontsize</code>).</li> </ul> </li> <li> <p>kind = 'mult_combiner':</p> <ul> <li>operation (string, optional): Operation of the combiner: {'mult', 'sum', 'dif'} (defaults to 'mult').</li> <li>length (float, optional): Total element length (defaults to <code>self.block_length</code>).</li> <li>inputs (list of str): Thread names to combine.</li> <li>operation (string, optional): Operation of the combiner: {'mult', 'sum'} (defaults to 'sum').</li> <li>orientation (str or float, optional): Orientation of the block: {'horizontal', 'vertical', 'up', 'down' 'right', left' or angle in degrees} (defaults to 'horizontal').</li> <li>fontsize (int, optional): Text font size (defaults to <code>self.fontsize</code>).</li> </ul> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; db = DiagramBuilder()\n&gt;&gt;&gt; db.add(\"x(t)\", kind=\"input\")\n&gt;&gt;&gt; db.add(\"H(s)\", kind=\"block\")\n&gt;&gt;&gt; db.add(\"y(t)\", kind=\"output\")\n</code></pre> Source code in <code>blockdiagrams\\DiagramBuilder.py</code> <pre><code>def add(self,name, kind='block', thread='main', position=None, debug=False, **kwargs):\n    \"\"\"\n    Adds an element to the block diagram at the current or specified position of a given thread.\n\n    This is the main interface for constructing diagrams by adding components such as blocks, arrows,\n    inputs, outputs, combiners, and connectors. The `kind` parameter determines the type of element,\n    and each type accepts specific keyword arguments listed below.\n\n    Args:\n        name (str): Main label or identifier for the element.\n        kind (str, optional): Type of element. One of:\n            - 'block': Rectangular block.\n            - 'arrow': Straight line with ending arrow.\n            - 'angled_arrow': Rect angle line with or without ending arrow.\n            - 'input': Arrow with text before it.\n            - 'output': Arrow with text after it.\n            - 'line': Straight line without arrow ending.\n            - 'combiner': Circle with (x), (+) or (-) and additional input.\n            - 'mult_combiner': Combiner with multiple inputs.\n        thread (str, optional): Thread identifier.\n        position (tuple or str or None, optional): (x, y) position, 'auto' (for mult_combiner), or None to use current thread position.\n        debug (bool, optional): If True, prints thread positions after placing the element.\n\n    The `**kwargs` vary depending on the `kind`:\n\n    - **kind = 'block'**:\n        - text (str, optional): Label inside the block (defaults to `name`).\n        - text_above (str, optional): Text above the block.\n        - text_below (str, optional): Text below the block.\n        - text_offset (float, optional): Offset for above/below text (defaults to 0.1).\n        - input_text (str, optional): Label for input arrow.\n        - input_side (str, optional): Side of a second optional input: {'top', 'bottom'} (defaults to `None`)\n        - length (float, optional): Block length (defaults to `self.block_length`).\n        - height (float, optional): Block height (defaults to `self.block_height`)..\n        - linestyle (str, optional): Block border line style (defaults to `-`).\n        - orientation (str or float, optional): Orientation of the block: {'horizontal', 'vertical', 'up', 'down' 'right', left' or angle in degrees} (defaults to 'horizontal').\n        - fontsize (int, optional): Text font size (defaults to `self.fontsize`).\n\n    - **kind = 'arrow'**, **'input'**, **'output'** or **'line'**:\n        - text (str, optional): Text on the arrow or line (defaults to `name`).\n        - text_position (str, optional): 'above', 'below', 'before', or 'after' (defaults to 'above' for 'arrow' and 'line', 'before' for 'input', and 'after' for 'output').\n        - text_offset (float, optional): Offset for text (defaults to 0.1).\n        - length (float, optional): Arrow or line length (defaults to `self.block_length`).\n        - orientation (str or float, optional): Orientation of the block: {'horizontal', 'vertical', 'up', 'down' 'right', left' or angle in degrees} (defaults to 'horizontal').\n        - fontsize (int, optional): Text font size (defaults to `self.fontsize`).\n\n    - **kind = 'angled_arrow'**:\n        - text (str, optional): Text on the arrow or line (defaults to `name`).\n        - final_pos (Numpy.NDarray or list): Coordinates of the ending point of the arrow.\n        - text_position (str, optional): 'above', 'below', 'before', or 'after' (defaults to 'above' for 'arrow' and 'line', 'before' for 'input', and 'after' for 'output').\n        - text_offset (float, optional): Offset for text (defaults to 0.1).\n        - arrow (bool, optional): Indicates if it must finish or not in an arrow.\n        - first_segment (string, optional): Drawing order: {'horizontal', 'vertical'}\n        - orientation (str or float, optional): Orientation of the block: {'horizontal', 'vertical', 'up', 'down' 'right', left' or angle in degrees} (defaults to 'horizontal').\n        - fontsize (int, optional): Text font size (defaults to `self.fontsize`).\n\n    - **kind = 'combiner'**:\n        - operation (string, optional): Operation of the combiner: {'mult', 'sum', 'dif'} (defaultds to 'mult').\n        - height (float, optional): Vertical height of the block. (defaults to `self.block_height`).\n        - input_side (string, optional): Side of the lateral input: {'bottom', 'top'} (defaults to 'bottom').\n        - input_text (string, optional): Label for the input arrow (below or above the arrow).\n        - text_offset (float, optional): Offset for text (defaults to 0.1).\n        - signs (list, optional): Sign to be shown on the horizontal (signs[0]) and vertical (signs[1]) inputs.\n        - orientation (str or float, optional): Orientation of the block: {'horizontal', 'vertical', 'up', 'down' 'right', left' or angle in degrees} (defaults to 'horizontal').\n        - fontsize (int, optional): Text font size (defaults to `self.fontsize`).\n\n    - **kind = 'mult_combiner'**:\n        - operation (string, optional): Operation of the combiner: {'mult', 'sum', 'dif'} (defaults to 'mult').\n        - length (float, optional): Total element length (defaults to `self.block_length`).\n        - inputs (list of str): Thread names to combine.\n        - operation (string, optional): Operation of the combiner: {'mult', 'sum'} (defaults to 'sum').\n        - orientation (str or float, optional): Orientation of the block: {'horizontal', 'vertical', 'up', 'down' 'right', left' or angle in degrees} (defaults to 'horizontal').\n        - fontsize (int, optional): Text font size (defaults to `self.fontsize`).\n\n    Examples:\n        &gt;&gt;&gt; db = DiagramBuilder()\n        &gt;&gt;&gt; db.add(\"x(t)\", kind=\"input\")\n        &gt;&gt;&gt; db.add(\"H(s)\", kind=\"block\")\n        &gt;&gt;&gt; db.add(\"y(t)\", kind=\"output\")\n    \"\"\"\n\n    # If position is 'auto' (draw_mult_combiner), position is calculated inside that method\n    if isinstance(position, str) and position == 'auto':\n        initial_pos = 'auto'\n    # If input argument position is given and not 'auto', element position is asigned to position argument value\n    elif position is not None:\n        initial_pos = list(position)\n    # If not given\n    else:\n        # If thread already exists, element position is asigned from thread head\n        if thread in self.thread_positions:\n            initial_pos = self.thread_positions[thread]\n        # If doesn't exist\n        else:\n            initial_pos = [0, 0]\n\n    if kind == 'arrow':\n        # Default arguments\n        default_kwargs = {\n            'text': name,\n            'text_position': 'above',\n            'arrow': True,\n            'text_offset': 0.1,\n            'length': self.block_length,\n            'fontsize': self.fontsize,\n            'orientation': 'horizontal'\n        }\n        # Overrides default arguments with provided ones\n        block_args = {**default_kwargs, **kwargs}\n        # Function call\n        final_pos = self.__draw_arrow__(initial_pos, **block_args)\n\n    elif kind == 'angled_arrow':\n        # Default arguments\n        default_kwargs = {\n            'text': name,\n            'text_offset': 0.1,\n            'fontsize': self.fontsize,\n            'orientation': 'horizontal',\n        }\n        # Overrides default arguments with provided ones\n        block_args = {**default_kwargs, **kwargs}\n        # Function call\n        final_pos = self.__draw_angled_arrow__(initial_pos, **block_args)\n\n    elif kind == 'input':\n        # Default arguments\n        default_kwargs = {\n            'text': name,\n            'text_position': 'before',\n            'arrow': True,\n            'text_offset': 0.1,\n            'length': self.block_length,\n            'fontsize': self.fontsize,\n            'orientation': 'horizontal'\n        }\n        # Overrides default arguments with provided ones\n        block_args = {**default_kwargs, **kwargs}\n        # Function call\n        final_pos = self.__draw_arrow__(initial_pos, **block_args)\n\n    elif kind == 'output':\n        # Default arguments\n        default_kwargs = {\n            'text': name,\n            'text_position': 'after',\n            'arrow': True,\n            'text_offset': 0.1,\n            'length': self.block_length,\n            'fontsize': self.fontsize,\n            'orientation': 'horizontal'\n        }\n        # Overrides default arguments with provided ones\n        block_args = {**default_kwargs, **kwargs}\n        # Function call\n        final_pos = self.__draw_arrow__(initial_pos, **block_args)\n\n    elif kind == 'line':\n        # Default arguments\n        default_kwargs = {\n            'text': name,\n            'text_position': 'above',\n            'arrow': False,\n            'text_offset': 0.1,\n            'length': self.block_length,\n            'fontsize': self.fontsize,\n            'orientation': 'horizontal'\n        }\n        # Overrides default arguments with provided ones\n        block_args = {**default_kwargs, **kwargs}\n        # Function call\n        final_pos = self.__draw_arrow__(initial_pos, **block_args)\n\n    elif kind == 'block':\n        # Default arguments\n        default_kwargs = {\n            'text': name,\n            'text_above': None,\n            'text_below': None,\n            'text_offset': 0.1,\n            'input_text': None,\n            'input_side': None,\n            'length': self.block_length,\n            'height': self.block_height,\n            'fontsize': self.fontsize,\n            'linestyle': '-',\n            'orientation': 'horizontal'\n        }\n        # Overrides default arguments with provided ones\n        block_args = {**default_kwargs, **kwargs}\n        # Function call\n        final_pos = self.__draw_block__(initial_pos, **block_args)\n\n    elif kind == 'combiner':\n        # Default arguments\n        default_kwargs = {\n            'height': self.block_height,\n            'fontsize': self.fontsize,\n            'operation': 'mult',\n            'input_side': 'bottom',\n            'orientation': 'horizontal'\n        }\n        # Overrides default arguments with provided ones\n        block_args = {**default_kwargs, **kwargs}\n        # Function call\n        final_pos = self.__draw_combiner__(initial_pos, **block_args)\n\n    elif kind == 'mult_combiner':\n        # Default arguments\n        default_kwargs = {\n            'length': self.block_length,\n            'operation': 'mult',\n            'orientation': 'horizontal'\n        }\n        # Overrides default arguments with provided ones\n        block_args = {**default_kwargs, **kwargs}\n        # Function call\n        final_pos = self.__draw_mult_combiner__(initial_pos, **block_args)\n\n\n    elif kind == 'output':\n        length=kwargs.get('length', self.block_length)\n        final_pos = self.__draw_io_arrow__(initial_pos, length=length, text=kwargs.get('text', name),\n                      io='output', fontsize=self.fontsize)\n\n    else:\n        raise ValueError(f\"Unknown block type: {kind}\")\n\n    # Update head position of thread\n    self.thread_positions[thread] = final_pos\n\n    if debug:\n        self.__print_threads__()\n</code></pre>"},{"location":"reference/#blockdiagrams.DiagramBuilder.DiagramBuilder.get_current_element","title":"<code>get_current_element()</code>","text":"<p>Returns the current element index (last added).</p> <p>Returns:</p> Type Description <code>int</code> <p>Index of the last added element.</p> Source code in <code>blockdiagrams\\DiagramBuilder.py</code> <pre><code>def get_current_element(self):\n    \"\"\"\n    Returns the current element index (last added).\n\n    Returns:\n        (int): Index of the last added element.\n    \"\"\"\n    return self.current_element\n</code></pre>"},{"location":"reference/#blockdiagrams.DiagramBuilder.DiagramBuilder.get_position","title":"<code>get_position(element=None)</code>","text":"<p>Returns the positions of the specified element index. If no element specified, last added element is used. The return is a dictinoary with coordinates of <code>input_pos</code>, <code>output_pos</code> and <code>feedback_pos</code> (feedback port coordinates).</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>int</code> <p>index of the element.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict of Tuples</code> <p>Dictionary with three 2-element tuples: <code>input_pos</code>, <code>output_pos</code> and <code>feedback_pos</code>.</p> Source code in <code>blockdiagrams\\DiagramBuilder.py</code> <pre><code>def get_position(self, element=None):\n    \"\"\"\n    Returns the positions of the specified element index. If no element specified, last added element is used.\n    The return is a dictinoary with coordinates of `input_pos`, `output_pos` and `feedback_pos` (feedback port coordinates).\n\n    Args:\n        element (int, optional): index of the element.\n\n    Returns:\n        (dict of Tuples): Dictionary with three 2-element tuples: `input_pos`, `output_pos` and `feedback_pos`.\n    \"\"\"\n    if element is None:\n        return self.element_positions[self.current_element]\n    elif element &lt;= self.current_element:\n        return self.element_positions[element]\n    else:\n        raise ValueError(f\"Element '{element}' not found.\")\n</code></pre>"},{"location":"reference/#blockdiagrams.DiagramBuilder.DiagramBuilder.get_thread_position","title":"<code>get_thread_position(thread='main')</code>","text":"<p>Returns the current output position of the specified thread.</p> <p>Parameters:</p> Name Type Description Default <code>thread</code> <code>str</code> <p>Thread identifier.</p> <code>'main'</code> Source code in <code>blockdiagrams\\DiagramBuilder.py</code> <pre><code>def get_thread_position(self, thread='main'):\n    \"\"\"\n    Returns the current output position of the specified thread.\n\n    Args:\n        thread (str, optional): Thread identifier.\n    \"\"\"\n    if thread in self.thread_positions:\n        return self.thread_positions[thread]\n    else:\n        raise ValueError(f\"Thread '{thread}' not found.\")\n</code></pre>"},{"location":"reference/#blockdiagrams.DiagramBuilder.DiagramBuilder.print_threads","title":"<code>print_threads()</code>","text":"<p>Prints name of each thread in diagram and actual position.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from blockdiagrams import DiagramBuilder\n&gt;&gt;&gt; db = DiagramBuilder(block_length=1, fontsize=16)\n&gt;&gt;&gt; # Upper thread\n&gt;&gt;&gt; db.add(\"x_1(t)\", kind=\"input\", thread='upper', position=(0, 1))\n&gt;&gt;&gt; db.add(\"mult\", kind=\"combiner\", thread='upper', input_text=\"e^{-j\\omega_0 t}\", input_side='top', operation='mult')\n&gt;&gt;&gt; db.add(\"\", kind=\"line\", thread='upper')\n&gt;&gt;&gt; # Lower thread\n&gt;&gt;&gt; db.add(\"x_2(t)\", kind=\"input\", thread='lower', position=(0, -1))\n&gt;&gt;&gt; db.add(\"mult\", kind=\"combiner\", input_text=\"e^{j\\omega_0 t}\", input_side='bottom', operation='mult', thread='lower')\n&gt;&gt;&gt; db.add(\"\", kind=\"line\", thread='lower')\n&gt;&gt;&gt; input_threads = ['upper', 'lower']\n&gt;&gt;&gt; # Adder\n&gt;&gt;&gt; db.add(\"\", kind=\"mult_combiner\", inputs=input_threads, position=\"auto\", operation='sum')\n&gt;&gt;&gt; # Rest of the diagram (main thread)\n&gt;&gt;&gt; db.add(\"x(t)\", kind=\"output\")\n&gt;&gt;&gt; db.show()\n&gt;&gt;&gt; db.print_threads()\n</code></pre> Source code in <code>blockdiagrams\\DiagramBuilder.py</code> <pre><code>def print_threads(self):\n    \"\"\"\n    Prints name of each thread in diagram and actual position.\n\n    Examples:\n        &gt;&gt;&gt; from blockdiagrams import DiagramBuilder\n        &gt;&gt;&gt; db = DiagramBuilder(block_length=1, fontsize=16)\n        &gt;&gt;&gt; # Upper thread\n        &gt;&gt;&gt; db.add(\"x_1(t)\", kind=\"input\", thread='upper', position=(0, 1))\n        &gt;&gt;&gt; db.add(\"mult\", kind=\"combiner\", thread='upper', input_text=\"e^{-j\\\\omega_0 t}\", input_side='top', operation='mult')\n        &gt;&gt;&gt; db.add(\"\", kind=\"line\", thread='upper')\n        &gt;&gt;&gt; # Lower thread\n        &gt;&gt;&gt; db.add(\"x_2(t)\", kind=\"input\", thread='lower', position=(0, -1))\n        &gt;&gt;&gt; db.add(\"mult\", kind=\"combiner\", input_text=\"e^{j\\\\omega_0 t}\", input_side='bottom', operation='mult', thread='lower')\n        &gt;&gt;&gt; db.add(\"\", kind=\"line\", thread='lower')\n        &gt;&gt;&gt; input_threads = ['upper', 'lower']\n        &gt;&gt;&gt; # Adder\n        &gt;&gt;&gt; db.add(\"\", kind=\"mult_combiner\", inputs=input_threads, position=\"auto\", operation='sum')\n        &gt;&gt;&gt; # Rest of the diagram (main thread)\n        &gt;&gt;&gt; db.add(\"x(t)\", kind=\"output\")\n        &gt;&gt;&gt; db.show()\n        &gt;&gt;&gt; db.print_threads()\n    \"\"\"\n    for thread in self.thread_positions:\n        print(thread, \": \", self.thread_positions[thread])\n</code></pre>"},{"location":"reference/#blockdiagrams.DiagramBuilder.DiagramBuilder.show","title":"<code>show(margin=0.5, scale=1.0, savepath=None)</code>","text":"<p>Displays the current diagram or saves it to a file.</p> <p>Adjusts the view to fit the full diagram with an optional margin and scaling factor. If no elements have been drawn, simply displays an empty figure.</p> <p>Parameters:</p> Name Type Description Default <code>margin</code> <code>float</code> <p>Margin to add around the diagram (in data units).</p> <code>0.5</code> <code>scale</code> <code>float</code> <p>Scaling factor for the figure size.</p> <code>1.0</code> <code>savepath</code> <code>str</code> <p>If provided, saves the figure to the specified path (e.g., 'diagram.png' or 'diagram.pdf').                       If None, the diagram is shown in an interactive window.</p> <code>None</code> Source code in <code>blockdiagrams\\DiagramBuilder.py</code> <pre><code>def show(self, margin=0.5, scale=1.0, savepath=None):\n    \"\"\"\n    Displays the current diagram or saves it to a file.\n\n    Adjusts the view to fit the full diagram with an optional margin and scaling factor.\n    If no elements have been drawn, simply displays an empty figure.\n\n    Args:\n        margin (float, optional): Margin to add around the diagram (in data units).\n        scale (float, optional): Scaling factor for the figure size.\n        savepath (str, optional): If provided, saves the figure to the specified path (e.g., 'diagram.png' or 'diagram.pdf').\n                                  If None, the diagram is shown in an interactive window.\n\n    \"\"\"\n    bbox = self.__get_bbox__()\n    if bbox is None:\n        plt.show()\n        return\n\n    x0 = bbox.x0 - margin\n    x1 = bbox.x1 + margin\n    y0 = bbox.y0 - margin\n    y1 = bbox.y1 + margin\n\n    width = x1 - x0\n    height = y1 - y0\n\n    fig_width = width * scale\n    fig_height = height * scale\n    self.fig.set_size_inches(fig_width, fig_height)\n\n    self.ax.set_xlim(x0, x1)\n    self.ax.set_ylim(y0, y1)\n    self.ax.set_aspect(\"equal\", adjustable=\"box\")\n    self.ax.set_position([0, 0, 1, 1])\n    self.ax.axis(\"off\")\n\n    if savepath:\n        self.fig.savefig(savepath, bbox_inches='tight', dpi=self.fig.dpi, transparent=False, facecolor='white')\n        print(f\"Saved in: {savepath}\")\n    else:\n        plt.show()\n</code></pre>"}]}