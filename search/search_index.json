{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SignalBlocks","text":"<p>SignalBlocks is a Python library for visualizing and manipulating signals &amp; systems.</p> <p>Developed by Miguel \u00c1. Mart\u00edn-Fern\u00e1ndez, the goal of this package is to make it easy to create publication-ready block diagrams and plot symbolic signal definitions and combinations, including time-domain operations (shifting, scaling, convolution) with a minimal and intuitive API.</p>"},{"location":"#installation","title":"\ud83d\ude80 Installation","text":"<p>You can install the library using <code>pip</code> (once published):</p> <pre><code>pip install signalblocks\n</code></pre> <p>If you're working locally with the repository:</p> <pre><code>pip install -e .\n</code></pre>"},{"location":"#features","title":"\ud83d\udce6 Features","text":"<ul> <li>Create and draw block diagrams:<ul> <li>Draw basic blocks, summing junctions, arrows, and multipliers</li> <li>Horizontal/vertical or any angle layout support</li> <li>Customizable labels and positions</li> <li>Easy integration with Jupyter notebooks</li> <li>Thread for several lines in diagrams</li> <li>Feedback branches</li> </ul> </li> <li>Define and plot signals:<ul> <li>Typical signals: steps, deltas, rect, tri, sinc, ramp, ...</li> <li>Piecewise signals.</li> <li>Periodic signals support.</li> <li>Time shift operations.</li> <li>Signal combinations.</li> <li>Time sampling support.</li> <li>Convolutions with intermediate signals plot.</li> </ul> </li> </ul>"},{"location":"#block-diagram-basic-example","title":"\ud83e\uddf0 Block Diagram Basic Example","text":"<pre><code>from signalblocks import DiagramBuilder\n\ndb = DiagramBuilder(block_length=1, fontsize=16)\n\n# Diagram drawing\ndb.add(\"x(t)\", kind=\"input\")\ndb.add(\"h_{aa}(t)\", kind=\"block\")\ndb.add(\"x_c(t)\", kind=\"arrow\")\ndb.add(\"mult\", kind=\"combiner\", input_text=\"p(t)\", operation='mult', input_side='bottom')\ndb.add(\"x_p(t)\", kind=\"arrow\")\ndb.add(\"C/D\", kind=\"block\", input_text=\"T_s\", input_side='bottom')\ndb.add(\"x_d[n]\", kind=\"arrow\")\ndb.add(\"D/C\", kind=\"block\")\ndb.add(\"x_p(t)\", kind=\"arrow\")\ndb.add(\"h_r(t)\", kind=\"block\")\ndb.add(\"x_r(t)\", kind=\"output\")\n\n#db.show()\ndb.show(savepath = \"diag1.png\")\n</code></pre> <p>This will generate a basic sample and interpolation diagram.</p> <p></p>"},{"location":"#additional-examples","title":"\ud83e\uddf0 Additional examples","text":"<p>Additional examples notebook 1 Additional examples notebook 2</p>"},{"location":"#signal-basic-example","title":"\ud83d\udcca Signal Basic Example","text":"<pre><code>from signalblocks import SignalPlotter\n\nsp = SignalPlotter()\nsp.add_signal(\"x1(t)=2*delta(t-1)\")\nsp.add_signal(\"x2(t)=rect(t)\")\nsp.add_signal(\"x3(t)=x1(t) + x2(t)\")\nsp.plot(\"x3\")\n</code></pre> <p>This will generate a basic signal with a shifted Dirac Delta and a rect.</p> <p></p>"},{"location":"#documentation","title":"\ud83d\udcda Documentation","text":"<p>See the API Documentation for full reference of all available drawing functions and parameters.</p>"},{"location":"#contributing","title":"\ud83d\udee0\ufe0f Contributing","text":"<p>Feel free to open issues or pull requests on GitHub if you'd like to contribute or report bugs.</p>"},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>This project is licensed under the GNU GPL v3.0 or later.</p>"},{"location":"reference/","title":"API Reference","text":""},{"location":"reference/#diagrambuilder","title":"DiagramBuilder","text":""},{"location":"reference/#signalblocks.DiagramBuilder.DiagramBuilder","title":"<code>DiagramBuilder</code>","text":"<p>A helper class for incrementally building signal processing diagrams using Matplotlib.</p> <p>This class provides high-level methods to add standard diagram components like blocks, arrows, combiners, and input/output labels, keeping track of layout and threading.</p> <p>Parameters:</p> Name Type Description Default <code>block_length</code> <code>float</code> <p>Default horizontal size of blocks.</p> <code>1.0</code> <code>block_height</code> <code>float</code> <p>Default vertical size of blocks.</p> <code>1.0</code> <code>fontsize</code> <code>int</code> <p>Default font size for all text.</p> <code>20</code> <p>Returns:</p> Type Description <code>DiagramBuilder</code> <p>created object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from signalblocks import DiagramBuilder\n&gt;&gt;&gt; db1 = DiagramBuilder()\n&gt;&gt;&gt; db2 = DiagramBuilder(block_length=2, fontsize=16)\n</code></pre> Source code in <code>signalblocks\\DiagramBuilder.py</code> <pre><code>class DiagramBuilder:\n    \"\"\"\n    A helper class for incrementally building signal processing diagrams using Matplotlib.\n\n    This class provides high-level methods to add standard diagram components like blocks, arrows,\n    combiners, and input/output labels, keeping track of layout and threading.\n\n    Args:\n        block_length (float, optional): Default horizontal size of blocks.\n        block_height (float, optional): Default vertical size of blocks.\n        fontsize (int, optional): Default font size for all text.\n\n    Returns:\n        (DiagramBuilder): created object.\n\n    Examples:\n        &gt;&gt;&gt; from signalblocks import DiagramBuilder\n        &gt;&gt;&gt; db1 = DiagramBuilder()\n        &gt;&gt;&gt; db2 = DiagramBuilder(block_length=2, fontsize=16)\n    \"\"\"\n    def __init__(self, block_length=1.0, block_height=1.0, fontsize=20):\n        \"\"\"\n        (Private) Creator of the DiagramBuilder class.\n        \"\"\"\n        self.fig, self.ax = plt.subplots()\n        self.ax.axis('off')  # Hide axes\n        self.fontsize = fontsize\n        self.block_length = block_length\n        self.block_height = block_height\n        self.thread_positions = {}\n        self.thread_positions['main'] = [0, 0]\n        # Dictionary to store element positions: input_pos, output_pos, feedback_pos\n        self.element_positions = {}\n        # Counter for current element\n        self.current_element = -1\n\n    def print_threads(self):\n        \"\"\"\n        Prints name of each thread in diagram and actual position.\n\n        Examples:\n            &gt;&gt;&gt; from signalblocks import DiagramBuilder\n            &gt;&gt;&gt; db = DiagramBuilder(block_length=1, fontsize=16)\n            &gt;&gt;&gt; # Upper thread\n            &gt;&gt;&gt; db.add(\"x_1(t)\", kind=\"input\", thread='upper', position=(0, 1))\n            &gt;&gt;&gt; db.add(\"mult\", kind=\"combiner\", thread='upper', input_text=\"e^{-j\\\\omega_0 t}\", input_side='top', operation='mult')\n            &gt;&gt;&gt; db.add(\"\", kind=\"line\", thread='upper')\n            &gt;&gt;&gt; # Lower thread\n            &gt;&gt;&gt; db.add(\"x_2(t)\", kind=\"input\", thread='lower', position=(0, -1))\n            &gt;&gt;&gt; db.add(\"mult\", kind=\"combiner\", input_text=\"e^{j\\\\omega_0 t}\", input_side='bottom', operation='mult', thread='lower')\n            &gt;&gt;&gt; db.add(\"\", kind=\"line\", thread='lower')\n            &gt;&gt;&gt; input_threads = ['upper', 'lower']\n            &gt;&gt;&gt; # Adder\n            &gt;&gt;&gt; db.add(\"\", kind=\"mult_combiner\", inputs=input_threads, position=\"auto\", operation='sum')\n            &gt;&gt;&gt; # Rest of the diagram (main thread)\n            &gt;&gt;&gt; db.add(\"x(t)\", kind=\"output\")\n            &gt;&gt;&gt; db.show()\n            &gt;&gt;&gt; db.print_threads()\n        \"\"\"\n        for thread in self.thread_positions:\n            print(thread, \": \", self.thread_positions[thread])\n\n\n    # --- Helper functions ---\n\n    def __get_bbox__(self):\n        return self.ax.dataLim\n\n    def __get_rotated_pos__(self, init_pos, outvector, angle):\n        \"\"\"\n        Inner method.\n        Compute rotated point init_pos + outvector.\n\n        Args:\n            init_pos (Numpy.NDArray or list): Initial position of the block (relative origin of coordinates).\n            outvector (Numpy.NDArray or list): Output vector before rotation (relative position with respect to init_pos).\n            angle (float): Rotation angle in degrees.\n\n        Returns:\n            (Numpy.NDArray): Rotated position of vector init_pos + outvector.\n        \"\"\"\n\n        # Output point respect to input point (before rotation)\n        out_vector = np.array(outvector)\n        # Rotation matrix (without translation)\n        rotation_matrix = transforms.Affine2D().rotate_deg(angle).get_matrix()[:2, :2]\n        # Apply rotation to the output vector\n        dx, dy = rotation_matrix @ out_vector\n        # Add the rotated output vector to the initial position\n        return np.array([init_pos[0] + dx, init_pos[1] + dy])\n\n    def __add_element_position__(self, input_pos: Tuple[float, float], \n                                 output_pos: Tuple[float, float], \n                                 feedback_pos: Tuple[float, float]):\n        \"\"\"\n        Inner method.\n        Adds a new element with the given input, output and feedback positions.\n\n        Args:\n            input_pos (Numpy.NDArray or list): Input position of the block.\n            output_pos (Numpy.NDArray or list): Output position of the block.\n            feedback_pos (Numpy.NDArray or list): Feedback port position of the block.\n        \"\"\"\n        self.current_element += 1\n\n        self.element_positions[self.current_element] = ElementPosition(\n            input_pos=input_pos,\n            output_pos=output_pos,\n            feedback_pos=feedback_pos\n        )\n\n    # --- Drawing functions ---\n\n    def __draw_rotated_text__(self, anchor_point, text, angle, rotate_text = True,\n                      ha='center', va='center', fontsize=16, offset=(0, 0)):\n        \"\"\"\n        Inner method.\n        Draws text rotated around the anchor point with optional offset. \n        Text position: rotation(anchor_point + offset)\n\n        Args:\n            anchor_point (Numpy.NDArray or list): Coordinates of the anchor point.\n            text (string): String to display. LaTeX math accepted (without $...$).\n            angle (float): Rotation angle in degrees.\n            rotate_text (bool, optional): Indicates if text must be rotated or not.\n            ha (string, optional): Horizontal alignment: {'center', 'left', 'right'}.\n            va (string, optional): Vertical alignment: {'center', 'bottom', 'top'}.\n            fontsize (int, optional): Font size.\n            offset (Numpy.NDArray or list): Coordinates of texr position respect to anchor point, before rotation.\n        \"\"\"\n        # Apply rotation to the offset vector\n        dx, dy = offset\n        offset_vec = np.array([dx, dy])\n        rot_matrix = transforms.Affine2D().rotate_deg(angle).get_matrix()[:2, :2]\n        dx_rot, dy_rot = rot_matrix @ offset_vec\n\n        # Compute final position\n        tx = anchor_point[0] + dx_rot\n        ty = anchor_point[1] + dy_rot\n\n        if rotate_text is False:\n            text_angle = 0\n        else:\n            text_angle = angle\n\n        # Draw text with angle, rotating around anchor point\n        self.ax.text(tx, ty, f\"${text}$\", ha=ha, va=va, fontsize=fontsize,\n                rotation=text_angle, rotation_mode='anchor', transform=self.ax.transData)\n\n\n    def __draw_block__(self, initial_position, text=None, text_below=None, \n                       text_above=None, text_offset=0.1, input_text=None, \n                       input_side=None, length=1.5, height=1, fontsize=14, \n                       linestyle='-', orientation='horizontal'):\n        \"\"\"\n        Inner method.\n        Draws a rectangular block with centered text, optional texts below and/or above and optional input arrow with text.\n\n        Args:\n            initial_position (Numpy.NDarray or list): Coordinates of the center position of the input edge of the block.\n            text (string, optional): Label to display in the block.\n            text_below (string, optional): Label to display below the block.\n            text_above (string, optional): Label to display above the block.\n            text_offset (float, optional): Vertical offset for the text position.\n            input_text (string, optional): Label for the optional input arrow (below or above the block).\n            input_side (string, optional): Side to place the input arrow: {'bottom', 'top', None}\n            length (float, optional): Horizontal length of the block. If not entered, default `block_length` is used.\n            height (float, optional): Vertical height of the block. If not entered, default `block_height` is used.\n            fontsize (int, optional): font size of the text inside the block. If not entered, default `fontsize` is used.\n            linestyle (string, optional): linestyle of the block edge: {'-, '--, ':', '-.'}.\n            orientation (string or float, optional): Direction of the block: {'horizontal', 'vertical', 'up', 'down', 'left', 'right', angle}.\n\n        Returns:\n            (Numpy.NDArray): Coordinates of the center position of the output edge of the block.\n        \"\"\"\n        # Parameters validation\n        if input_side not in (None, 'top', 'bottom'):\n            raise ValueError(f\"Invalid input_side: {input_side}. Use 'top' or 'bottom'.\")\n        if orientation not in (None, 'horizontal', 'vertical', 'up', 'down', 'left', 'right'):\n            if isinstance(orientation, (int, float)):\n                pass\n            else:\n                raise ValueError(f\"Invalid orientation: {orientation}. Use 'horizontal', 'vertical', 'up', 'down', 'left', or 'right'.\")\n        if linestyle not in (None, '-', '--', ':', '-.', 'solid', 'dashed', 'dotted', 'dashdot'):\n            raise ValueError(f\"Invalid linestyle: {linestyle}. Use '-', '--', ':', '-.', 'solid', 'dashed', 'dotted', or 'dashdot'.\")\n        if not isinstance(length, (int, float)) or length &lt;= 0:\n            raise ValueError(f\"Invalid length: {length}. Length must be a positive number.\")\n        if not isinstance(height, (int, float)) or height &lt;= 0:\n            raise ValueError(f\"Invalid height: {height}. Height must be a positive number.\")\n        if not isinstance(text_offset, (int, float)):\n            raise ValueError(f\"Invalid text_offset: {text_offset}. Text offset must be a number.\")\n        if not isinstance(fontsize, (int, float)):\n            raise ValueError(f\"Invalid fontsize: {fontsize}. Font size must be a number.\")\n\n\n        # Determine rotation angle based on orientation\n        if orientation in ['horizontal', 'right']:\n            angle = 0\n        elif orientation == 'left':\n            angle = 180\n        elif orientation in ['vertical', 'down']:\n            angle = -90\n        elif orientation == 'up':\n            angle = 90\n        elif isinstance(orientation, (int, float)):\n            angle = orientation\n        else:\n            angle = 0\n\n        x_in, y_in = initial_position\n\n        # Bottom-left corner of the block (before rotation)\n        x0 = x_in\n        y0 = y_in - height / 2\n\n        # Center of the block (before rotation)\n        cx = x_in + length / 2\n        cy = y_in\n\n        # Apply the rotation around the connection point (x_ini, y_ini)\n        trans = transforms.Affine2D().rotate_deg_around(x_in, y_in, angle) + self.ax.transData   \n\n        self.ax.add_patch(Rectangle((x0, y0), length, height, \n                                    edgecolor='black', facecolor='none', \n                                    linestyle=linestyle, transform=trans))\n        # Don't rotate text if orientation is vertical, down or up\n        rotate_text = False if orientation in ['vertical', 'down', 'up', 'left'] else True\n\n        # Draw text inside the block\n        if text is not None:\n            offset_vector = np.array([length / 2, 0])\n            self.__draw_rotated_text__(initial_position, text, \n                                       angle=angle, rotate_text=rotate_text,\n                                       ha='center', va='center', \n                                       fontsize=fontsize, offset=offset_vector)\n\n        # Draw text above the block\n        if text_above is not None:\n            if orientation in ['vertical', 'down']:\n                ha = 'left'\n                va = 'center'\n            elif orientation in ['up']:\n                ha = 'right'\n                va = 'center'\n            else:\n                ha = 'center'\n                va = 'bottom'\n            offset_vector = np.array([length / 2, height / 2 + text_offset])\n            self.__draw_rotated_text__(initial_position, text_above, \n                                       angle=angle, rotate_text=rotate_text,\n                                       ha=ha, va=va, \n                                       fontsize=fontsize, offset=offset_vector)\n\n        # Draw text below the block\n        if text_below is not None:\n            if orientation in ['vertical', 'down']:\n                ha = 'right'\n                va = 'center'\n            elif orientation in ['up']:\n                ha = 'left'\n                va = 'center'\n            else:\n                ha = 'center'\n                va = 'top'\n            offset_vector = np.array([length / 2, - height / 2 - text_offset])\n            self.__draw_rotated_text__(initial_position, text_below, \n                                       angle=angle, rotate_text=rotate_text,\n                                       ha=ha, va=va, \n                                       fontsize=fontsize, offset=offset_vector)\n\n        if input_side is not None:\n            if input_side == 'bottom':\n                arrow_height = 0.75 * height\n                y_init = y0 - arrow_height\n                offset_vector = np.array([length / 2, - height /2 - arrow_height - text_offset])\n                va = 'top'\n                ha = 'center'\n                if orientation in ['vertical', 'down']:\n                    ha = 'right'\n                    va = 'center'\n                elif orientation in ['up']:\n                    ha = 'left'\n                    va = 'center'\n                elif orientation in ['left']:\n                    ha = 'center'\n                    va = 'bottom'\n            elif input_side == 'top':\n                arrow_height = - 0.75 * height\n                y_init = y0 + height - arrow_height\n                offset_vector = np.array([length / 2, height /2 - arrow_height + text_offset])\n                va = 'bottom'\n                ha = 'center'\n                if orientation in ['vertical', 'down']:\n                    ha = 'left'\n                    va = 'center'\n                elif orientation in ['up']:\n                    ha = 'right'\n                    va = 'center'\n                elif orientation in ['left']:\n                    ha = 'center'\n                    va = 'top'\n            else:\n                raise ValueError(f\"Unknown input side: {input_side}. Use 'bottom' or 'top'.\")   \n\n            self.ax.add_patch(FancyArrow(cx, y_init, 0, arrow_height, width=0.01,\n                                    length_includes_head=True, head_width=0.15, \n                                    color='black', transform=trans))\n            if input_text is not None:\n\n                self.__draw_rotated_text__(initial_position, input_text, \n                                           angle=angle, rotate_text=rotate_text,\n                                           ha=ha, va=va, \n                                           fontsize=fontsize, offset=offset_vector)\n\n        # Compute rotated output point\n        output_pos = self.__get_rotated_pos__(initial_position, [length, 0], angle)\n        # Compute feedback point\n        feedback_pos = self.__get_rotated_pos__(initial_position, [length/2, -height/2], angle)\n        # Add element position to the dictionary\n        self.__add_element_position__(input_pos=[x_in,y_in], output_pos=output_pos,\n                                      feedback_pos=feedback_pos)\n        return output_pos\n\n    def __draw_arrow__(self, initial_position, length, text=None, \n                       text_position = 'above', text_offset=0.2, arrow = True,\n                       fontsize=14, orientation='horizontal'):\n        \"\"\"\n        Inner method.\n        Draws a horizontal arrow with optional label.\n\n        Args:\n            initial_position (Numpy.NDarray or list): Coordinates of the starting point of the arrow.\n            length (float, optional): Horizontal length of the block. If not entered, default `block_length` is used.\n            text (string, optional): Label to display in the block.\n            text_position (string, optional): Position of the optional text: {'before', 'after', 'above'}\n            text_offset (float, optional): Vertical offset for the text position.\n            arrow (bool, optional): Indicated if an line mush finish or not in an arrow.\n            fontsize (int, optional): font size of the text inside the block. If not entered, default `fontsize` is used.\n            orientation (string or float, optional): Direction of the block: {'horizontal', 'vertical', 'up', 'down', 'left', 'right', angle}.\n\n        Returns:\n            (Numpy.NDArray): Coordinates of output point of the arrow.\n        \"\"\"\n        # end = (initial_position[0] + length, initial_position[1])\n        head_width = 0.15 if arrow else 0\n\n        angle = 0\n        # Determine rotation angle based on orientation\n        if orientation in ['horizontal', 'right']:\n            angle = 0\n        elif orientation == 'left':\n            angle = 180\n        elif orientation in ['vertical', 'down']:\n            angle = -90\n        elif orientation == 'up':\n            angle = 90\n        elif isinstance(orientation, (int, float)):\n            angle = orientation\n        else:\n            angle = 0\n\n        x_in, y_in = initial_position\n\n        # Apply rotation around the connection point (x_ini, y_ini)\n        trans = transforms.Affine2D().rotate_deg_around(x_in, y_in, angle) + self.ax.transData   \n\n\n        self.ax.add_patch(FancyArrow(x_in, y_in, length, 0, width=0.01,\n                                length_includes_head=True, head_width=head_width, \n                                color='black', transform=trans))\n\n        # Don't rotate text if orientation is vertical, down or up\n        rotate_text = False if orientation in ['vertical', 'down', 'up', 'left'] else True\n\n        if text:\n            # Calculate offset vector based on orientation in non-rotated coordinates\n            if text_position == 'before':\n                ha, va = 'right', 'center'\n                offset_vector = np.array([-text_offset, 0])\n                if orientation in ['vertical', 'down']:\n                    ha = 'center'\n                    va = 'bottom'\n                elif orientation in ['up']:\n                    ha = 'center'\n                    va = 'top'\n            elif text_position == 'after':\n                ha, va = 'left', 'center'\n                offset_vector = np.array([length + text_offset, 0])\n                if orientation in ['vertical', 'down']:\n                    ha = 'center'\n                    va = 'top'\n                elif orientation in ['up']:\n                    ha = 'center'\n                    va = 'bottom'\n            elif text_position == 'above':\n                ha, va = 'center', 'bottom'\n                offset_vector = np.array([length / 2, text_offset])\n                if orientation in ['vertical', 'down',]:\n                    ha = 'left'\n                    va = 'bottom'\n                elif orientation in ['up']:\n                    ha = 'right'\n                    va = 'top'\n            else:\n                raise ValueError(f\"Unknown text_position: {text_position}\")\n\n            self.__draw_rotated_text__(initial_position, text, \n                                       angle=angle, rotate_text=rotate_text,\n                                       ha=ha, va=va, offset=offset_vector,\n                                       fontsize=fontsize)\n\n        # Compute rotated output point\n        output_pos = self.__get_rotated_pos__(initial_position, [length, 0], angle)\n        # Compute feedback point\n        feedback_pos = self.__get_rotated_pos__(initial_position, [length/2, 0], angle)\n        # Add element position to the dictionary\n        self.__add_element_position__(input_pos=[x_in,y_in], output_pos=output_pos,\n                                      feedback_pos=feedback_pos)\n        return output_pos\n\n    def __draw_angled_arrow__(self, initial_position, final_position, \n                            text=None, text_offset=0.2, arrow = True, fontsize=14,\n                            first_segment='horizontal', orientation='horizontal'):\n        \"\"\"\n        Inner method.\n        Draws a right-angled arrow composed of two segments, with a specified first segment orientation and optional label.\n\n        Args:\n            initial_position (Numpy.NDarray or list): Coordinates of the starting point of the arrow.\n            final_position (Numpy.NDarray or list): Coordinates of the ending point of the arrow.\n            text (string, optional): Label to display in the block.\n            text_offset (float, optional): Vertical offset for the text position.\n            arrow (bool, optional): Indicates if it must finish or not in an arrow.\n            fontsize (int, optional): font size of the text inside the block. If not entered, default `fontsize` is used.\n            first_segment (string, optional): Drawing order: {'horizontal', 'vertical'}\n            orientation (string or float, optional): Direction of the block: {'horizontal', 'vertical', 'up', 'down', 'left', 'right', angle}.\n\n        Returns:\n            (Numpy.NDArray): Coordinates of output point of the arrow.\n        \"\"\"\n        head_width = 0.15 if arrow else 0\n\n        angle = 0\n        # Determine rotation angle based on orientation\n        if orientation in ['horizontal', 'right']:\n            angle = 0\n        elif orientation == 'left':\n            angle = 180\n        elif orientation in ['vertical', 'down']:\n            angle = -90\n        elif orientation == 'up':\n            angle = 90\n        elif isinstance(orientation, (int, float)):\n            angle = orientation\n        else:\n            angle = 0\n\n        x_in, y_in = initial_position\n        x_out, y_out = final_position\n        dx = x_out - x_in\n        dy = y_out - y_in\n\n        # Apply rotation around the connection point (x_ini, y_ini)\n        trans = transforms.Affine2D().rotate_deg_around(x_in, y_in, angle) + self.ax.transData   \n\n        if first_segment == 'horizontal':\n            corner = (x_out, y_in)\n        elif first_segment == 'vertical':\n            corner = (x_in, y_out)\n        else:\n            raise ValueError(\"first_segment must be either 'horizontal' or 'vertical'\")\n\n        # Draw segments\n        if first_segment == 'horizontal':\n            if dx != 0:\n                self.ax.add_patch(FancyArrow(x_in, y_in, dx, 0, width=0.01,\n                        length_includes_head=True, head_width=0, \n                        color='black', transform=trans))\n            if dy != 0:\n                self.ax.add_patch(FancyArrow(corner[0], corner[1], 0, dy, width=0.01,\n                        length_includes_head=True, head_width=head_width, \n                        color='black', transform=trans))\n        else:  # first vertical\n            if dy != 0:\n                self.ax.add_patch(FancyArrow(x_in, y_in, 0, dy, width=0.01,\n                        length_includes_head=True, head_width=0, \n                        color='black', transform=trans))\n            if dx != 0:\n                self.ax.add_patch(FancyArrow(corner[0], corner[1], dx, 0, width=0.01,\n                        length_includes_head=True, head_width=head_width, \n                        color='black', transform=trans))\n\n        # Don't rotate text if orientation is vertical, down or up\n        rotate_text = False if orientation in ['vertical', 'down', 'up', 'left'] else True\n\n        # Optional text near the corner\n        if text:\n            # Calculate offset vector based on orientation in non-rotated coordinates\n            if first_segment == 'horizontal':\n                offset_vector = np.array([dx/2, text_offset])    \n            else: # first vertical\n                offset_vector = np.array([dx/2, dy + text_offset])    \n\n            self.__draw_rotated_text__(initial_position, text, \n                                       angle=angle, rotate_text=rotate_text,\n                                       ha='center', va='bottom', offset=offset_vector,\n                                       fontsize=fontsize)\n\n        # Compute rotated output point\n        output_pos = self.__get_rotated_pos__(final_position, [0, 0], angle)\n        # Compute feedback point\n        feedback_pos = self.__get_rotated_pos__(corner, [0, 0], angle)\n        # Save element position\n        self.__add_element_position__(input_pos=initial_position, output_pos=output_pos, feedback_pos=feedback_pos)\n\n        return output_pos\n\n    def __draw_combiner__(self, initial_position, height=1,\n                        input_text=None, input_side='bottom', operation='mult', \n                        text_offset=0.1, signs=[None, None], fontsize=14, orientation='horizontal'):\n        \"\"\"\n        Inner method.\n        Draws a combiner block: a circle with a multiplication sign (\u00d7), sum sign (+) \n        or substraction sign (-) inside, with optional signs on each input.\n\n        Args:\n            initial_position (Numpy.NDarray or list): Coordinates of the starting point of the arrow.\n            height (float, optional): Vertical height of the block. If not entered, default `block_height` is used.\n            input_text (string, optional): Label for the input arrow (below or above the arrow).\n            input_side (string, optional): Side of the lateral input: {'bottom', 'top'}.\n            operation (string, optional): Operation of the combiner: {'mult', 'sum', 'dif'}.\n            text_offset (float, optional): Vertical offset for the text position.\n            signs (list, optional): Sign to be shown on the horizontal (signs[0]) and vertical (signs[1]) inputs.\n            fontsize (int, optional): font size of the text inside the block. If not entered, default `fontsize` is used.\n            orientation (string or float, optional): Direction of the block: {'horizontal', 'vertical', 'up', 'down', 'left', 'right', angle}.\n\n        Returns:\n            (Numpy.NDArray): Coordinates of output point of the combiner.\n        \"\"\"\n        angle = 0\n        # Determine rotation angle based on orientation\n        if orientation in ['horizontal', 'right']:\n            angle = 0\n        elif orientation == 'left':\n            angle = 180\n        elif orientation in ['vertical', 'down']:\n            angle = -90\n        elif orientation == 'up':\n            angle = 90\n        elif isinstance(orientation, (int, float)):\n            angle = orientation\n        else:\n            angle = 0\n\n        x_in, y_in = initial_position\n\n        radius = height / 4\n        # Center of the block (before rotation)\n        cx = x_in + radius\n        cy = y_in\n\n        # Apply rotation around the connection point (x_ini, y_ini)\n        trans = transforms.Affine2D().rotate_deg_around(x_in, y_in, angle) + self.ax.transData  \n\n        circle = plt.Circle((cx, cy), radius, edgecolor='black', \n                            facecolor='white', transform=trans, zorder=2)\n        self.ax.add_patch(circle)\n\n        rel_size = 0.7\n        if operation == 'mult':\n            # L\u00edneas diagonales (forma de \"X\") dentro del c\u00edrculo\n            dx = radius * rel_size * np.cos(np.pi / 4)  # Escalamos un poco para que quepa dentro del c\u00edrculo\n            dy = radius * rel_size * np.sin(np.pi / 4)\n            # L\u00ednea de 45\u00b0\n            self.ax.plot([cx - dx, cx + dx], [cy - dy, cy + dy], color='black', \n                         linewidth=2, transform=trans, zorder=3)\n            # L\u00ednea de 135\u00b0\n            self.ax.plot([cx - dx, cx + dx], [cy + dy, cy - dy], color='black', \n                         linewidth=2, transform=trans, zorder=3)\n\n        elif operation == 'sum':\n            dx = radius * rel_size\n            dy = radius * rel_size\n            # L\u00edneas horizontales y verticales (forma de \"+\") dentro del c\u00edrculo\n            self.ax.plot([cx - dx, cx + dx], [cy, cy], color='black', \n                         linewidth=2, transform=trans, zorder=3)\n            self.ax.plot([cx, cx], [cy - dy, cy + dy], color='black', \n                         linewidth=2, transform=trans, zorder=3)\n        elif operation == 'dif':\n            dx = radius * rel_size\n            # L\u00ednea horizontal (forma de \"-\") dentro del c\u00edrculo\n            self.ax.plot([cx - dx, cx + dx], [cy, cy], color='black', \n                         linewidth=2, transform=trans, zorder=3)\n        else:\n            raise ValueError(f\"Unknown operation: {operation}. 'operation' must be 'mult', 'sum' or 'dif'.\")\n\n        # Don't rotate text if orientation is vertical, down or up\n        rotate_text = False if orientation in ['vertical', 'down', 'up', 'left'] else True\n\n        # Side input\n        if input_side == 'bottom':\n            arrow_height = height - radius\n            y_init = y_in - radius - arrow_height\n            offset_vector = np.array([radius, - (height + text_offset)])\n            va = 'top'\n            ha = 'center'\n            if orientation in ['vertical', 'down']:\n                ha = 'right'\n                va = 'center'\n            elif orientation in ['up']:\n                ha = 'left'\n                va = 'center'\n        elif input_side == 'top':\n            arrow_height = - (height - radius)\n            y_init = y_in + radius - arrow_height\n            offset_vector = np.array([radius, height + text_offset])\n            va = 'bottom'\n            ha = 'center'\n            if orientation in ['vertical', 'down']:\n                ha = 'left'\n                va = 'center'\n            elif orientation in ['up']:\n                ha = 'right'\n                va = 'center'\n        else:\n            raise ValueError(f\"Unknown input_side: {input_side}. 'input_side' must be 'bottom' or 'top'.\")\n\n        # Show signs on each input if not None\n        if signs[0] is not None:\n            self.__draw_rotated_text__(initial_position, signs[0], \n                                    angle=angle, rotate_text=rotate_text,\n                                    ha=ha, va=va, \n                                    fontsize=fontsize, offset=[-radius, 1.5*radius])\n        if signs[1] is not None:\n            self.__draw_rotated_text__(initial_position, signs[1], \n                                    angle=angle, rotate_text=rotate_text,\n                                    ha=ha, va=va, \n                                    fontsize=fontsize, offset=[0, -1.5*radius])\n\n        self.ax.add_patch(FancyArrow(cx, y_init, 0, arrow_height, width=0.01,\n                                length_includes_head=True, head_width=0.15, \n                                color='black', transform=trans))\n        if input_text is not None:\n            self.__draw_rotated_text__(initial_position, input_text, \n                                       angle=angle, rotate_text=rotate_text,\n                                       ha=ha, va=va, \n                                       fontsize=fontsize, offset=offset_vector)\n\n        # Compute rotated output point\n        output_pos = self.__get_rotated_pos__(initial_position, [2 * radius, 0], angle)\n        # Compute feedback point\n        feedback_pos = self.__get_rotated_pos__(initial_position, [radius, y_init - y_in + arrow_height], angle)\n        # Add element position to the dictionary\n        self.__add_element_position__(input_pos=[x_in,y_in], output_pos=output_pos,\n                                      feedback_pos=feedback_pos)\n        return output_pos\n\n    def __draw_mult_combiner__(self, initial_position, length, inputs, \n                               operation='sum', orientation='horizontal'):\n        \"\"\"\n        Inner method.\n        Draws a summation or multiplication block with multiple inputs distributed \n        along the left edge of a circle, from pi/2 to 3*pi/2. Inputs can have a sign.\n\n        Args:\n            initial_position (Numpy.NDarray or list): Coordinates of the starting point of the arrow.\n            length (float, optional): Horizontal length of the block. If not entered, default `block_length` is used.\n            inputs (list of str): Thread names to combine.\n            operation (string, optional): Operation of the combiner: {'mult', 'sum'}.\n            orientation (string or float, optional): Direction of the block: {'horizontal', 'vertical', 'up', 'down', 'left', 'right', angle}.\n\n        Returns:\n            (Numpy.NDArray): Coordinates of output point of the combiner.\n        \"\"\"\n        angle = 0\n        # Determine rotation angle based on orientation\n        if orientation in ['horizontal', 'right']:\n            angle = 0\n        elif orientation == 'left':\n            angle = 180\n        elif orientation in ['vertical', 'down']:\n            angle = -90\n        elif orientation == 'up':\n            angle = 90\n        elif isinstance(orientation, (int, float)):\n            angle = orientation\n        else:\n            angle = 0\n\n        # If position is 'auto', obtain head position\n        if isinstance(initial_position, str) and initial_position == 'auto':\n            # Get head positions of input threads\n            thread_input_pos = np.array([self.thread_positions[key] for key in inputs])\n            x_in = np.max(thread_input_pos[:, 0])\n            y_in = np.mean(thread_input_pos[:,1])\n            initial_position = [x_in, y_in]\n        # If position is given, use it\n        else:\n            x_in, y_in = initial_position\n\n        radius = length / 4\n        cx = x_in + length - radius\n        cy = y_in\n\n        # Apply rotation around the connection point (x_ini, y_ini)\n        trans = transforms.Affine2D().rotate_deg_around(x_in, y_in, angle) + self.ax.transData  \n\n        # Circle\n        circle = plt.Circle((cx, cy), radius, edgecolor='black', \n                            facecolor='white', transform=trans, zorder=2)\n        self.ax.add_patch(circle)\n\n        # Draw symbol inside circle depending on operation\n        rel_size = 0.7\n        if operation == 'mult':\n            # \"X\" inside circle\n            dx = radius * rel_size * np.cos(np.pi / 4)  # Escalamos un poco para que quepa dentro del c\u00edrculo\n            dy = radius * rel_size * np.sin(np.pi / 4)\n            #  45\u00b0 line\n            self.ax.plot([cx - dx, cx + dx], [cy - dy, cy + dy], color='black', \n                         linewidth=2, transform=trans, zorder=3)\n            # 135\u00b0 line\n            self.ax.plot([cx - dx, cx + dx], [cy + dy, cy - dy], color='black', \n                         linewidth=2, transform=trans, zorder=3)\n        elif operation == 'sum':\n            dx = radius * rel_size\n            dy = radius * rel_size\n            # \"+\" inside circle\n            self.ax.plot([cx - dx, cx + dx], [cy, cy], color='black', \n                         linewidth=2, transform=trans, zorder=3)\n            self.ax.plot([cx, cx], [cy - dy, cy + dy], color='black', \n                         linewidth=2, transform=trans, zorder=3)\n        else:\n            raise ValueError(f\"Unknown operation: {operation}. Use 'sum' or 'mult'.\")\n\n        # Get rotation matrix\n        rot_matrix = transforms.Affine2D().rotate_deg(angle).get_matrix()[:2, :2]\n\n        n = len(thread_input_pos)\n        angles = np.linspace(5* np.pi / 8, 11 * np.pi / 8, n)\n\n        arrow_width = 0.01\n        arrow_head_width = 0.15\n\n        # Input arrows\n        for i, inp in enumerate(thread_input_pos):\n            xi, yi = inp[:2]\n\n            x_edge = cx + radius * np.cos(angles[i])\n            y_edge = cy + radius * np.sin(angles[i])\n\n            dx = x_edge - x_in\n            dy = y_edge - y_in\n            offset_vec = [dx, dy]\n\n            # Rotated offset vector with respect to initial_position of element\n            dx_rot, dy_rot = rot_matrix @ offset_vec\n            # Rotated offset vector with respect to initial position of arrow\n            dx_rot_rel = dx_rot - xi + x_in\n            dy_rot_rel = dy_rot - yi + y_in\n\n            self.ax.add_patch(FancyArrow(\n                xi, yi, dx_rot_rel, dy_rot_rel,\n                width=arrow_width,\n                length_includes_head=True,\n                head_width=arrow_head_width,\n                color='black', transform=self.ax.transData, zorder=1\n            ))\n\n        # Compute rotated output point\n        output_pos = self.__get_rotated_pos__(initial_position, [length, 0], angle)\n        # Compute feedback point\n        feedback_pos = self.__get_rotated_pos__(initial_position, [length - radius, -radius], angle)\n        # Add element position to the dictionary\n        self.__add_element_position__(input_pos=[x_in,y_in], output_pos=output_pos,\n                                      feedback_pos=feedback_pos)\n        return output_pos\n\n    def add(self,name, kind='block', thread='main', position=None, debug=False, **kwargs):\n        \"\"\"\n        Adds an element to the block diagram at the current or specified position of a given thread.\n\n        This is the main interface for constructing diagrams by adding components such as blocks, arrows,\n        inputs, outputs, combiners, and connectors. The `kind` parameter determines the type of element,\n        and each type accepts specific keyword arguments listed below.\n\n        Args:\n            name (str): Main label or identifier for the element.\n            kind (str, optional): Type of element. One of:\n                - 'block': Rectangular block.\n                - 'arrow': Straight line with ending arrow.\n                - 'angled_arrow': Rect angle line with or without ending arrow.\n                - 'input': Arrow with text before it.\n                - 'output': Arrow with text after it.\n                - 'line': Straight line without arrow ending.\n                - 'combiner': Circle with (x), (+) or (-) and additional input.\n                - 'mult_combiner': Combiner with multiple inputs.\n            thread (str, optional): Thread identifier.\n            position (tuple or str or None, optional): (x, y) position, 'auto' (for mult_combiner), or None to use current thread position.\n            debug (bool, optional): If True, prints thread positions after placing the element.\n\n        The `**kwargs` vary depending on the `kind`:\n\n        - **kind = 'block'**:\n            - text (str, optional): Label inside the block (defaults to `name`).\n            - text_above (str, optional): Text above the block.\n            - text_below (str, optional): Text below the block.\n            - text_offset (float, optional): Offset for above/below text (defaults to 0.1).\n            - input_text (str, optional): Label for input arrow.\n            - input_side (str, optional): Side of a second optional input: {'top', 'bottom'} (defaults to `None`)\n            - length (float, optional): Block length (defaults to `self.block_length`).\n            - height (float, optional): Block height (defaults to `self.block_height`)..\n            - linestyle (str, optional): Block border line style (defaults to `-`).\n            - orientation (str or float, optional): Orientation of the block: {'horizontal', 'vertical', 'up', 'down' 'right', left' or angle in degrees} (defaults to 'horizontal').\n            - fontsize (int, optional): Text font size (defaults to `self.fontsize`).\n\n        - **kind = 'arrow'**, **'input'**, **'output'** or **'line'**:\n            - text (str, optional): Text on the arrow or line (defaults to `name`).\n            - text_position (str, optional): 'above', 'below', 'before', or 'after' (defaults to 'above' for 'arrow' and 'line', 'before' for 'input', and 'after' for 'output').\n            - text_offset (float, optional): Offset for text (defaults to 0.1).\n            - length (float, optional): Arrow or line length (defaults to `self.block_length`).\n            - orientation (str or float, optional): Orientation of the block: {'horizontal', 'vertical', 'up', 'down' 'right', left' or angle in degrees} (defaults to 'horizontal').\n            - fontsize (int, optional): Text font size (defaults to `self.fontsize`).\n\n        - **kind = 'angled_arrow'**:\n            - text (str, optional): Text on the arrow or line (defaults to `name`).\n            - final_pos (Numpy.NDarray or list): Coordinates of the ending point of the arrow.\n            - text_position (str, optional): 'above', 'below', 'before', or 'after' (defaults to 'above' for 'arrow' and 'line', 'before' for 'input', and 'after' for 'output').\n            - text_offset (float, optional): Offset for text (defaults to 0.1).\n            - arrow (bool, optional): Indicates if it must finish or not in an arrow.\n            - first_segment (string, optional): Drawing order: {'horizontal', 'vertical'}\n            - orientation (str or float, optional): Orientation of the block: {'horizontal', 'vertical', 'up', 'down' 'right', left' or angle in degrees} (defaults to 'horizontal').\n            - fontsize (int, optional): Text font size (defaults to `self.fontsize`).\n\n        - **kind = 'combiner'**:\n            - operation (string, optional): Operation of the combiner: {'mult', 'sum', 'dif'} (defaultds to 'mult').\n            - height (float, optional): Vertical height of the block. (defaults to `self.block_height`).\n            - input_side (string, optional): Side of the lateral input: {'bottom', 'top'} (defaults to 'bottom').\n            - input_text (string, optional): Label for the input arrow (below or above the arrow).\n            - text_offset (float, optional): Offset for text (defaults to 0.1).\n            - signs (list, optional): Sign to be shown on the horizontal (signs[0]) and vertical (signs[1]) inputs.\n            - orientation (str or float, optional): Orientation of the block: {'horizontal', 'vertical', 'up', 'down' 'right', left' or angle in degrees} (defaults to 'horizontal').\n            - fontsize (int, optional): Text font size (defaults to `self.fontsize`).\n\n        - **kind = 'mult_combiner'**:\n            - operation (string, optional): Operation of the combiner: {'mult', 'sum', 'dif'} (defaults to 'mult').\n            - length (float, optional): Total element length (defaults to `self.block_length`).\n            - inputs (list of str): Thread names to combine.\n            - operation (string, optional): Operation of the combiner: {'mult', 'sum'} (defaults to 'sum').\n            - orientation (str or float, optional): Orientation of the block: {'horizontal', 'vertical', 'up', 'down' 'right', left' or angle in degrees} (defaults to 'horizontal').\n            - fontsize (int, optional): Text font size (defaults to `self.fontsize`).\n\n        Examples:\n            &gt;&gt;&gt; db = DiagramBuilder()\n            &gt;&gt;&gt; db.add(\"x(t)\", kind=\"input\")\n            &gt;&gt;&gt; db.add(\"H(s)\", kind=\"block\")\n            &gt;&gt;&gt; db.add(\"y(t)\", kind=\"output\")\n        \"\"\"\n\n        # If position is 'auto' (draw_mult_combiner), position is calculated inside that method\n        if isinstance(position, str) and position == 'auto':\n            initial_pos = 'auto'\n        # If input argument position is given and not 'auto', element position is asigned to position argument value\n        elif position is not None:\n            initial_pos = list(position)\n        # If not given\n        else:\n            # If thread already exists, element position is asigned from thread head\n            if thread in self.thread_positions:\n                initial_pos = self.thread_positions[thread]\n            # If doesn't exist\n            else:\n                initial_pos = [0, 0]\n\n        if kind == 'arrow':\n            # Default arguments\n            default_kwargs = {\n                'text': name,\n                'text_position': 'above',\n                'arrow': True,\n                'text_offset': 0.1,\n                'length': self.block_length,\n                'fontsize': self.fontsize,\n                'orientation': 'horizontal'\n            }\n            # Overrides default arguments with provided ones\n            block_args = {**default_kwargs, **kwargs}\n            # Function call\n            final_pos = self.__draw_arrow__(initial_pos, **block_args)\n\n        elif kind == 'angled_arrow':\n            # Default arguments\n            default_kwargs = {\n                'text': name,\n                'text_offset': 0.1,\n                'fontsize': self.fontsize,\n                'orientation': 'horizontal',\n            }\n            # Overrides default arguments with provided ones\n            block_args = {**default_kwargs, **kwargs}\n            # Function call\n            final_pos = self.__draw_angled_arrow__(initial_pos, **block_args)\n\n        elif kind == 'input':\n            # Default arguments\n            default_kwargs = {\n                'text': name,\n                'text_position': 'before',\n                'arrow': True,\n                'text_offset': 0.1,\n                'length': self.block_length,\n                'fontsize': self.fontsize,\n                'orientation': 'horizontal'\n            }\n            # Overrides default arguments with provided ones\n            block_args = {**default_kwargs, **kwargs}\n            # Function call\n            final_pos = self.__draw_arrow__(initial_pos, **block_args)\n\n        elif kind == 'output':\n            # Default arguments\n            default_kwargs = {\n                'text': name,\n                'text_position': 'after',\n                'arrow': True,\n                'text_offset': 0.1,\n                'length': self.block_length,\n                'fontsize': self.fontsize,\n                'orientation': 'horizontal'\n            }\n            # Overrides default arguments with provided ones\n            block_args = {**default_kwargs, **kwargs}\n            # Function call\n            final_pos = self.__draw_arrow__(initial_pos, **block_args)\n\n        elif kind == 'line':\n            # Default arguments\n            default_kwargs = {\n                'text': name,\n                'text_position': 'above',\n                'arrow': False,\n                'text_offset': 0.1,\n                'length': self.block_length,\n                'fontsize': self.fontsize,\n                'orientation': 'horizontal'\n            }\n            # Overrides default arguments with provided ones\n            block_args = {**default_kwargs, **kwargs}\n            # Function call\n            final_pos = self.__draw_arrow__(initial_pos, **block_args)\n\n        elif kind == 'block':\n            # Default arguments\n            default_kwargs = {\n                'text': name,\n                'text_above': None,\n                'text_below': None,\n                'text_offset': 0.1,\n                'input_text': None,\n                'input_side': None,\n                'length': self.block_length,\n                'height': self.block_height,\n                'fontsize': self.fontsize,\n                'linestyle': '-',\n                'orientation': 'horizontal'\n            }\n            # Overrides default arguments with provided ones\n            block_args = {**default_kwargs, **kwargs}\n            # Function call\n            final_pos = self.__draw_block__(initial_pos, **block_args)\n\n        elif kind == 'combiner':\n            # Default arguments\n            default_kwargs = {\n                'height': self.block_height,\n                'fontsize': self.fontsize,\n                'operation': 'mult',\n                'input_side': 'bottom',\n                'orientation': 'horizontal'\n            }\n            # Overrides default arguments with provided ones\n            block_args = {**default_kwargs, **kwargs}\n            # Function call\n            final_pos = self.__draw_combiner__(initial_pos, **block_args)\n\n        elif kind == 'mult_combiner':\n            # Default arguments\n            default_kwargs = {\n                'length': self.block_length,\n                'operation': 'mult',\n                'orientation': 'horizontal'\n            }\n            # Overrides default arguments with provided ones\n            block_args = {**default_kwargs, **kwargs}\n            # Function call\n            final_pos = self.__draw_mult_combiner__(initial_pos, **block_args)\n\n\n        elif kind == 'output':\n            length=kwargs.get('length', self.block_length)\n            final_pos = self.__draw_io_arrow__(initial_pos, length=length, text=kwargs.get('text', name),\n                          io='output', fontsize=self.fontsize)\n\n        else:\n            raise ValueError(f\"Unknown block type: {kind}\")\n\n        # Update head position of thread\n        self.thread_positions[thread] = final_pos\n\n        if debug:\n            self.__print_threads__()\n\n    def get_current_element(self):\n        \"\"\"\n        Returns the current element index (last added).\n\n        Returns:\n            (int): Index of the last added element.\n        \"\"\"\n        return self.current_element\n\n    def get_position(self, element=None):\n        \"\"\"\n        Returns the positions of the specified element index. If no element specified, last added element is used.\n        The return is a dictinoary with coordinates of `input_pos`, `output_pos` and `feedback_pos` (feedback port coordinates).\n\n        Args:\n            element (int, optional): index of the element.\n\n        Returns:\n            (dict of Tuples): Dictionary with three 2-element tuples: `input_pos`, `output_pos` and `feedback_pos`.\n        \"\"\"\n        if element is None:\n            return self.element_positions[self.current_element]\n        elif element &lt;= self.current_element:\n            return self.element_positions[element]\n        else:\n            raise ValueError(f\"Element '{element}' not found.\")\n\n    def get_thread_position(self, thread='main'):\n        \"\"\"\n        Returns the current output position of the specified thread.\n\n        Args:\n            thread (str, optional): Thread identifier.\n        \"\"\"\n        if thread in self.thread_positions:\n            return self.thread_positions[thread]\n        else:\n            raise ValueError(f\"Thread '{thread}' not found.\")\n\n\n    def show(self, margin=0.5, scale=1.0, savepath=None):\n        \"\"\"\n        Displays the current diagram or saves it to a file.\n\n        Adjusts the view to fit the full diagram with an optional margin and scaling factor.\n        If no elements have been drawn, simply displays an empty figure.\n\n        Args:\n            margin (float, optional): Margin to add around the diagram (in data units).\n            scale (float, optional): Scaling factor for the figure size.\n            savepath (str, optional): If provided, saves the figure to the specified path (e.g., 'diagram.png' or 'diagram.pdf').\n                                      If None, the diagram is shown in an interactive window.\n\n        \"\"\"\n        bbox = self.__get_bbox__()\n        if bbox is None:\n            plt.show()\n            return\n\n        x0 = bbox.x0 - margin\n        x1 = bbox.x1 + margin\n        y0 = bbox.y0 - margin\n        y1 = bbox.y1 + margin\n\n        width = x1 - x0\n        height = y1 - y0\n\n        fig_width = width * scale\n        fig_height = height * scale\n        self.fig.set_size_inches(fig_width, fig_height)\n\n        self.ax.set_xlim(x0, x1)\n        self.ax.set_ylim(y0, y1)\n        self.ax.set_aspect(\"equal\", adjustable=\"box\")\n        self.ax.set_position([0, 0, 1, 1])\n        self.ax.axis(\"off\")\n\n        if savepath:\n            self.fig.savefig(savepath, bbox_inches='tight', dpi=self.fig.dpi, transparent=False, facecolor='white')\n            print(f\"Saved in: {savepath}\")\n        else:\n            plt.show()\n</code></pre>"},{"location":"reference/#signalblocks.DiagramBuilder.DiagramBuilder.__add_element_position__","title":"<code>__add_element_position__(input_pos, output_pos, feedback_pos)</code>","text":"<p>Inner method. Adds a new element with the given input, output and feedback positions.</p> <p>Parameters:</p> Name Type Description Default <code>input_pos</code> <code>NDArray or list</code> <p>Input position of the block.</p> required <code>output_pos</code> <code>NDArray or list</code> <p>Output position of the block.</p> required <code>feedback_pos</code> <code>NDArray or list</code> <p>Feedback port position of the block.</p> required Source code in <code>signalblocks\\DiagramBuilder.py</code> <pre><code>def __add_element_position__(self, input_pos: Tuple[float, float], \n                             output_pos: Tuple[float, float], \n                             feedback_pos: Tuple[float, float]):\n    \"\"\"\n    Inner method.\n    Adds a new element with the given input, output and feedback positions.\n\n    Args:\n        input_pos (Numpy.NDArray or list): Input position of the block.\n        output_pos (Numpy.NDArray or list): Output position of the block.\n        feedback_pos (Numpy.NDArray or list): Feedback port position of the block.\n    \"\"\"\n    self.current_element += 1\n\n    self.element_positions[self.current_element] = ElementPosition(\n        input_pos=input_pos,\n        output_pos=output_pos,\n        feedback_pos=feedback_pos\n    )\n</code></pre>"},{"location":"reference/#signalblocks.DiagramBuilder.DiagramBuilder.__draw_angled_arrow__","title":"<code>__draw_angled_arrow__(initial_position, final_position, text=None, text_offset=0.2, arrow=True, fontsize=14, first_segment='horizontal', orientation='horizontal')</code>","text":"<p>Inner method. Draws a right-angled arrow composed of two segments, with a specified first segment orientation and optional label.</p> <p>Parameters:</p> Name Type Description Default <code>initial_position</code> <code>NDarray or list</code> <p>Coordinates of the starting point of the arrow.</p> required <code>final_position</code> <code>NDarray or list</code> <p>Coordinates of the ending point of the arrow.</p> required <code>text</code> <code>string</code> <p>Label to display in the block.</p> <code>None</code> <code>text_offset</code> <code>float</code> <p>Vertical offset for the text position.</p> <code>0.2</code> <code>arrow</code> <code>bool</code> <p>Indicates if it must finish or not in an arrow.</p> <code>True</code> <code>fontsize</code> <code>int</code> <p>font size of the text inside the block. If not entered, default <code>fontsize</code> is used.</p> <code>14</code> <code>first_segment</code> <code>string</code> <p>Drawing order: {'horizontal', 'vertical'}</p> <code>'horizontal'</code> <code>orientation</code> <code>string or float</code> <p>Direction of the block: {'horizontal', 'vertical', 'up', 'down', 'left', 'right', angle}.</p> <code>'horizontal'</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>Coordinates of output point of the arrow.</p> Source code in <code>signalblocks\\DiagramBuilder.py</code> <pre><code>def __draw_angled_arrow__(self, initial_position, final_position, \n                        text=None, text_offset=0.2, arrow = True, fontsize=14,\n                        first_segment='horizontal', orientation='horizontal'):\n    \"\"\"\n    Inner method.\n    Draws a right-angled arrow composed of two segments, with a specified first segment orientation and optional label.\n\n    Args:\n        initial_position (Numpy.NDarray or list): Coordinates of the starting point of the arrow.\n        final_position (Numpy.NDarray or list): Coordinates of the ending point of the arrow.\n        text (string, optional): Label to display in the block.\n        text_offset (float, optional): Vertical offset for the text position.\n        arrow (bool, optional): Indicates if it must finish or not in an arrow.\n        fontsize (int, optional): font size of the text inside the block. If not entered, default `fontsize` is used.\n        first_segment (string, optional): Drawing order: {'horizontal', 'vertical'}\n        orientation (string or float, optional): Direction of the block: {'horizontal', 'vertical', 'up', 'down', 'left', 'right', angle}.\n\n    Returns:\n        (Numpy.NDArray): Coordinates of output point of the arrow.\n    \"\"\"\n    head_width = 0.15 if arrow else 0\n\n    angle = 0\n    # Determine rotation angle based on orientation\n    if orientation in ['horizontal', 'right']:\n        angle = 0\n    elif orientation == 'left':\n        angle = 180\n    elif orientation in ['vertical', 'down']:\n        angle = -90\n    elif orientation == 'up':\n        angle = 90\n    elif isinstance(orientation, (int, float)):\n        angle = orientation\n    else:\n        angle = 0\n\n    x_in, y_in = initial_position\n    x_out, y_out = final_position\n    dx = x_out - x_in\n    dy = y_out - y_in\n\n    # Apply rotation around the connection point (x_ini, y_ini)\n    trans = transforms.Affine2D().rotate_deg_around(x_in, y_in, angle) + self.ax.transData   \n\n    if first_segment == 'horizontal':\n        corner = (x_out, y_in)\n    elif first_segment == 'vertical':\n        corner = (x_in, y_out)\n    else:\n        raise ValueError(\"first_segment must be either 'horizontal' or 'vertical'\")\n\n    # Draw segments\n    if first_segment == 'horizontal':\n        if dx != 0:\n            self.ax.add_patch(FancyArrow(x_in, y_in, dx, 0, width=0.01,\n                    length_includes_head=True, head_width=0, \n                    color='black', transform=trans))\n        if dy != 0:\n            self.ax.add_patch(FancyArrow(corner[0], corner[1], 0, dy, width=0.01,\n                    length_includes_head=True, head_width=head_width, \n                    color='black', transform=trans))\n    else:  # first vertical\n        if dy != 0:\n            self.ax.add_patch(FancyArrow(x_in, y_in, 0, dy, width=0.01,\n                    length_includes_head=True, head_width=0, \n                    color='black', transform=trans))\n        if dx != 0:\n            self.ax.add_patch(FancyArrow(corner[0], corner[1], dx, 0, width=0.01,\n                    length_includes_head=True, head_width=head_width, \n                    color='black', transform=trans))\n\n    # Don't rotate text if orientation is vertical, down or up\n    rotate_text = False if orientation in ['vertical', 'down', 'up', 'left'] else True\n\n    # Optional text near the corner\n    if text:\n        # Calculate offset vector based on orientation in non-rotated coordinates\n        if first_segment == 'horizontal':\n            offset_vector = np.array([dx/2, text_offset])    \n        else: # first vertical\n            offset_vector = np.array([dx/2, dy + text_offset])    \n\n        self.__draw_rotated_text__(initial_position, text, \n                                   angle=angle, rotate_text=rotate_text,\n                                   ha='center', va='bottom', offset=offset_vector,\n                                   fontsize=fontsize)\n\n    # Compute rotated output point\n    output_pos = self.__get_rotated_pos__(final_position, [0, 0], angle)\n    # Compute feedback point\n    feedback_pos = self.__get_rotated_pos__(corner, [0, 0], angle)\n    # Save element position\n    self.__add_element_position__(input_pos=initial_position, output_pos=output_pos, feedback_pos=feedback_pos)\n\n    return output_pos\n</code></pre>"},{"location":"reference/#signalblocks.DiagramBuilder.DiagramBuilder.__draw_arrow__","title":"<code>__draw_arrow__(initial_position, length, text=None, text_position='above', text_offset=0.2, arrow=True, fontsize=14, orientation='horizontal')</code>","text":"<p>Inner method. Draws a horizontal arrow with optional label.</p> <p>Parameters:</p> Name Type Description Default <code>initial_position</code> <code>NDarray or list</code> <p>Coordinates of the starting point of the arrow.</p> required <code>length</code> <code>float</code> <p>Horizontal length of the block. If not entered, default <code>block_length</code> is used.</p> required <code>text</code> <code>string</code> <p>Label to display in the block.</p> <code>None</code> <code>text_position</code> <code>string</code> <p>Position of the optional text: {'before', 'after', 'above'}</p> <code>'above'</code> <code>text_offset</code> <code>float</code> <p>Vertical offset for the text position.</p> <code>0.2</code> <code>arrow</code> <code>bool</code> <p>Indicated if an line mush finish or not in an arrow.</p> <code>True</code> <code>fontsize</code> <code>int</code> <p>font size of the text inside the block. If not entered, default <code>fontsize</code> is used.</p> <code>14</code> <code>orientation</code> <code>string or float</code> <p>Direction of the block: {'horizontal', 'vertical', 'up', 'down', 'left', 'right', angle}.</p> <code>'horizontal'</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>Coordinates of output point of the arrow.</p> Source code in <code>signalblocks\\DiagramBuilder.py</code> <pre><code>def __draw_arrow__(self, initial_position, length, text=None, \n                   text_position = 'above', text_offset=0.2, arrow = True,\n                   fontsize=14, orientation='horizontal'):\n    \"\"\"\n    Inner method.\n    Draws a horizontal arrow with optional label.\n\n    Args:\n        initial_position (Numpy.NDarray or list): Coordinates of the starting point of the arrow.\n        length (float, optional): Horizontal length of the block. If not entered, default `block_length` is used.\n        text (string, optional): Label to display in the block.\n        text_position (string, optional): Position of the optional text: {'before', 'after', 'above'}\n        text_offset (float, optional): Vertical offset for the text position.\n        arrow (bool, optional): Indicated if an line mush finish or not in an arrow.\n        fontsize (int, optional): font size of the text inside the block. If not entered, default `fontsize` is used.\n        orientation (string or float, optional): Direction of the block: {'horizontal', 'vertical', 'up', 'down', 'left', 'right', angle}.\n\n    Returns:\n        (Numpy.NDArray): Coordinates of output point of the arrow.\n    \"\"\"\n    # end = (initial_position[0] + length, initial_position[1])\n    head_width = 0.15 if arrow else 0\n\n    angle = 0\n    # Determine rotation angle based on orientation\n    if orientation in ['horizontal', 'right']:\n        angle = 0\n    elif orientation == 'left':\n        angle = 180\n    elif orientation in ['vertical', 'down']:\n        angle = -90\n    elif orientation == 'up':\n        angle = 90\n    elif isinstance(orientation, (int, float)):\n        angle = orientation\n    else:\n        angle = 0\n\n    x_in, y_in = initial_position\n\n    # Apply rotation around the connection point (x_ini, y_ini)\n    trans = transforms.Affine2D().rotate_deg_around(x_in, y_in, angle) + self.ax.transData   \n\n\n    self.ax.add_patch(FancyArrow(x_in, y_in, length, 0, width=0.01,\n                            length_includes_head=True, head_width=head_width, \n                            color='black', transform=trans))\n\n    # Don't rotate text if orientation is vertical, down or up\n    rotate_text = False if orientation in ['vertical', 'down', 'up', 'left'] else True\n\n    if text:\n        # Calculate offset vector based on orientation in non-rotated coordinates\n        if text_position == 'before':\n            ha, va = 'right', 'center'\n            offset_vector = np.array([-text_offset, 0])\n            if orientation in ['vertical', 'down']:\n                ha = 'center'\n                va = 'bottom'\n            elif orientation in ['up']:\n                ha = 'center'\n                va = 'top'\n        elif text_position == 'after':\n            ha, va = 'left', 'center'\n            offset_vector = np.array([length + text_offset, 0])\n            if orientation in ['vertical', 'down']:\n                ha = 'center'\n                va = 'top'\n            elif orientation in ['up']:\n                ha = 'center'\n                va = 'bottom'\n        elif text_position == 'above':\n            ha, va = 'center', 'bottom'\n            offset_vector = np.array([length / 2, text_offset])\n            if orientation in ['vertical', 'down',]:\n                ha = 'left'\n                va = 'bottom'\n            elif orientation in ['up']:\n                ha = 'right'\n                va = 'top'\n        else:\n            raise ValueError(f\"Unknown text_position: {text_position}\")\n\n        self.__draw_rotated_text__(initial_position, text, \n                                   angle=angle, rotate_text=rotate_text,\n                                   ha=ha, va=va, offset=offset_vector,\n                                   fontsize=fontsize)\n\n    # Compute rotated output point\n    output_pos = self.__get_rotated_pos__(initial_position, [length, 0], angle)\n    # Compute feedback point\n    feedback_pos = self.__get_rotated_pos__(initial_position, [length/2, 0], angle)\n    # Add element position to the dictionary\n    self.__add_element_position__(input_pos=[x_in,y_in], output_pos=output_pos,\n                                  feedback_pos=feedback_pos)\n    return output_pos\n</code></pre>"},{"location":"reference/#signalblocks.DiagramBuilder.DiagramBuilder.__draw_block__","title":"<code>__draw_block__(initial_position, text=None, text_below=None, text_above=None, text_offset=0.1, input_text=None, input_side=None, length=1.5, height=1, fontsize=14, linestyle='-', orientation='horizontal')</code>","text":"<p>Inner method. Draws a rectangular block with centered text, optional texts below and/or above and optional input arrow with text.</p> <p>Parameters:</p> Name Type Description Default <code>initial_position</code> <code>NDarray or list</code> <p>Coordinates of the center position of the input edge of the block.</p> required <code>text</code> <code>string</code> <p>Label to display in the block.</p> <code>None</code> <code>text_below</code> <code>string</code> <p>Label to display below the block.</p> <code>None</code> <code>text_above</code> <code>string</code> <p>Label to display above the block.</p> <code>None</code> <code>text_offset</code> <code>float</code> <p>Vertical offset for the text position.</p> <code>0.1</code> <code>input_text</code> <code>string</code> <p>Label for the optional input arrow (below or above the block).</p> <code>None</code> <code>input_side</code> <code>string</code> <p>Side to place the input arrow: {'bottom', 'top', None}</p> <code>None</code> <code>length</code> <code>float</code> <p>Horizontal length of the block. If not entered, default <code>block_length</code> is used.</p> <code>1.5</code> <code>height</code> <code>float</code> <p>Vertical height of the block. If not entered, default <code>block_height</code> is used.</p> <code>1</code> <code>fontsize</code> <code>int</code> <p>font size of the text inside the block. If not entered, default <code>fontsize</code> is used.</p> <code>14</code> <code>linestyle</code> <code>string</code> <p>linestyle of the block edge: {'-, '--, ':', '-.'}.</p> <code>'-'</code> <code>orientation</code> <code>string or float</code> <p>Direction of the block: {'horizontal', 'vertical', 'up', 'down', 'left', 'right', angle}.</p> <code>'horizontal'</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>Coordinates of the center position of the output edge of the block.</p> Source code in <code>signalblocks\\DiagramBuilder.py</code> <pre><code>def __draw_block__(self, initial_position, text=None, text_below=None, \n                   text_above=None, text_offset=0.1, input_text=None, \n                   input_side=None, length=1.5, height=1, fontsize=14, \n                   linestyle='-', orientation='horizontal'):\n    \"\"\"\n    Inner method.\n    Draws a rectangular block with centered text, optional texts below and/or above and optional input arrow with text.\n\n    Args:\n        initial_position (Numpy.NDarray or list): Coordinates of the center position of the input edge of the block.\n        text (string, optional): Label to display in the block.\n        text_below (string, optional): Label to display below the block.\n        text_above (string, optional): Label to display above the block.\n        text_offset (float, optional): Vertical offset for the text position.\n        input_text (string, optional): Label for the optional input arrow (below or above the block).\n        input_side (string, optional): Side to place the input arrow: {'bottom', 'top', None}\n        length (float, optional): Horizontal length of the block. If not entered, default `block_length` is used.\n        height (float, optional): Vertical height of the block. If not entered, default `block_height` is used.\n        fontsize (int, optional): font size of the text inside the block. If not entered, default `fontsize` is used.\n        linestyle (string, optional): linestyle of the block edge: {'-, '--, ':', '-.'}.\n        orientation (string or float, optional): Direction of the block: {'horizontal', 'vertical', 'up', 'down', 'left', 'right', angle}.\n\n    Returns:\n        (Numpy.NDArray): Coordinates of the center position of the output edge of the block.\n    \"\"\"\n    # Parameters validation\n    if input_side not in (None, 'top', 'bottom'):\n        raise ValueError(f\"Invalid input_side: {input_side}. Use 'top' or 'bottom'.\")\n    if orientation not in (None, 'horizontal', 'vertical', 'up', 'down', 'left', 'right'):\n        if isinstance(orientation, (int, float)):\n            pass\n        else:\n            raise ValueError(f\"Invalid orientation: {orientation}. Use 'horizontal', 'vertical', 'up', 'down', 'left', or 'right'.\")\n    if linestyle not in (None, '-', '--', ':', '-.', 'solid', 'dashed', 'dotted', 'dashdot'):\n        raise ValueError(f\"Invalid linestyle: {linestyle}. Use '-', '--', ':', '-.', 'solid', 'dashed', 'dotted', or 'dashdot'.\")\n    if not isinstance(length, (int, float)) or length &lt;= 0:\n        raise ValueError(f\"Invalid length: {length}. Length must be a positive number.\")\n    if not isinstance(height, (int, float)) or height &lt;= 0:\n        raise ValueError(f\"Invalid height: {height}. Height must be a positive number.\")\n    if not isinstance(text_offset, (int, float)):\n        raise ValueError(f\"Invalid text_offset: {text_offset}. Text offset must be a number.\")\n    if not isinstance(fontsize, (int, float)):\n        raise ValueError(f\"Invalid fontsize: {fontsize}. Font size must be a number.\")\n\n\n    # Determine rotation angle based on orientation\n    if orientation in ['horizontal', 'right']:\n        angle = 0\n    elif orientation == 'left':\n        angle = 180\n    elif orientation in ['vertical', 'down']:\n        angle = -90\n    elif orientation == 'up':\n        angle = 90\n    elif isinstance(orientation, (int, float)):\n        angle = orientation\n    else:\n        angle = 0\n\n    x_in, y_in = initial_position\n\n    # Bottom-left corner of the block (before rotation)\n    x0 = x_in\n    y0 = y_in - height / 2\n\n    # Center of the block (before rotation)\n    cx = x_in + length / 2\n    cy = y_in\n\n    # Apply the rotation around the connection point (x_ini, y_ini)\n    trans = transforms.Affine2D().rotate_deg_around(x_in, y_in, angle) + self.ax.transData   \n\n    self.ax.add_patch(Rectangle((x0, y0), length, height, \n                                edgecolor='black', facecolor='none', \n                                linestyle=linestyle, transform=trans))\n    # Don't rotate text if orientation is vertical, down or up\n    rotate_text = False if orientation in ['vertical', 'down', 'up', 'left'] else True\n\n    # Draw text inside the block\n    if text is not None:\n        offset_vector = np.array([length / 2, 0])\n        self.__draw_rotated_text__(initial_position, text, \n                                   angle=angle, rotate_text=rotate_text,\n                                   ha='center', va='center', \n                                   fontsize=fontsize, offset=offset_vector)\n\n    # Draw text above the block\n    if text_above is not None:\n        if orientation in ['vertical', 'down']:\n            ha = 'left'\n            va = 'center'\n        elif orientation in ['up']:\n            ha = 'right'\n            va = 'center'\n        else:\n            ha = 'center'\n            va = 'bottom'\n        offset_vector = np.array([length / 2, height / 2 + text_offset])\n        self.__draw_rotated_text__(initial_position, text_above, \n                                   angle=angle, rotate_text=rotate_text,\n                                   ha=ha, va=va, \n                                   fontsize=fontsize, offset=offset_vector)\n\n    # Draw text below the block\n    if text_below is not None:\n        if orientation in ['vertical', 'down']:\n            ha = 'right'\n            va = 'center'\n        elif orientation in ['up']:\n            ha = 'left'\n            va = 'center'\n        else:\n            ha = 'center'\n            va = 'top'\n        offset_vector = np.array([length / 2, - height / 2 - text_offset])\n        self.__draw_rotated_text__(initial_position, text_below, \n                                   angle=angle, rotate_text=rotate_text,\n                                   ha=ha, va=va, \n                                   fontsize=fontsize, offset=offset_vector)\n\n    if input_side is not None:\n        if input_side == 'bottom':\n            arrow_height = 0.75 * height\n            y_init = y0 - arrow_height\n            offset_vector = np.array([length / 2, - height /2 - arrow_height - text_offset])\n            va = 'top'\n            ha = 'center'\n            if orientation in ['vertical', 'down']:\n                ha = 'right'\n                va = 'center'\n            elif orientation in ['up']:\n                ha = 'left'\n                va = 'center'\n            elif orientation in ['left']:\n                ha = 'center'\n                va = 'bottom'\n        elif input_side == 'top':\n            arrow_height = - 0.75 * height\n            y_init = y0 + height - arrow_height\n            offset_vector = np.array([length / 2, height /2 - arrow_height + text_offset])\n            va = 'bottom'\n            ha = 'center'\n            if orientation in ['vertical', 'down']:\n                ha = 'left'\n                va = 'center'\n            elif orientation in ['up']:\n                ha = 'right'\n                va = 'center'\n            elif orientation in ['left']:\n                ha = 'center'\n                va = 'top'\n        else:\n            raise ValueError(f\"Unknown input side: {input_side}. Use 'bottom' or 'top'.\")   \n\n        self.ax.add_patch(FancyArrow(cx, y_init, 0, arrow_height, width=0.01,\n                                length_includes_head=True, head_width=0.15, \n                                color='black', transform=trans))\n        if input_text is not None:\n\n            self.__draw_rotated_text__(initial_position, input_text, \n                                       angle=angle, rotate_text=rotate_text,\n                                       ha=ha, va=va, \n                                       fontsize=fontsize, offset=offset_vector)\n\n    # Compute rotated output point\n    output_pos = self.__get_rotated_pos__(initial_position, [length, 0], angle)\n    # Compute feedback point\n    feedback_pos = self.__get_rotated_pos__(initial_position, [length/2, -height/2], angle)\n    # Add element position to the dictionary\n    self.__add_element_position__(input_pos=[x_in,y_in], output_pos=output_pos,\n                                  feedback_pos=feedback_pos)\n    return output_pos\n</code></pre>"},{"location":"reference/#signalblocks.DiagramBuilder.DiagramBuilder.__draw_combiner__","title":"<code>__draw_combiner__(initial_position, height=1, input_text=None, input_side='bottom', operation='mult', text_offset=0.1, signs=[None, None], fontsize=14, orientation='horizontal')</code>","text":"<p>Inner method. Draws a combiner block: a circle with a multiplication sign (\u00d7), sum sign (+)  or substraction sign (-) inside, with optional signs on each input.</p> <p>Parameters:</p> Name Type Description Default <code>initial_position</code> <code>NDarray or list</code> <p>Coordinates of the starting point of the arrow.</p> required <code>height</code> <code>float</code> <p>Vertical height of the block. If not entered, default <code>block_height</code> is used.</p> <code>1</code> <code>input_text</code> <code>string</code> <p>Label for the input arrow (below or above the arrow).</p> <code>None</code> <code>input_side</code> <code>string</code> <p>Side of the lateral input: {'bottom', 'top'}.</p> <code>'bottom'</code> <code>operation</code> <code>string</code> <p>Operation of the combiner: {'mult', 'sum', 'dif'}.</p> <code>'mult'</code> <code>text_offset</code> <code>float</code> <p>Vertical offset for the text position.</p> <code>0.1</code> <code>signs</code> <code>list</code> <p>Sign to be shown on the horizontal (signs[0]) and vertical (signs[1]) inputs.</p> <code>[None, None]</code> <code>fontsize</code> <code>int</code> <p>font size of the text inside the block. If not entered, default <code>fontsize</code> is used.</p> <code>14</code> <code>orientation</code> <code>string or float</code> <p>Direction of the block: {'horizontal', 'vertical', 'up', 'down', 'left', 'right', angle}.</p> <code>'horizontal'</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>Coordinates of output point of the combiner.</p> Source code in <code>signalblocks\\DiagramBuilder.py</code> <pre><code>def __draw_combiner__(self, initial_position, height=1,\n                    input_text=None, input_side='bottom', operation='mult', \n                    text_offset=0.1, signs=[None, None], fontsize=14, orientation='horizontal'):\n    \"\"\"\n    Inner method.\n    Draws a combiner block: a circle with a multiplication sign (\u00d7), sum sign (+) \n    or substraction sign (-) inside, with optional signs on each input.\n\n    Args:\n        initial_position (Numpy.NDarray or list): Coordinates of the starting point of the arrow.\n        height (float, optional): Vertical height of the block. If not entered, default `block_height` is used.\n        input_text (string, optional): Label for the input arrow (below or above the arrow).\n        input_side (string, optional): Side of the lateral input: {'bottom', 'top'}.\n        operation (string, optional): Operation of the combiner: {'mult', 'sum', 'dif'}.\n        text_offset (float, optional): Vertical offset for the text position.\n        signs (list, optional): Sign to be shown on the horizontal (signs[0]) and vertical (signs[1]) inputs.\n        fontsize (int, optional): font size of the text inside the block. If not entered, default `fontsize` is used.\n        orientation (string or float, optional): Direction of the block: {'horizontal', 'vertical', 'up', 'down', 'left', 'right', angle}.\n\n    Returns:\n        (Numpy.NDArray): Coordinates of output point of the combiner.\n    \"\"\"\n    angle = 0\n    # Determine rotation angle based on orientation\n    if orientation in ['horizontal', 'right']:\n        angle = 0\n    elif orientation == 'left':\n        angle = 180\n    elif orientation in ['vertical', 'down']:\n        angle = -90\n    elif orientation == 'up':\n        angle = 90\n    elif isinstance(orientation, (int, float)):\n        angle = orientation\n    else:\n        angle = 0\n\n    x_in, y_in = initial_position\n\n    radius = height / 4\n    # Center of the block (before rotation)\n    cx = x_in + radius\n    cy = y_in\n\n    # Apply rotation around the connection point (x_ini, y_ini)\n    trans = transforms.Affine2D().rotate_deg_around(x_in, y_in, angle) + self.ax.transData  \n\n    circle = plt.Circle((cx, cy), radius, edgecolor='black', \n                        facecolor='white', transform=trans, zorder=2)\n    self.ax.add_patch(circle)\n\n    rel_size = 0.7\n    if operation == 'mult':\n        # L\u00edneas diagonales (forma de \"X\") dentro del c\u00edrculo\n        dx = radius * rel_size * np.cos(np.pi / 4)  # Escalamos un poco para que quepa dentro del c\u00edrculo\n        dy = radius * rel_size * np.sin(np.pi / 4)\n        # L\u00ednea de 45\u00b0\n        self.ax.plot([cx - dx, cx + dx], [cy - dy, cy + dy], color='black', \n                     linewidth=2, transform=trans, zorder=3)\n        # L\u00ednea de 135\u00b0\n        self.ax.plot([cx - dx, cx + dx], [cy + dy, cy - dy], color='black', \n                     linewidth=2, transform=trans, zorder=3)\n\n    elif operation == 'sum':\n        dx = radius * rel_size\n        dy = radius * rel_size\n        # L\u00edneas horizontales y verticales (forma de \"+\") dentro del c\u00edrculo\n        self.ax.plot([cx - dx, cx + dx], [cy, cy], color='black', \n                     linewidth=2, transform=trans, zorder=3)\n        self.ax.plot([cx, cx], [cy - dy, cy + dy], color='black', \n                     linewidth=2, transform=trans, zorder=3)\n    elif operation == 'dif':\n        dx = radius * rel_size\n        # L\u00ednea horizontal (forma de \"-\") dentro del c\u00edrculo\n        self.ax.plot([cx - dx, cx + dx], [cy, cy], color='black', \n                     linewidth=2, transform=trans, zorder=3)\n    else:\n        raise ValueError(f\"Unknown operation: {operation}. 'operation' must be 'mult', 'sum' or 'dif'.\")\n\n    # Don't rotate text if orientation is vertical, down or up\n    rotate_text = False if orientation in ['vertical', 'down', 'up', 'left'] else True\n\n    # Side input\n    if input_side == 'bottom':\n        arrow_height = height - radius\n        y_init = y_in - radius - arrow_height\n        offset_vector = np.array([radius, - (height + text_offset)])\n        va = 'top'\n        ha = 'center'\n        if orientation in ['vertical', 'down']:\n            ha = 'right'\n            va = 'center'\n        elif orientation in ['up']:\n            ha = 'left'\n            va = 'center'\n    elif input_side == 'top':\n        arrow_height = - (height - radius)\n        y_init = y_in + radius - arrow_height\n        offset_vector = np.array([radius, height + text_offset])\n        va = 'bottom'\n        ha = 'center'\n        if orientation in ['vertical', 'down']:\n            ha = 'left'\n            va = 'center'\n        elif orientation in ['up']:\n            ha = 'right'\n            va = 'center'\n    else:\n        raise ValueError(f\"Unknown input_side: {input_side}. 'input_side' must be 'bottom' or 'top'.\")\n\n    # Show signs on each input if not None\n    if signs[0] is not None:\n        self.__draw_rotated_text__(initial_position, signs[0], \n                                angle=angle, rotate_text=rotate_text,\n                                ha=ha, va=va, \n                                fontsize=fontsize, offset=[-radius, 1.5*radius])\n    if signs[1] is not None:\n        self.__draw_rotated_text__(initial_position, signs[1], \n                                angle=angle, rotate_text=rotate_text,\n                                ha=ha, va=va, \n                                fontsize=fontsize, offset=[0, -1.5*radius])\n\n    self.ax.add_patch(FancyArrow(cx, y_init, 0, arrow_height, width=0.01,\n                            length_includes_head=True, head_width=0.15, \n                            color='black', transform=trans))\n    if input_text is not None:\n        self.__draw_rotated_text__(initial_position, input_text, \n                                   angle=angle, rotate_text=rotate_text,\n                                   ha=ha, va=va, \n                                   fontsize=fontsize, offset=offset_vector)\n\n    # Compute rotated output point\n    output_pos = self.__get_rotated_pos__(initial_position, [2 * radius, 0], angle)\n    # Compute feedback point\n    feedback_pos = self.__get_rotated_pos__(initial_position, [radius, y_init - y_in + arrow_height], angle)\n    # Add element position to the dictionary\n    self.__add_element_position__(input_pos=[x_in,y_in], output_pos=output_pos,\n                                  feedback_pos=feedback_pos)\n    return output_pos\n</code></pre>"},{"location":"reference/#signalblocks.DiagramBuilder.DiagramBuilder.__draw_mult_combiner__","title":"<code>__draw_mult_combiner__(initial_position, length, inputs, operation='sum', orientation='horizontal')</code>","text":"<p>Inner method. Draws a summation or multiplication block with multiple inputs distributed  along the left edge of a circle, from pi/2 to 3*pi/2. Inputs can have a sign.</p> <p>Parameters:</p> Name Type Description Default <code>initial_position</code> <code>NDarray or list</code> <p>Coordinates of the starting point of the arrow.</p> required <code>length</code> <code>float</code> <p>Horizontal length of the block. If not entered, default <code>block_length</code> is used.</p> required <code>inputs</code> <code>list of str</code> <p>Thread names to combine.</p> required <code>operation</code> <code>string</code> <p>Operation of the combiner: {'mult', 'sum'}.</p> <code>'sum'</code> <code>orientation</code> <code>string or float</code> <p>Direction of the block: {'horizontal', 'vertical', 'up', 'down', 'left', 'right', angle}.</p> <code>'horizontal'</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>Coordinates of output point of the combiner.</p> Source code in <code>signalblocks\\DiagramBuilder.py</code> <pre><code>def __draw_mult_combiner__(self, initial_position, length, inputs, \n                           operation='sum', orientation='horizontal'):\n    \"\"\"\n    Inner method.\n    Draws a summation or multiplication block with multiple inputs distributed \n    along the left edge of a circle, from pi/2 to 3*pi/2. Inputs can have a sign.\n\n    Args:\n        initial_position (Numpy.NDarray or list): Coordinates of the starting point of the arrow.\n        length (float, optional): Horizontal length of the block. If not entered, default `block_length` is used.\n        inputs (list of str): Thread names to combine.\n        operation (string, optional): Operation of the combiner: {'mult', 'sum'}.\n        orientation (string or float, optional): Direction of the block: {'horizontal', 'vertical', 'up', 'down', 'left', 'right', angle}.\n\n    Returns:\n        (Numpy.NDArray): Coordinates of output point of the combiner.\n    \"\"\"\n    angle = 0\n    # Determine rotation angle based on orientation\n    if orientation in ['horizontal', 'right']:\n        angle = 0\n    elif orientation == 'left':\n        angle = 180\n    elif orientation in ['vertical', 'down']:\n        angle = -90\n    elif orientation == 'up':\n        angle = 90\n    elif isinstance(orientation, (int, float)):\n        angle = orientation\n    else:\n        angle = 0\n\n    # If position is 'auto', obtain head position\n    if isinstance(initial_position, str) and initial_position == 'auto':\n        # Get head positions of input threads\n        thread_input_pos = np.array([self.thread_positions[key] for key in inputs])\n        x_in = np.max(thread_input_pos[:, 0])\n        y_in = np.mean(thread_input_pos[:,1])\n        initial_position = [x_in, y_in]\n    # If position is given, use it\n    else:\n        x_in, y_in = initial_position\n\n    radius = length / 4\n    cx = x_in + length - radius\n    cy = y_in\n\n    # Apply rotation around the connection point (x_ini, y_ini)\n    trans = transforms.Affine2D().rotate_deg_around(x_in, y_in, angle) + self.ax.transData  \n\n    # Circle\n    circle = plt.Circle((cx, cy), radius, edgecolor='black', \n                        facecolor='white', transform=trans, zorder=2)\n    self.ax.add_patch(circle)\n\n    # Draw symbol inside circle depending on operation\n    rel_size = 0.7\n    if operation == 'mult':\n        # \"X\" inside circle\n        dx = radius * rel_size * np.cos(np.pi / 4)  # Escalamos un poco para que quepa dentro del c\u00edrculo\n        dy = radius * rel_size * np.sin(np.pi / 4)\n        #  45\u00b0 line\n        self.ax.plot([cx - dx, cx + dx], [cy - dy, cy + dy], color='black', \n                     linewidth=2, transform=trans, zorder=3)\n        # 135\u00b0 line\n        self.ax.plot([cx - dx, cx + dx], [cy + dy, cy - dy], color='black', \n                     linewidth=2, transform=trans, zorder=3)\n    elif operation == 'sum':\n        dx = radius * rel_size\n        dy = radius * rel_size\n        # \"+\" inside circle\n        self.ax.plot([cx - dx, cx + dx], [cy, cy], color='black', \n                     linewidth=2, transform=trans, zorder=3)\n        self.ax.plot([cx, cx], [cy - dy, cy + dy], color='black', \n                     linewidth=2, transform=trans, zorder=3)\n    else:\n        raise ValueError(f\"Unknown operation: {operation}. Use 'sum' or 'mult'.\")\n\n    # Get rotation matrix\n    rot_matrix = transforms.Affine2D().rotate_deg(angle).get_matrix()[:2, :2]\n\n    n = len(thread_input_pos)\n    angles = np.linspace(5* np.pi / 8, 11 * np.pi / 8, n)\n\n    arrow_width = 0.01\n    arrow_head_width = 0.15\n\n    # Input arrows\n    for i, inp in enumerate(thread_input_pos):\n        xi, yi = inp[:2]\n\n        x_edge = cx + radius * np.cos(angles[i])\n        y_edge = cy + radius * np.sin(angles[i])\n\n        dx = x_edge - x_in\n        dy = y_edge - y_in\n        offset_vec = [dx, dy]\n\n        # Rotated offset vector with respect to initial_position of element\n        dx_rot, dy_rot = rot_matrix @ offset_vec\n        # Rotated offset vector with respect to initial position of arrow\n        dx_rot_rel = dx_rot - xi + x_in\n        dy_rot_rel = dy_rot - yi + y_in\n\n        self.ax.add_patch(FancyArrow(\n            xi, yi, dx_rot_rel, dy_rot_rel,\n            width=arrow_width,\n            length_includes_head=True,\n            head_width=arrow_head_width,\n            color='black', transform=self.ax.transData, zorder=1\n        ))\n\n    # Compute rotated output point\n    output_pos = self.__get_rotated_pos__(initial_position, [length, 0], angle)\n    # Compute feedback point\n    feedback_pos = self.__get_rotated_pos__(initial_position, [length - radius, -radius], angle)\n    # Add element position to the dictionary\n    self.__add_element_position__(input_pos=[x_in,y_in], output_pos=output_pos,\n                                  feedback_pos=feedback_pos)\n    return output_pos\n</code></pre>"},{"location":"reference/#signalblocks.DiagramBuilder.DiagramBuilder.__draw_rotated_text__","title":"<code>__draw_rotated_text__(anchor_point, text, angle, rotate_text=True, ha='center', va='center', fontsize=16, offset=(0, 0))</code>","text":"<p>Inner method. Draws text rotated around the anchor point with optional offset.  Text position: rotation(anchor_point + offset)</p> <p>Parameters:</p> Name Type Description Default <code>anchor_point</code> <code>NDArray or list</code> <p>Coordinates of the anchor point.</p> required <code>text</code> <code>string</code> <p>String to display. LaTeX math accepted (without $...$).</p> required <code>angle</code> <code>float</code> <p>Rotation angle in degrees.</p> required <code>rotate_text</code> <code>bool</code> <p>Indicates if text must be rotated or not.</p> <code>True</code> <code>ha</code> <code>string</code> <p>Horizontal alignment: {'center', 'left', 'right'}.</p> <code>'center'</code> <code>va</code> <code>string</code> <p>Vertical alignment: {'center', 'bottom', 'top'}.</p> <code>'center'</code> <code>fontsize</code> <code>int</code> <p>Font size.</p> <code>16</code> <code>offset</code> <code>NDArray or list</code> <p>Coordinates of texr position respect to anchor point, before rotation.</p> <code>(0, 0)</code> Source code in <code>signalblocks\\DiagramBuilder.py</code> <pre><code>def __draw_rotated_text__(self, anchor_point, text, angle, rotate_text = True,\n                  ha='center', va='center', fontsize=16, offset=(0, 0)):\n    \"\"\"\n    Inner method.\n    Draws text rotated around the anchor point with optional offset. \n    Text position: rotation(anchor_point + offset)\n\n    Args:\n        anchor_point (Numpy.NDArray or list): Coordinates of the anchor point.\n        text (string): String to display. LaTeX math accepted (without $...$).\n        angle (float): Rotation angle in degrees.\n        rotate_text (bool, optional): Indicates if text must be rotated or not.\n        ha (string, optional): Horizontal alignment: {'center', 'left', 'right'}.\n        va (string, optional): Vertical alignment: {'center', 'bottom', 'top'}.\n        fontsize (int, optional): Font size.\n        offset (Numpy.NDArray or list): Coordinates of texr position respect to anchor point, before rotation.\n    \"\"\"\n    # Apply rotation to the offset vector\n    dx, dy = offset\n    offset_vec = np.array([dx, dy])\n    rot_matrix = transforms.Affine2D().rotate_deg(angle).get_matrix()[:2, :2]\n    dx_rot, dy_rot = rot_matrix @ offset_vec\n\n    # Compute final position\n    tx = anchor_point[0] + dx_rot\n    ty = anchor_point[1] + dy_rot\n\n    if rotate_text is False:\n        text_angle = 0\n    else:\n        text_angle = angle\n\n    # Draw text with angle, rotating around anchor point\n    self.ax.text(tx, ty, f\"${text}$\", ha=ha, va=va, fontsize=fontsize,\n            rotation=text_angle, rotation_mode='anchor', transform=self.ax.transData)\n</code></pre>"},{"location":"reference/#signalblocks.DiagramBuilder.DiagramBuilder.__get_rotated_pos__","title":"<code>__get_rotated_pos__(init_pos, outvector, angle)</code>","text":"<p>Inner method. Compute rotated point init_pos + outvector.</p> <p>Parameters:</p> Name Type Description Default <code>init_pos</code> <code>NDArray or list</code> <p>Initial position of the block (relative origin of coordinates).</p> required <code>outvector</code> <code>NDArray or list</code> <p>Output vector before rotation (relative position with respect to init_pos).</p> required <code>angle</code> <code>float</code> <p>Rotation angle in degrees.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>Rotated position of vector init_pos + outvector.</p> Source code in <code>signalblocks\\DiagramBuilder.py</code> <pre><code>def __get_rotated_pos__(self, init_pos, outvector, angle):\n    \"\"\"\n    Inner method.\n    Compute rotated point init_pos + outvector.\n\n    Args:\n        init_pos (Numpy.NDArray or list): Initial position of the block (relative origin of coordinates).\n        outvector (Numpy.NDArray or list): Output vector before rotation (relative position with respect to init_pos).\n        angle (float): Rotation angle in degrees.\n\n    Returns:\n        (Numpy.NDArray): Rotated position of vector init_pos + outvector.\n    \"\"\"\n\n    # Output point respect to input point (before rotation)\n    out_vector = np.array(outvector)\n    # Rotation matrix (without translation)\n    rotation_matrix = transforms.Affine2D().rotate_deg(angle).get_matrix()[:2, :2]\n    # Apply rotation to the output vector\n    dx, dy = rotation_matrix @ out_vector\n    # Add the rotated output vector to the initial position\n    return np.array([init_pos[0] + dx, init_pos[1] + dy])\n</code></pre>"},{"location":"reference/#signalblocks.DiagramBuilder.DiagramBuilder.__init__","title":"<code>__init__(block_length=1.0, block_height=1.0, fontsize=20)</code>","text":"<p>(Private) Creator of the DiagramBuilder class.</p> Source code in <code>signalblocks\\DiagramBuilder.py</code> <pre><code>def __init__(self, block_length=1.0, block_height=1.0, fontsize=20):\n    \"\"\"\n    (Private) Creator of the DiagramBuilder class.\n    \"\"\"\n    self.fig, self.ax = plt.subplots()\n    self.ax.axis('off')  # Hide axes\n    self.fontsize = fontsize\n    self.block_length = block_length\n    self.block_height = block_height\n    self.thread_positions = {}\n    self.thread_positions['main'] = [0, 0]\n    # Dictionary to store element positions: input_pos, output_pos, feedback_pos\n    self.element_positions = {}\n    # Counter for current element\n    self.current_element = -1\n</code></pre>"},{"location":"reference/#signalblocks.DiagramBuilder.DiagramBuilder.add","title":"<code>add(name, kind='block', thread='main', position=None, debug=False, **kwargs)</code>","text":"<p>Adds an element to the block diagram at the current or specified position of a given thread.</p> <p>This is the main interface for constructing diagrams by adding components such as blocks, arrows, inputs, outputs, combiners, and connectors. The <code>kind</code> parameter determines the type of element, and each type accepts specific keyword arguments listed below.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Main label or identifier for the element.</p> required <code>kind</code> <code>str</code> <p>Type of element. One of: - 'block': Rectangular block. - 'arrow': Straight line with ending arrow. - 'angled_arrow': Rect angle line with or without ending arrow. - 'input': Arrow with text before it. - 'output': Arrow with text after it. - 'line': Straight line without arrow ending. - 'combiner': Circle with (x), (+) or (-) and additional input. - 'mult_combiner': Combiner with multiple inputs.</p> <code>'block'</code> <code>thread</code> <code>str</code> <p>Thread identifier.</p> <code>'main'</code> <code>position</code> <code>tuple or str or None</code> <p>(x, y) position, 'auto' (for mult_combiner), or None to use current thread position.</p> <code>None</code> <code>debug</code> <code>bool</code> <p>If True, prints thread positions after placing the element.</p> <code>False</code> <p>The <code>**kwargs</code> vary depending on the <code>kind</code>:</p> <ul> <li> <p>kind = 'block':</p> <ul> <li>text (str, optional): Label inside the block (defaults to <code>name</code>).</li> <li>text_above (str, optional): Text above the block.</li> <li>text_below (str, optional): Text below the block.</li> <li>text_offset (float, optional): Offset for above/below text (defaults to 0.1).</li> <li>input_text (str, optional): Label for input arrow.</li> <li>input_side (str, optional): Side of a second optional input: {'top', 'bottom'} (defaults to <code>None</code>)</li> <li>length (float, optional): Block length (defaults to <code>self.block_length</code>).</li> <li>height (float, optional): Block height (defaults to <code>self.block_height</code>)..</li> <li>linestyle (str, optional): Block border line style (defaults to <code>-</code>).</li> <li>orientation (str or float, optional): Orientation of the block: {'horizontal', 'vertical', 'up', 'down' 'right', left' or angle in degrees} (defaults to 'horizontal').</li> <li>fontsize (int, optional): Text font size (defaults to <code>self.fontsize</code>).</li> </ul> </li> <li> <p>kind = 'arrow', 'input', 'output' or 'line':</p> <ul> <li>text (str, optional): Text on the arrow or line (defaults to <code>name</code>).</li> <li>text_position (str, optional): 'above', 'below', 'before', or 'after' (defaults to 'above' for 'arrow' and 'line', 'before' for 'input', and 'after' for 'output').</li> <li>text_offset (float, optional): Offset for text (defaults to 0.1).</li> <li>length (float, optional): Arrow or line length (defaults to <code>self.block_length</code>).</li> <li>orientation (str or float, optional): Orientation of the block: {'horizontal', 'vertical', 'up', 'down' 'right', left' or angle in degrees} (defaults to 'horizontal').</li> <li>fontsize (int, optional): Text font size (defaults to <code>self.fontsize</code>).</li> </ul> </li> <li> <p>kind = 'angled_arrow':</p> <ul> <li>text (str, optional): Text on the arrow or line (defaults to <code>name</code>).</li> <li>final_pos (Numpy.NDarray or list): Coordinates of the ending point of the arrow.</li> <li>text_position (str, optional): 'above', 'below', 'before', or 'after' (defaults to 'above' for 'arrow' and 'line', 'before' for 'input', and 'after' for 'output').</li> <li>text_offset (float, optional): Offset for text (defaults to 0.1).</li> <li>arrow (bool, optional): Indicates if it must finish or not in an arrow.</li> <li>first_segment (string, optional): Drawing order: {'horizontal', 'vertical'}</li> <li>orientation (str or float, optional): Orientation of the block: {'horizontal', 'vertical', 'up', 'down' 'right', left' or angle in degrees} (defaults to 'horizontal').</li> <li>fontsize (int, optional): Text font size (defaults to <code>self.fontsize</code>).</li> </ul> </li> <li> <p>kind = 'combiner':</p> <ul> <li>operation (string, optional): Operation of the combiner: {'mult', 'sum', 'dif'} (defaultds to 'mult').</li> <li>height (float, optional): Vertical height of the block. (defaults to <code>self.block_height</code>).</li> <li>input_side (string, optional): Side of the lateral input: {'bottom', 'top'} (defaults to 'bottom').</li> <li>input_text (string, optional): Label for the input arrow (below or above the arrow).</li> <li>text_offset (float, optional): Offset for text (defaults to 0.1).</li> <li>signs (list, optional): Sign to be shown on the horizontal (signs[0]) and vertical (signs[1]) inputs.</li> <li>orientation (str or float, optional): Orientation of the block: {'horizontal', 'vertical', 'up', 'down' 'right', left' or angle in degrees} (defaults to 'horizontal').</li> <li>fontsize (int, optional): Text font size (defaults to <code>self.fontsize</code>).</li> </ul> </li> <li> <p>kind = 'mult_combiner':</p> <ul> <li>operation (string, optional): Operation of the combiner: {'mult', 'sum', 'dif'} (defaults to 'mult').</li> <li>length (float, optional): Total element length (defaults to <code>self.block_length</code>).</li> <li>inputs (list of str): Thread names to combine.</li> <li>operation (string, optional): Operation of the combiner: {'mult', 'sum'} (defaults to 'sum').</li> <li>orientation (str or float, optional): Orientation of the block: {'horizontal', 'vertical', 'up', 'down' 'right', left' or angle in degrees} (defaults to 'horizontal').</li> <li>fontsize (int, optional): Text font size (defaults to <code>self.fontsize</code>).</li> </ul> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; db = DiagramBuilder()\n&gt;&gt;&gt; db.add(\"x(t)\", kind=\"input\")\n&gt;&gt;&gt; db.add(\"H(s)\", kind=\"block\")\n&gt;&gt;&gt; db.add(\"y(t)\", kind=\"output\")\n</code></pre> Source code in <code>signalblocks\\DiagramBuilder.py</code> <pre><code>def add(self,name, kind='block', thread='main', position=None, debug=False, **kwargs):\n    \"\"\"\n    Adds an element to the block diagram at the current or specified position of a given thread.\n\n    This is the main interface for constructing diagrams by adding components such as blocks, arrows,\n    inputs, outputs, combiners, and connectors. The `kind` parameter determines the type of element,\n    and each type accepts specific keyword arguments listed below.\n\n    Args:\n        name (str): Main label or identifier for the element.\n        kind (str, optional): Type of element. One of:\n            - 'block': Rectangular block.\n            - 'arrow': Straight line with ending arrow.\n            - 'angled_arrow': Rect angle line with or without ending arrow.\n            - 'input': Arrow with text before it.\n            - 'output': Arrow with text after it.\n            - 'line': Straight line without arrow ending.\n            - 'combiner': Circle with (x), (+) or (-) and additional input.\n            - 'mult_combiner': Combiner with multiple inputs.\n        thread (str, optional): Thread identifier.\n        position (tuple or str or None, optional): (x, y) position, 'auto' (for mult_combiner), or None to use current thread position.\n        debug (bool, optional): If True, prints thread positions after placing the element.\n\n    The `**kwargs` vary depending on the `kind`:\n\n    - **kind = 'block'**:\n        - text (str, optional): Label inside the block (defaults to `name`).\n        - text_above (str, optional): Text above the block.\n        - text_below (str, optional): Text below the block.\n        - text_offset (float, optional): Offset for above/below text (defaults to 0.1).\n        - input_text (str, optional): Label for input arrow.\n        - input_side (str, optional): Side of a second optional input: {'top', 'bottom'} (defaults to `None`)\n        - length (float, optional): Block length (defaults to `self.block_length`).\n        - height (float, optional): Block height (defaults to `self.block_height`)..\n        - linestyle (str, optional): Block border line style (defaults to `-`).\n        - orientation (str or float, optional): Orientation of the block: {'horizontal', 'vertical', 'up', 'down' 'right', left' or angle in degrees} (defaults to 'horizontal').\n        - fontsize (int, optional): Text font size (defaults to `self.fontsize`).\n\n    - **kind = 'arrow'**, **'input'**, **'output'** or **'line'**:\n        - text (str, optional): Text on the arrow or line (defaults to `name`).\n        - text_position (str, optional): 'above', 'below', 'before', or 'after' (defaults to 'above' for 'arrow' and 'line', 'before' for 'input', and 'after' for 'output').\n        - text_offset (float, optional): Offset for text (defaults to 0.1).\n        - length (float, optional): Arrow or line length (defaults to `self.block_length`).\n        - orientation (str or float, optional): Orientation of the block: {'horizontal', 'vertical', 'up', 'down' 'right', left' or angle in degrees} (defaults to 'horizontal').\n        - fontsize (int, optional): Text font size (defaults to `self.fontsize`).\n\n    - **kind = 'angled_arrow'**:\n        - text (str, optional): Text on the arrow or line (defaults to `name`).\n        - final_pos (Numpy.NDarray or list): Coordinates of the ending point of the arrow.\n        - text_position (str, optional): 'above', 'below', 'before', or 'after' (defaults to 'above' for 'arrow' and 'line', 'before' for 'input', and 'after' for 'output').\n        - text_offset (float, optional): Offset for text (defaults to 0.1).\n        - arrow (bool, optional): Indicates if it must finish or not in an arrow.\n        - first_segment (string, optional): Drawing order: {'horizontal', 'vertical'}\n        - orientation (str or float, optional): Orientation of the block: {'horizontal', 'vertical', 'up', 'down' 'right', left' or angle in degrees} (defaults to 'horizontal').\n        - fontsize (int, optional): Text font size (defaults to `self.fontsize`).\n\n    - **kind = 'combiner'**:\n        - operation (string, optional): Operation of the combiner: {'mult', 'sum', 'dif'} (defaultds to 'mult').\n        - height (float, optional): Vertical height of the block. (defaults to `self.block_height`).\n        - input_side (string, optional): Side of the lateral input: {'bottom', 'top'} (defaults to 'bottom').\n        - input_text (string, optional): Label for the input arrow (below or above the arrow).\n        - text_offset (float, optional): Offset for text (defaults to 0.1).\n        - signs (list, optional): Sign to be shown on the horizontal (signs[0]) and vertical (signs[1]) inputs.\n        - orientation (str or float, optional): Orientation of the block: {'horizontal', 'vertical', 'up', 'down' 'right', left' or angle in degrees} (defaults to 'horizontal').\n        - fontsize (int, optional): Text font size (defaults to `self.fontsize`).\n\n    - **kind = 'mult_combiner'**:\n        - operation (string, optional): Operation of the combiner: {'mult', 'sum', 'dif'} (defaults to 'mult').\n        - length (float, optional): Total element length (defaults to `self.block_length`).\n        - inputs (list of str): Thread names to combine.\n        - operation (string, optional): Operation of the combiner: {'mult', 'sum'} (defaults to 'sum').\n        - orientation (str or float, optional): Orientation of the block: {'horizontal', 'vertical', 'up', 'down' 'right', left' or angle in degrees} (defaults to 'horizontal').\n        - fontsize (int, optional): Text font size (defaults to `self.fontsize`).\n\n    Examples:\n        &gt;&gt;&gt; db = DiagramBuilder()\n        &gt;&gt;&gt; db.add(\"x(t)\", kind=\"input\")\n        &gt;&gt;&gt; db.add(\"H(s)\", kind=\"block\")\n        &gt;&gt;&gt; db.add(\"y(t)\", kind=\"output\")\n    \"\"\"\n\n    # If position is 'auto' (draw_mult_combiner), position is calculated inside that method\n    if isinstance(position, str) and position == 'auto':\n        initial_pos = 'auto'\n    # If input argument position is given and not 'auto', element position is asigned to position argument value\n    elif position is not None:\n        initial_pos = list(position)\n    # If not given\n    else:\n        # If thread already exists, element position is asigned from thread head\n        if thread in self.thread_positions:\n            initial_pos = self.thread_positions[thread]\n        # If doesn't exist\n        else:\n            initial_pos = [0, 0]\n\n    if kind == 'arrow':\n        # Default arguments\n        default_kwargs = {\n            'text': name,\n            'text_position': 'above',\n            'arrow': True,\n            'text_offset': 0.1,\n            'length': self.block_length,\n            'fontsize': self.fontsize,\n            'orientation': 'horizontal'\n        }\n        # Overrides default arguments with provided ones\n        block_args = {**default_kwargs, **kwargs}\n        # Function call\n        final_pos = self.__draw_arrow__(initial_pos, **block_args)\n\n    elif kind == 'angled_arrow':\n        # Default arguments\n        default_kwargs = {\n            'text': name,\n            'text_offset': 0.1,\n            'fontsize': self.fontsize,\n            'orientation': 'horizontal',\n        }\n        # Overrides default arguments with provided ones\n        block_args = {**default_kwargs, **kwargs}\n        # Function call\n        final_pos = self.__draw_angled_arrow__(initial_pos, **block_args)\n\n    elif kind == 'input':\n        # Default arguments\n        default_kwargs = {\n            'text': name,\n            'text_position': 'before',\n            'arrow': True,\n            'text_offset': 0.1,\n            'length': self.block_length,\n            'fontsize': self.fontsize,\n            'orientation': 'horizontal'\n        }\n        # Overrides default arguments with provided ones\n        block_args = {**default_kwargs, **kwargs}\n        # Function call\n        final_pos = self.__draw_arrow__(initial_pos, **block_args)\n\n    elif kind == 'output':\n        # Default arguments\n        default_kwargs = {\n            'text': name,\n            'text_position': 'after',\n            'arrow': True,\n            'text_offset': 0.1,\n            'length': self.block_length,\n            'fontsize': self.fontsize,\n            'orientation': 'horizontal'\n        }\n        # Overrides default arguments with provided ones\n        block_args = {**default_kwargs, **kwargs}\n        # Function call\n        final_pos = self.__draw_arrow__(initial_pos, **block_args)\n\n    elif kind == 'line':\n        # Default arguments\n        default_kwargs = {\n            'text': name,\n            'text_position': 'above',\n            'arrow': False,\n            'text_offset': 0.1,\n            'length': self.block_length,\n            'fontsize': self.fontsize,\n            'orientation': 'horizontal'\n        }\n        # Overrides default arguments with provided ones\n        block_args = {**default_kwargs, **kwargs}\n        # Function call\n        final_pos = self.__draw_arrow__(initial_pos, **block_args)\n\n    elif kind == 'block':\n        # Default arguments\n        default_kwargs = {\n            'text': name,\n            'text_above': None,\n            'text_below': None,\n            'text_offset': 0.1,\n            'input_text': None,\n            'input_side': None,\n            'length': self.block_length,\n            'height': self.block_height,\n            'fontsize': self.fontsize,\n            'linestyle': '-',\n            'orientation': 'horizontal'\n        }\n        # Overrides default arguments with provided ones\n        block_args = {**default_kwargs, **kwargs}\n        # Function call\n        final_pos = self.__draw_block__(initial_pos, **block_args)\n\n    elif kind == 'combiner':\n        # Default arguments\n        default_kwargs = {\n            'height': self.block_height,\n            'fontsize': self.fontsize,\n            'operation': 'mult',\n            'input_side': 'bottom',\n            'orientation': 'horizontal'\n        }\n        # Overrides default arguments with provided ones\n        block_args = {**default_kwargs, **kwargs}\n        # Function call\n        final_pos = self.__draw_combiner__(initial_pos, **block_args)\n\n    elif kind == 'mult_combiner':\n        # Default arguments\n        default_kwargs = {\n            'length': self.block_length,\n            'operation': 'mult',\n            'orientation': 'horizontal'\n        }\n        # Overrides default arguments with provided ones\n        block_args = {**default_kwargs, **kwargs}\n        # Function call\n        final_pos = self.__draw_mult_combiner__(initial_pos, **block_args)\n\n\n    elif kind == 'output':\n        length=kwargs.get('length', self.block_length)\n        final_pos = self.__draw_io_arrow__(initial_pos, length=length, text=kwargs.get('text', name),\n                      io='output', fontsize=self.fontsize)\n\n    else:\n        raise ValueError(f\"Unknown block type: {kind}\")\n\n    # Update head position of thread\n    self.thread_positions[thread] = final_pos\n\n    if debug:\n        self.__print_threads__()\n</code></pre>"},{"location":"reference/#signalblocks.DiagramBuilder.DiagramBuilder.get_current_element","title":"<code>get_current_element()</code>","text":"<p>Returns the current element index (last added).</p> <p>Returns:</p> Type Description <code>int</code> <p>Index of the last added element.</p> Source code in <code>signalblocks\\DiagramBuilder.py</code> <pre><code>def get_current_element(self):\n    \"\"\"\n    Returns the current element index (last added).\n\n    Returns:\n        (int): Index of the last added element.\n    \"\"\"\n    return self.current_element\n</code></pre>"},{"location":"reference/#signalblocks.DiagramBuilder.DiagramBuilder.get_position","title":"<code>get_position(element=None)</code>","text":"<p>Returns the positions of the specified element index. If no element specified, last added element is used. The return is a dictinoary with coordinates of <code>input_pos</code>, <code>output_pos</code> and <code>feedback_pos</code> (feedback port coordinates).</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>int</code> <p>index of the element.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict of Tuples</code> <p>Dictionary with three 2-element tuples: <code>input_pos</code>, <code>output_pos</code> and <code>feedback_pos</code>.</p> Source code in <code>signalblocks\\DiagramBuilder.py</code> <pre><code>def get_position(self, element=None):\n    \"\"\"\n    Returns the positions of the specified element index. If no element specified, last added element is used.\n    The return is a dictinoary with coordinates of `input_pos`, `output_pos` and `feedback_pos` (feedback port coordinates).\n\n    Args:\n        element (int, optional): index of the element.\n\n    Returns:\n        (dict of Tuples): Dictionary with three 2-element tuples: `input_pos`, `output_pos` and `feedback_pos`.\n    \"\"\"\n    if element is None:\n        return self.element_positions[self.current_element]\n    elif element &lt;= self.current_element:\n        return self.element_positions[element]\n    else:\n        raise ValueError(f\"Element '{element}' not found.\")\n</code></pre>"},{"location":"reference/#signalblocks.DiagramBuilder.DiagramBuilder.get_thread_position","title":"<code>get_thread_position(thread='main')</code>","text":"<p>Returns the current output position of the specified thread.</p> <p>Parameters:</p> Name Type Description Default <code>thread</code> <code>str</code> <p>Thread identifier.</p> <code>'main'</code> Source code in <code>signalblocks\\DiagramBuilder.py</code> <pre><code>def get_thread_position(self, thread='main'):\n    \"\"\"\n    Returns the current output position of the specified thread.\n\n    Args:\n        thread (str, optional): Thread identifier.\n    \"\"\"\n    if thread in self.thread_positions:\n        return self.thread_positions[thread]\n    else:\n        raise ValueError(f\"Thread '{thread}' not found.\")\n</code></pre>"},{"location":"reference/#signalblocks.DiagramBuilder.DiagramBuilder.print_threads","title":"<code>print_threads()</code>","text":"<p>Prints name of each thread in diagram and actual position.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from signalblocks import DiagramBuilder\n&gt;&gt;&gt; db = DiagramBuilder(block_length=1, fontsize=16)\n&gt;&gt;&gt; # Upper thread\n&gt;&gt;&gt; db.add(\"x_1(t)\", kind=\"input\", thread='upper', position=(0, 1))\n&gt;&gt;&gt; db.add(\"mult\", kind=\"combiner\", thread='upper', input_text=\"e^{-j\\omega_0 t}\", input_side='top', operation='mult')\n&gt;&gt;&gt; db.add(\"\", kind=\"line\", thread='upper')\n&gt;&gt;&gt; # Lower thread\n&gt;&gt;&gt; db.add(\"x_2(t)\", kind=\"input\", thread='lower', position=(0, -1))\n&gt;&gt;&gt; db.add(\"mult\", kind=\"combiner\", input_text=\"e^{j\\omega_0 t}\", input_side='bottom', operation='mult', thread='lower')\n&gt;&gt;&gt; db.add(\"\", kind=\"line\", thread='lower')\n&gt;&gt;&gt; input_threads = ['upper', 'lower']\n&gt;&gt;&gt; # Adder\n&gt;&gt;&gt; db.add(\"\", kind=\"mult_combiner\", inputs=input_threads, position=\"auto\", operation='sum')\n&gt;&gt;&gt; # Rest of the diagram (main thread)\n&gt;&gt;&gt; db.add(\"x(t)\", kind=\"output\")\n&gt;&gt;&gt; db.show()\n&gt;&gt;&gt; db.print_threads()\n</code></pre> Source code in <code>signalblocks\\DiagramBuilder.py</code> <pre><code>def print_threads(self):\n    \"\"\"\n    Prints name of each thread in diagram and actual position.\n\n    Examples:\n        &gt;&gt;&gt; from signalblocks import DiagramBuilder\n        &gt;&gt;&gt; db = DiagramBuilder(block_length=1, fontsize=16)\n        &gt;&gt;&gt; # Upper thread\n        &gt;&gt;&gt; db.add(\"x_1(t)\", kind=\"input\", thread='upper', position=(0, 1))\n        &gt;&gt;&gt; db.add(\"mult\", kind=\"combiner\", thread='upper', input_text=\"e^{-j\\\\omega_0 t}\", input_side='top', operation='mult')\n        &gt;&gt;&gt; db.add(\"\", kind=\"line\", thread='upper')\n        &gt;&gt;&gt; # Lower thread\n        &gt;&gt;&gt; db.add(\"x_2(t)\", kind=\"input\", thread='lower', position=(0, -1))\n        &gt;&gt;&gt; db.add(\"mult\", kind=\"combiner\", input_text=\"e^{j\\\\omega_0 t}\", input_side='bottom', operation='mult', thread='lower')\n        &gt;&gt;&gt; db.add(\"\", kind=\"line\", thread='lower')\n        &gt;&gt;&gt; input_threads = ['upper', 'lower']\n        &gt;&gt;&gt; # Adder\n        &gt;&gt;&gt; db.add(\"\", kind=\"mult_combiner\", inputs=input_threads, position=\"auto\", operation='sum')\n        &gt;&gt;&gt; # Rest of the diagram (main thread)\n        &gt;&gt;&gt; db.add(\"x(t)\", kind=\"output\")\n        &gt;&gt;&gt; db.show()\n        &gt;&gt;&gt; db.print_threads()\n    \"\"\"\n    for thread in self.thread_positions:\n        print(thread, \": \", self.thread_positions[thread])\n</code></pre>"},{"location":"reference/#signalblocks.DiagramBuilder.DiagramBuilder.show","title":"<code>show(margin=0.5, scale=1.0, savepath=None)</code>","text":"<p>Displays the current diagram or saves it to a file.</p> <p>Adjusts the view to fit the full diagram with an optional margin and scaling factor. If no elements have been drawn, simply displays an empty figure.</p> <p>Parameters:</p> Name Type Description Default <code>margin</code> <code>float</code> <p>Margin to add around the diagram (in data units).</p> <code>0.5</code> <code>scale</code> <code>float</code> <p>Scaling factor for the figure size.</p> <code>1.0</code> <code>savepath</code> <code>str</code> <p>If provided, saves the figure to the specified path (e.g., 'diagram.png' or 'diagram.pdf').                       If None, the diagram is shown in an interactive window.</p> <code>None</code> Source code in <code>signalblocks\\DiagramBuilder.py</code> <pre><code>def show(self, margin=0.5, scale=1.0, savepath=None):\n    \"\"\"\n    Displays the current diagram or saves it to a file.\n\n    Adjusts the view to fit the full diagram with an optional margin and scaling factor.\n    If no elements have been drawn, simply displays an empty figure.\n\n    Args:\n        margin (float, optional): Margin to add around the diagram (in data units).\n        scale (float, optional): Scaling factor for the figure size.\n        savepath (str, optional): If provided, saves the figure to the specified path (e.g., 'diagram.png' or 'diagram.pdf').\n                                  If None, the diagram is shown in an interactive window.\n\n    \"\"\"\n    bbox = self.__get_bbox__()\n    if bbox is None:\n        plt.show()\n        return\n\n    x0 = bbox.x0 - margin\n    x1 = bbox.x1 + margin\n    y0 = bbox.y0 - margin\n    y1 = bbox.y1 + margin\n\n    width = x1 - x0\n    height = y1 - y0\n\n    fig_width = width * scale\n    fig_height = height * scale\n    self.fig.set_size_inches(fig_width, fig_height)\n\n    self.ax.set_xlim(x0, x1)\n    self.ax.set_ylim(y0, y1)\n    self.ax.set_aspect(\"equal\", adjustable=\"box\")\n    self.ax.set_position([0, 0, 1, 1])\n    self.ax.axis(\"off\")\n\n    if savepath:\n        self.fig.savefig(savepath, bbox_inches='tight', dpi=self.fig.dpi, transparent=False, facecolor='white')\n        print(f\"Saved in: {savepath}\")\n    else:\n        plt.show()\n</code></pre>"},{"location":"reference/#signalplotter","title":"SignalPlotter","text":""},{"location":"reference/#signalblocks.SignalPlotter.SignalPlotter","title":"<code>SignalPlotter</code>","text":"<p>A helper class to plot signals y a minimalistic way. It has predefined typical signals, like rect, tri, Heaviside, delta, sinc, ... It allow to do operations with signals, like time shifts and inversions, sums, products, convolutions, ...</p> <p>Parameters:</p> Name Type Description Default <code>expr_str</code> <code>str</code> <p>A string expression defining the signal, e.g. \"x(t)=sin(t)*u(t)\".</p> <code>None</code> <code>horiz_range</code> <code>tuple</code> <p>Tuple (t_min, t_max) specifying the horizontal plotting range.</p> <code>(-5, 5)</code> <code>vert_range</code> <code>tuple</code> <p>Tuple (y_min, y_max) specifying the vertical range. Auto-scaled if None.</p> <code>None</code> <code>period</code> <code>float</code> <p>If provided, the signal is treated as periodic with this period.</p> <code>None</code> <code>num_points</code> <code>int</code> <p>Number of points used to discretize the time axis.</p> <code>1000</code> <code>figsize</code> <code>tuple</code> <p>Size of the figure in centimeters (width, height).</p> <code>(8, 3)</code> <code>tick_size_px</code> <code>int</code> <p>Size of axis tick marks in pixels.</p> <code>5</code> <code>xticks</code> <code>list or auto or None</code> <p>Positions of x-axis ticks. If 'auto', they are generated automatically.</p> <code>'auto'</code> <code>yticks</code> <code>list or auto or None</code> <p>Same for y-axis.</p> <code>'auto'</code> <code>xtick_labels</code> <code>list of str</code> <p>Labels for xticks. Must match xticks in length.</p> <code>None</code> <code>ytick_labels</code> <code>list of str</code> <p>Labels for yticks. Must match yticks in length.</p> <code>None</code> <code>pi_mode</code> <code>bool</code> <p>If True, x and y tick labels are shown as fractionary multiples of \u03c0 if possible.</p> <code>False</code> <code>fraction_ticks</code> <code>bool</code> <p>If True, tick labels are shown as rational fractions.</p> <code>False</code> <code>xticks_delta</code> <code>float</code> <p>If provided, generates xticks at this interval (when xticks='auto').</p> <code>None</code> <code>yticks_delta</code> <code>float</code> <p>Same for yticks.</p> <code>None</code> <code>save_path</code> <code>str</code> <p>If provided, saves the plot to the given path instead of displaying.</p> <code>None</code> <code>show_plot</code> <code>bool</code> <p>Whether to show the plot window (if False and save_path is given, it only saves).</p> <code>True</code> <code>color</code> <code>str</code> <p>Color for the plot line and impulses.</p> <code>'black'</code> <code>alpha</code> <code>float</code> <p>Transparency for background label boxes (between 0 and 1).</p> <code>0.5</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from signalblocks import SignalPlotter\n&gt;&gt;&gt; sp = SignalPlotter(\"x(t)=rect(t)\", horiz_range=(-2, 2), pi_mode=True).plot()\n&gt;&gt;&gt; SignalPlotter(\"x(t)=delta(t/2-1) + 3*delta(t + 2)\", color='blue', figsize=(8,4)).plot('x')\n&gt;&gt;&gt; signal1 = SignalPlotter(\"x(t)=cos(4 pi t)*tri(t/2)\", alpha=0.7, horiz_range=[-3, 3], xticks=np.linspace(-2, 2, 9), color='blue', figsize=(12,4))\n&gt;&gt;&gt; signal1.plot()\n&gt;&gt;&gt; SignalPlotter(\"x(t)=pw((t**2, (t&gt;-1) &amp; (t&lt;0)), (-t, (t&gt;=0) &amp; (t&lt;1)), (0, True))\", horiz_range=[-2.5, 2.5], xticks=np.linspace(-2, 2, 9), color='blue', period=2)\n</code></pre> Source code in <code>signalblocks\\SignalPlotter.py</code> <pre><code>class SignalPlotter:\n    \"\"\"\n    A helper class to plot signals y a minimalistic way. It has predefined\n    typical signals, like rect, tri, Heaviside, delta, sinc, ...\n    It allow to do operations with signals, like time shifts and inversions,\n    sums, products, convolutions, ...\n\n    Args:\n        expr_str (str, optional): A string expression defining the signal, e.g. \"x(t)=sin(t)*u(t)\".\n        horiz_range (tuple, optional): Tuple (t_min, t_max) specifying the horizontal plotting range.\n        vert_range (tuple, optional): Tuple (y_min, y_max) specifying the vertical range. Auto-scaled if None.\n        period (float, optional): If provided, the signal is treated as periodic with this period.\n        num_points (int, optional): Number of points used to discretize the time axis.\n        figsize (tuple, optional): Size of the figure in centimeters (width, height).\n        tick_size_px (int, optional): Size of axis tick marks in pixels.\n        xticks (list or 'auto' or None): Positions of x-axis ticks. If 'auto', they are generated automatically.\n        yticks (list or 'auto' or None): Same for y-axis.\n        xtick_labels (list of str, optional): Labels for xticks. Must match xticks in length.\n        ytick_labels (list of str, optional): Labels for yticks. Must match yticks in length.\n        pi_mode (bool, optional): If True, x and y tick labels are shown as fractionary multiples of \u03c0 if possible.\n        fraction_ticks (bool, optional): If True, tick labels are shown as rational fractions.\n        xticks_delta (float, optional): If provided, generates xticks at this interval (when xticks='auto').\n        yticks_delta (float, optional): Same for yticks.\n        save_path (str, optional): If provided, saves the plot to the given path instead of displaying.\n        show_plot (bool, optional): Whether to show the plot window (if False and save_path is given, it only saves).\n        color (str, optional): Color for the plot line and impulses.\n        alpha (float, optional): Transparency for background label boxes (between 0 and 1).\n\n    Examples:\n        &gt;&gt;&gt; from signalblocks import SignalPlotter\n        &gt;&gt;&gt; sp = SignalPlotter(\"x(t)=rect(t)\", horiz_range=(-2, 2), pi_mode=True).plot()\n        &gt;&gt;&gt; SignalPlotter(\"x(t)=delta(t/2-1) + 3*delta(t + 2)\", color='blue', figsize=(8,4)).plot('x')\n        &gt;&gt;&gt; signal1 = SignalPlotter(\"x(t)=cos(4 pi t)*tri(t/2)\", alpha=0.7, horiz_range=[-3, 3], xticks=np.linspace(-2, 2, 9), color='blue', figsize=(12,4))\n        &gt;&gt;&gt; signal1.plot()\n        &gt;&gt;&gt; SignalPlotter(\"x(t)=pw((t**2, (t&gt;-1) &amp; (t&lt;0)), (-t, (t&gt;=0) &amp; (t&lt;1)), (0, True))\", horiz_range=[-2.5, 2.5], xticks=np.linspace(-2, 2, 9), color='blue', period=2)\n    \"\"\"\n    def __init__(\n        self,\n        expr_str=None, \n        horiz_range=(-5, 5),\n        vert_range=None,\n        period=None,\n        num_points=1000,\n        figsize=(8, 3), \n        tick_size_px=5,\n        xticks='auto',\n        yticks='auto',\n        xtick_labels=None,\n        ytick_labels=None,\n        xticks_delta=None,\n        yticks_delta=None,\n        pi_mode=False,\n        fraction_ticks=False,\n        save_path=None, \n        show_plot=True,\n        color='black', \n        alpha=0.5 \n    ):\n        \"\"\"\n        (Private) Creator of the SignalPlotter class.\n        \"\"\"\n        self.signal_defs = {}\n        self.var_symbols = {}\n        self.current_name = None\n        self.horiz_range = horiz_range\n        self.vert_range = vert_range\n        self.num_points = num_points\n        self.figsize = figsize\n        self.tick_size_px = tick_size_px\n        self.color = color\n        self.alpha = alpha\n        self.period = period\n        self.save_path = save_path\n        self.show_plot = show_plot\n\n        self.fraction_ticks = fraction_ticks\n\n        # Preserve original tick arguments to differentiate None / [] / 'auto'\n        self.init_xticks_arg = xticks\n        self.init_yticks_arg = yticks\n\n        if isinstance(xticks, (list, tuple, np.ndarray)) and len(xticks) &gt; 0:\n            self.xticks = np.array(xticks)\n        else:\n            self.xticks = None\n        if isinstance(yticks, (list, tuple, np.ndarray)) and len(yticks) &gt; 0:\n            self.yticks = np.array(yticks)\n        else:\n            self.yticks = None\n\n        self.pi_mode = pi_mode\n\n        self.xtick_labels = xtick_labels\n        self.ytick_labels = ytick_labels\n\n        if self.xtick_labels is not None:\n            if self.xticks is None:\n                raise ValueError(\"xtick_labels provided without xticks positions\")\n            if len(self.xtick_labels) != len(self.xticks):\n                raise ValueError(\"xtick_labels and xticks must have the same length\")\n        if self.ytick_labels is not None:\n            if self.yticks is None:\n                raise ValueError(\"ytick_labels provided without yticks positions\")\n            if len(self.ytick_labels) != len(self.yticks):\n                raise ValueError(\"ytick_labels and yticks must have the same length\")\n\n        self.xticks_delta = xticks_delta\n        self.yticks_delta = yticks_delta\n\n        self.expr_str_pending = expr_str  # Expression to initialize later if plot() is called first\n\n        self.transformations = (standard_transformations + (implicit_multiplication_application,))\n\n\n    def _get_local_dict(self):\n        \"\"\"\n        (Private) Returns a local dictionary of predefined symbols and functions used\n        during symbolic parsing and evaluation of signal expressions.\n\n        This includes:\n        - Common signal processing functions such as:\n            - u(t): Heaviside step (centered at 0.5)\n            - rect(t), tri(t), sinc(t), ramp(t), delta(t)\n        - Piecewise functions:\n            - Piecewise, pw\n        - Mathematical functions and constants:\n            - sin, cos, exp, pi, abs, arg, re, im, conj\n        - Symbols used in frequency/time analysis: t, \u03c9, \u03a9, \u03c4, \u03bb\n        - Support for complex signals: i, j, re, im, conj, abs, arg \n        - Previously defined signal names in the format \"name(variable)\"\n\n        Returns:\n            dict: A dictionary mapping names to SymPy expressions or functions.\n\n        Examples:\n            &gt;&gt;&gt; local_dict = self._get_local_dict()\n            &gt;&gt;&gt; expr = parse_expr(\"x(t) + rect(t)\", local_dict=local_dict)\n        \"\"\"\n        d = {\n            'u':            lambda t: sp.Heaviside(t, 0.5),\n            'rect':         lambda t: sp.Piecewise((1, sp.And(t &gt;= -0.5, t &lt;= 0.5)), (0, True)),\n            'tri':          lambda t: (1 - abs(t)) * sp.Heaviside(1 - abs(t), 0),   # 0 expl\u00edcito en bordes de tri\u00e1ngulo\n            'ramp':         lambda t: sp.Heaviside(t, 0) * t,\n            'sinc':         lambda t: sp.sin(sp.pi * t) / (sp.pi * t),\n            'delta':        sp.DiracDelta,\n            'DiracDelta':   sp.DiracDelta,\n            'Heaviside':    lambda t: sp.Heaviside(t, 0.5),\n            'pi':           sp.pi,\n            'sin':          sp.sin,\n            'cos':          sp.cos,\n            'exp':          sp.exp,\n            'Piecewise':    sp.Piecewise,\n            'pw':           sp.Piecewise,\n            're':           sp.re,\n            'im':           sp.im,\n            'conj':         sp.conjugate,\n            'abs':          lambda x: np.abs(x),\n            'arg':          sp.arg,\n            'i':            sp.I,\n            'j':            sp.I,\n            't':            sp.Symbol('t'),\n            'omega':        sp.Symbol('omega'),\n            'Omega':        sp.Symbol('Omega'),\n            'tau':          sp.Symbol('tau'),\n            'lambda':       sp.Symbol('lambda'),\n        }\n        d.update(self.var_symbols)\n        for name, expr in self.signal_defs.items():\n            for var in self.var_symbols.values():\n                d[f\"{name}({var})\"] = expr.subs(var, var)\n        return d\n\n    # def _initialize_expression(self, expr_str):\n    #     m = re.match(r\"^(?P&lt;fn&gt;[^\\W\\d_]+)\\((?P&lt;vr&gt;[^)]+)\\)\\s*=\\s*(?P&lt;ex&gt;.+)$\", expr_str)\n    #     if m:\n    #         self.func_name = m.group('fn')\n    #         var_name = m.group('vr')\n    #         expr_body = m.group('ex')\n    #     else:\n    #         self.func_name = 'x'\n    #         var_name = 't'\n    #         expr_body = expr_str\n\n    #     replacements = {'\\\\omega': '\u03c9', '\\\\tau': '\u03c4'}\n    #     for latex_var, unicode_var in replacements.items():\n    #         var_name = var_name.replace(latex_var, unicode_var)\n    #         expr_body = expr_body.replace(latex_var, unicode_var)\n\n    #     self.expr_str = expr_body\n    #     self.var = sp.Symbol(var_name)\n    #     self.xlabel = var_name\n    #     self.ylabel = self.func_name + '(' + var_name + ')'\n\n    #     self.local_dict = self._get_local_dict()\n\n    #     transformations = standard_transformations + (implicit_multiplication_application,)\n    #     self.expr = parse_expr(expr_body, local_dict=self.local_dict, transformations=transformations)\n\n    #     self.expr_cont = self._remove_dirac_terms()\n    #     self.impulse_locs, self.impulse_areas = self._extract_impulses()\n\n    #     t0, t1 = self.horiz_range\n    #     self.t_vals = np.linspace(t0, t1, self.num_points)\n    #     if self.period is not None:\n    #         T = self.period\n    #         self.t_vals = ((self.t_vals + T/2) % T) - T/2\n    #         self.t_vals.sort()\n\n    #     self.func = sp.lambdify(self.var, self.expr_cont, modules=[\"numpy\", self.local_dict])\n    #     self.fig, self.ax = plt.subplots(figsize=self.figsize)\n    #     self._prepare_plot()\n\n    def add_signal(self, expr_str, label=None, period=None):\n        \"\"\"\n        Adds a new signal to the internal dictionary for later plotting.\n        - The expression is parsed symbolically using SymPy.\n        - If other signals are referenced, their definitions are recursively substituted.\n        - If `period` is set, the signal will be expanded as a sum of time-shifted versions over the full horizontal range.\n\n        Args:\n            expr_str (str): Signal definition in the form \"name(var) = expression\",\n        e.g. \"x(t) = rect(t) + delta(t-1)\". The expression may include previously defined signals.\n            label (str, optional): Custom label for the vertical axis when plotting this signal.\n            period (float, optional): If provided, the signal will be treated as periodic with this period.\n\n        Examples:\n            &gt;&gt;&gt; sp = SignalPlotter(horiz_range=(-1, 1), fraction_ticks=True, figsize=(12, 4))\n            &gt;&gt;&gt; sp.add_signal(\"x1(t) = tri(t)\")\n            &gt;&gt;&gt; sp.add_signal(\"x2(t) = delta(t)\", period=0.2)\n            &gt;&gt;&gt; sp.add_signal(\"x3(t) = x1(t) * (1 + x2(t))\", label=\"x_3(t)\")\n            &gt;&gt;&gt; sp.plot(\"x3\")\n            &gt;&gt;&gt; sp.add_signal(\"x4(t) = exp((-2+j*8*pi)*t)*u(t)\")\n            &gt;&gt;&gt; sp.add_signal(\"x5(t) = re(x4(t))\", label=\"\\Re\\{x_4(t)\\}\")\n            &gt;&gt;&gt; sp.plot('x5')\n        \"\"\"\n        m = re.match(r\"^(?P&lt;fn&gt;\\w+)\\((?P&lt;vr&gt;\\w+)\\)\\s*=\\s*(?P&lt;ex&gt;.+)$\", expr_str)\n\n        replacements = {'\\\\omega': '\u03c9', '\\\\tau': '\u03c4'}\n        for latex_var, unicode_var in replacements.items():\n            expr_str = expr_str.replace(latex_var, unicode_var)\n        m = re.match(r\"^(?P&lt;fn&gt;\\w+)\\((?P&lt;vr&gt;\\w+)\\)\\s*=\\s*(?P&lt;ex&gt;.+)$\", expr_str)\n\n        name = m.group('fn')\n        var = m.group('vr')\n        body = m.group('ex')\n\n        if var not in self.var_symbols:\n            self.var_symbols[var] = sp.Symbol(var)\n        var_sym = self.var_symbols[var]\n\n        local_dict = self._get_local_dict()\n        for other_name in self.signal_defs:\n            local_dict[other_name] = sp.Function(other_name)\n\n        transformations = standard_transformations + (implicit_multiplication_application,)\n        parsed_expr = parse_expr(body, local_dict=local_dict, transformations=transformations)\n\n        for other_name, other_expr in self.signal_defs.items():\n            f = sp.Function(other_name)\n            matches = parsed_expr.find(f)\n            for call in matches:\n                if isinstance(call, sp.Function):\n                    arg = call.args[0]\n                    replaced = other_expr.subs(var_sym, arg)\n                    parsed_expr = parsed_expr.subs(call, replaced)\n\n        self.signal_defs[name] = parsed_expr\n        self.var_symbols[name] = var_sym\n\n        if label is not None:\n            if not hasattr(self, 'custom_labels'):\n                self.custom_labels = {}\n            self.custom_labels[name] = label\n\n        if period is not None:\n            if not hasattr(self, 'signal_periods'):\n                self.signal_periods = {}\n            self.signal_periods[name] = period\n\n            # Expand signal as sum of shifts within range\n            horiz_min, horiz_max = self.horiz_range\n            num_periods = int(np.ceil((horiz_max - horiz_min) / period))\n            k_range = range(-num_periods - 2, num_periods + 3)  # m\u00e1rgenes extra\n\n            # Expanded as sum of shifted expressions (in SymPy)\n            expanded_expr = sum(parsed_expr.subs(var_sym, var_sym - period * k) for k in k_range)\n\n            self.signal_defs[name] = expanded_expr\n        else:\n            self.signal_defs[name] = parsed_expr\n\n\n    def _prepare_plot(self):\n        \"\"\"\n        (Private) Determines the vertical plotting range (y-axis limits) based on the signal values. \n        Called from `plot()`.\n\n        This method:\n        - Evaluates the continuous part of the signal over `self.t_vals`.\n        - Identifies Dirac delta impulses located within the horizontal plotting range.\n        - Computes the minimum and maximum of both continuous and impulsive parts.\n        - Ensures a minimal vertical span to avoid flat-looking plots.\n        - Uses `self.vert_range` if explicitly provided.\n\n        Sets:\n        - self.y_min, self.y_max: Vertical limits for plotting.\n\n        Notes:\n        - If evaluation fails (e.g. undefined expression), defaults to [-1, 1].\n        - Delta impulses are included only if they fall within the horizontal range.\n\n        Examples:\n            &gt;&gt;&gt; self._prepare_plot()\n            &gt;&gt;&gt; print(self.y_min, self.y_max)  # \u2192 computed bounds\n        \"\"\"\n        try:\n            # Evaluate continuous expression\n            y_vals = self.func(self.t_vals)\n            y_vals = np.array(y_vals, dtype=np.float64)\n            y_vals = y_vals[np.isfinite(y_vals)]\n\n            if y_vals.size &gt; 0:\n                cont_min = np.min(y_vals)\n                cont_max = np.max(y_vals)\n            else:\n                cont_min = 0.0\n                cont_max = 0.0\n\n            # Visible deltas in hoirzontal range\n            if self.impulse_locs and self.impulse_areas:\n                t_min, t_max = self.horiz_range\n                filtered_areas = [\n                    area for loc, area in zip(self.impulse_locs, self.impulse_areas)\n                    if t_min &lt;= loc &lt;= t_max\n                ]\n                if filtered_areas:\n                    imp_min = min(filtered_areas)\n                    imp_max = max(filtered_areas)\n                    overall_min = min(cont_min, imp_min, 0.0)\n                    overall_max = max(cont_max, imp_max, 0.0)\n                else:\n                    overall_min = min(cont_min, 0.0)\n                    overall_max = max(cont_max, 0.0)\n            else:\n                overall_min = min(cont_min, 0.0)\n                overall_max = max(cont_max, 0.0)\n\n            # Fit in case range is too narrow\n            if abs(overall_max - overall_min) &lt; 1e-2:\n                overall_min -= 1.0\n                overall_max += 1.0\n\n            # Apply vertical range if provided\n            if self.vert_range:\n                self.y_min, self.y_max = self.vert_range\n            else:\n                self.y_min, self.y_max = overall_min, overall_max\n\n        except Exception:\n            self.y_min, self.y_max = -1, 1\n\n\n    def _eval_func_array(self, t):\n        \"\"\"\n        (Private) Evaluates the continuous (non-impulsive) part of the signal at the given time values.\n        Notes:\n        - This method assumes `self.func` is a callable created with `lambdify(...)`.\n        - Ensures consistent array output for plotting, regardless of scalar/vector behavior.\n\n        Args:\n            t (array-like or scalar): Time values at which to evaluate the signal function.\n\n        Returns:\n            (Numpy.NDArray): A NumPy array of evaluated values with the same shape as `t`.\n            If the result is scalar (i.e., constant function), it is broadcast across all `t`.\n\n        Examples:\n            &gt;&gt;&gt; t_vals = np.linspace(-1, 1, 100)\n            &gt;&gt;&gt; y_vals = self._eval_func_array(t_vals)\n        \"\"\"\n        y = self.func(t)\n        return np.full_like(t, y, dtype=float) if np.isscalar(y) else np.array(y, dtype=float)\n\n    def _extract_impulses(self):\n        \"\"\"\n        (Private) Extracts the locations and amplitudes of Dirac delta impulses from the signal expression.\n\n        This method:\n        - Expands the symbolic expression `self.expr` into additive terms.\n        - Identifies all DiracDelta terms and their arguments.\n        - Solves each delta argument for its root(s) to determine impulse location(s).\n        - Computes the effective amplitude of each impulse, accounting for time scaling:\n            For \u03b4(a\u00b7t + b), amplitude is scaled by 1/|a|.\n        - Merges nearby impulses numerically (within a tolerance of 1e-8) to avoid duplicates.\n        - Ignores impulses with near-zero amplitude (threshold: 1e-6).\n\n        Returns:\n            impulse_locs (list of float): Time positions of Dirac delta impulses.\n            impulse_areas (list of float): Corresponding amplitudes (areas) of each impulse.\n\n        Example:\n            &gt;&gt;&gt; self.expr = sp.DiracDelta(t - 1) + 2*sp.DiracDelta(2*t)\n            &gt;&gt;&gt; locs, areas = self._extract_impulses()\n            &gt;&gt;&gt; print(locs)   # \u2192 [1.0, 0.0]\n            &gt;&gt;&gt; print(areas)  # \u2192 [1.0, 1.0]  (2*\u03b4(2t) has area 1 due to 1/|2| scaling)\n        \"\"\"\n        impulse_map = {}\n\n        # Expandir y descomponer en t\u00e9rminos\n        expr_terms = self.expr.expand().as_ordered_terms()\n\n        for term in expr_terms:\n            deltas = term.atoms(sp.DiracDelta)\n            for delta in deltas:\n                arg = delta.args[0]\n                roots = sp.solve(arg, self.var)\n                amp = term.coeff(delta)\n                d_arg = sp.diff(arg, self.var)\n                scale = sp.Abs(d_arg)\n\n                for r in roots:\n                    try:\n                        scale_val = float(scale.subs(self.var, r))\n                        amp_eval = amp.subs(self.var, r).doit().evalf()\n                        effective_amp = float(amp_eval) / scale_val if scale_val != 0 else 0.0\n                        if abs(effective_amp) &gt; 1e-6:\n                            loc = float(r)\n                            # Buscar ubicaci\u00f3n cercana ya existente (tolerancia)\n                            found = False\n                            for known_loc in impulse_map:\n                                if abs(known_loc - loc) &lt; 1e-8:\n                                    impulse_map[known_loc] += effective_amp\n                                    found = True\n                                    break\n                            if not found:\n                                impulse_map[loc] = effective_amp\n                    except (TypeError, ValueError, ZeroDivisionError):\n                        continue\n\n        # Filtrar deltas resultantes \u2260 0 tras sumar contribuciones\n        impulse_locs = []\n        impulse_areas = []\n        for loc, area in impulse_map.items():\n            if abs(area) &gt; 1e-6:\n                impulse_locs.append(loc)\n                impulse_areas.append(area)\n\n        return impulse_locs, impulse_areas\n\n\n\n    def _remove_dirac_terms(self):\n        \"\"\"\n        Removes all Dirac delta (impulse) terms from the symbolic expression.\n\n        This method:\n        - Scans `self.expr` for any subexpressions containing `DiracDelta(...)`.\n        - Replaces each occurrence with 0, effectively isolating the continuous part\n        of the signal (excluding impulses).\n\n        Returns:\n            sympy.Expr: A new expression identical to `self.expr` but with all DiracDelta terms removed.\n\n        Example:\n            &gt;&gt;&gt; self.expr = delta(t) + sp.sin(t)\n            &gt;&gt;&gt; self._remove_dirac_terms()\n            sin(t)\n        \"\"\"\n        return self.expr.replace(lambda expr: expr.has(sp.DiracDelta), lambda _: 0)\n\n\n    def draw_function(self, horiz_range=None):\n        \"\"\"\n        Plots the continuous part of the signal over the specified horizontal range.\n        This method is typically called after `setup_axes()`.\n        This method is usually called internally from `plot()`, but can also be used manually.\n\n        This method:\n        - Evaluates the function defined in `self.func` across `self.t_vals`.\n        - Plots the result as a smooth curve using the configured color and linewidth.\n        - Automatically detects and adds ellipsis (\"\u22ef\") on the left/right ends if:\n            - The signal is marked as periodic, or\n            - Significant energy exists just outside the plotting range.\n\n        Notes:\n        - This method does not draw delta impulses. Use `draw_impulses()` for that.\n        - Ellipsis are drawn at 5% beyond the plot edges when appropriate.\n\n        Args:\n            horiz_range (tuple, optional): Tuple (t_min, t_max) to override the default horizontal range. If None, uses `self.horiz_range`.\n\n        Examples:\n            &gt;&gt;&gt; self.draw_function()\n            &gt;&gt;&gt; self.draw_impulses()  # to add deltas on top of the curve\n        \"\"\"\n\n        if horiz_range is None:\n            horiz_range = self.horiz_range\n\n        t0, t1 = horiz_range\n        t_plot = self.t_vals\n        y_plot = self._eval_func_array(t_plot)\n\n        # Assure arrays and format\n        t_plot = np.array(t_plot)\n        y_plot = np.array(y_plot)\n        if y_plot.ndim == 0:\n            y_plot = np.full_like(t_plot, y_plot, dtype=float)\n\n        # Plot curve\n        self.ax.plot(t_plot, y_plot, color=self.color, linewidth=2.5, zorder=5)\n\n        # Decide whether to draw ellipsis\n        delta = (t1 - t0) * 0.05\n        tol = 1e-3\n        span = t1 - t0\n        draw_left = draw_right = False\n\n        # Show alwais if periodic\n        if hasattr(self, 'signal_periods') and self.current_name in self.signal_periods:\n            draw_left = draw_right = True\n        else:\n            N = max(10, int(0.05 * self.num_points))\n            xs_left = np.linspace(t0 - 0.05 * span, t0, N)\n            ys_left = np.abs(self._eval_func_array(xs_left))\n            if np.trapz(ys_left, xs_left) &gt; tol:\n                draw_left = True\n\n            xs_right = np.linspace(t1, t1 + 0.05 * span, N)\n            ys_right = np.abs(self._eval_func_array(xs_right))\n            if np.trapz(ys_right, xs_right) &gt; tol:\n                draw_right = True\n\n        # Draw ellipsis if needed\n        y_mid = (self.y_min + 2 * self.y_max) / 3\n        if draw_left:\n            self.ax.text(t0 - delta, y_mid, r'$\\cdots$', ha='left', va='center',\n                        color=self.color, fontsize=14, zorder=10)\n        if draw_right:\n            self.ax.text(t1 + delta, y_mid, r'$\\cdots$', ha='right', va='center',\n                        color=self.color, fontsize=14, zorder=10)\n\n\n    def draw_impulses(self):\n        \"\"\"\n        Draws Dirac delta impulses at the extracted positions and amplitudes.\n        This method is typically called after `draw_functions()`.\n        This method is usually called internally from `plot()`, but can also be used manually.\n\n        This method:\n        - Iterates over the list of impulse locations (`self.impulse_locs`)\n        and their corresponding amplitudes (`self.impulse_areas`).\n        - Calls `_draw_single_impulse()` for each impulse located within\n        the current horizontal plotting range (`self.horiz_range`).\n\n        Notes:\n        - This method only draws impulses that are visible within the plotting window.\n        - Periodicity is not assumed. Use `add_signal(..., period=...)` to manually expand periodic impulses.\n        - The drawing includes both a vertical arrow and a bold label showing the impulse area.\n\n        Examples:\n            &gt;&gt;&gt; self.draw_function()\n            &gt;&gt;&gt; self.draw_impulses()\n        \"\"\"\n        t_min, t_max = self.horiz_range\n        for t0, amp in zip(self.impulse_locs, self.impulse_areas):\n            if t_min &lt;= t0 &lt;= t_max:\n                self._draw_single_impulse(t0, amp)\n\n    def _draw_single_impulse(self, t0, amp):\n        \"\"\"\n        Draws a single Dirac delta impulse at the specified location and amplitude.\n\n        This method:\n        - Draws a vertical arrow starting from (t0, 0) up to (t0, amp).\n        - Places a bold numerical label near the tip of the arrow indicating the amplitude.\n        - Slightly offsets the label horizontally if the impulse is located at or near t = 0,\n        to avoid overlapping with the vertical axis.\n\n        Notes:\n        - Arrow and label use the color specified in `self.color`.\n        - Label placement is adjusted to avoid axis clutter at t = 0.\n\n        Args:\n            t0 (float): The location of the impulse along the time axis.\n            amp (float): The area of the impulse. Determines arrow height and label.\n\n        Examples:\n            &gt;&gt;&gt; self._draw_single_impulse(1.0, 2.5)  # draws 2.5\u00b7\u03b4(t \u2212 1)\n        \"\"\"\n        # Arrow from (t0,0) to (t0, amp)\n        self.ax.annotate(\n            '', xy=(t0, amp + 0.01 * (self.y_max - self.y_min)), xytext=(t0, 0),\n            arrowprops=dict(\n                arrowstyle='-|&gt;',\n                linewidth=2.5,\n                color=self.color,\n                mutation_scale=16\n            ),\n            zorder=10\n        )\n\n        # Calculate horizontal offset for the label if t0 \u2248 0\n        x_min, x_max = self.ax.get_xlim()\n        x_range = x_max - x_min\n        # Threshold to consider that t0 is 'almost' zero\n        tol = 1e-6 * max(1.0, abs(x_range))\n        if abs(t0) &lt; tol:\n            # Shift label a 2% of horizontal range to the left\n            x_offset = -0.01 * x_range\n            ha = 'right'\n        else:\n            x_offset = 0.0\n            ha = 'center'\n\n        # Algin label above continuous curve if necessary\n        arrow_headroom = 0.05 * (self.y_max - self.y_min)\n        x_text = t0 + x_offset\n        y_text = amp + arrow_headroom\n\n        self.ax.text(\n            x_text, y_text,\n            f'{amp:g}',\n            ha=ha,\n            va='bottom' if amp &gt; 0 else 'top',\n            fontsize=12,\n            color=self.color,\n            fontweight='bold',\n            zorder=10\n        )\n\n\n    def setup_axes(self, horiz_range=None):\n        \"\"\"\n        Configures the plot axes: hides borders, sets limits, and draws arrow-like axes.\n        This method is typically called after `_prepare_plot()` to finalize the plot appearance.\n        This method is usually called internally from `plot()`, but can also be used manually.\n\n        This method:\n        - Hides the default box (spines) around the plot.\n        - Clears all default ticks.\n        - Sets the horizontal and vertical limits based on the signal range.\n        - Adds margin space around the plotted data to improve visual clarity.\n        - Draws custom x- and y-axis arrows using `annotate`.\n        - Calls `tight_layout()` to prevent label clipping.\n\n        Notes:\n        - The horizontal axis includes a 20% margin on both sides.\n        - The vertical axis includes 30% below and 60% above the data range.\n        - The vertical range must be computed beforehand via `_prepare_plot()`.\n\n        Args:\n            horiz_range (tuple, optional): If provided, overrides the default horizontal range.\n\n        Examples:\n            &gt;&gt;&gt; self._prepare_plot()\n            &gt;&gt;&gt; self.setup_axes()\n        \"\"\"\n        # Hide all axis spines (borders)\n        for spine in self.ax.spines.values():\n            spine.set_color('none')\n\n        # Remove default ticks\n        self.ax.set_xticks([])\n        self.ax.set_yticks([])\n\n        if horiz_range is None:\n            horiz_range = self.horiz_range\n\n        # Compute horizontal range and margin\n        x0, x1 = horiz_range\n        x_range = x1 - x0\n        # You can adjust this value if needed\n        x_margin = 0.2 * x_range\n\n        # Use vertical range computed in _prepare_plot\n        y_min, y_max = self.y_min, self.y_max\n        y_range = y_max - y_min\n\n        # Add a 30% margin below and 60% margin above the signal range\n        if y_range &lt;= 0:\n            # In degenerate cases, ensure a minimum visible height\n            y_margin = 1.0\n        else:\n            y_margin = 0.3 * y_range\n\n        self.ax.set_xlim(horiz_range[0] - x_margin, horiz_range[1] + x_margin)\n        self.ax.set_ylim(self.y_min - y_margin, self.y_max + 1.6 * y_margin)\n\n        # Draw x-axis arrow\n        self.ax.annotate('', xy=(self.ax.get_xlim()[1], 0), xytext=(self.ax.get_xlim()[0], 0),\n                         arrowprops=dict(arrowstyle='-|&gt;', linewidth=1.5, color='black',\n                                         mutation_scale=16, mutation_aspect=0.8, fc='black'))\n\n        # Draw x-axis arrow\n        self.ax.annotate('', xy=(0, self.ax.get_ylim()[1]), xytext=(0, self.ax.get_ylim()[0]),\n                         arrowprops=dict(arrowstyle='-|&gt;', linewidth=1.5, color='black',\n                                         mutation_scale=12, mutation_aspect=2, fc='black'))\n\n        # Prevent labels from being clipped\n        self.fig.tight_layout()\n\n    def draw_ticks(self,\n                tick_size_px=None,\n                xticks=None,\n                yticks=None,\n                xtick_labels='auto',\n                ytick_labels='auto'):\n        \"\"\"\n        Draws tick marks and labels on both x- and y-axes, using automatic or manual configurations.\n        This method is typically called after `draw_impulses()`.\n        This method is usually called internally from `plot()`, but can also be used manually.\n\n        Features:\n        - Adds tick marks and LaTeX-formatted labels.\n        - Integrates impulse positions into xticks automatically, unless explicitly overridden.\n        - Supports:\n            - `pi_mode`: labels as multiples of \u03c0.\n            - `fraction_ticks`: labels as rational fractions.\n            - Hiding y=0 label if x=0 tick is shown (to avoid overlapping at the origin).\n        - Avoids duplicate tick values based on numerical tolerance.\n\n        Notes:\n        - If `xticks_delta` or `yticks_delta` are provided (in constructor), evenly spaced ticks are placed at multiples.\n        - If custom labels are passed and their count does not match the tick list, raises ValueError.\n        - Labels are drawn on white rounded boxes for visibility over plots.\n\n        Args:\n            tick_size_px (int, optional): Length of tick marks in pixels. If None, uses self.tick_size_px.\n            xticks (list or 'auto' or None): X-axis tick positions.\n                - 'auto': automatically computed ticks (even spacing or using xticks_delta).\n                - list: manually specified tick positions.\n                - None: ticks are shown only at Dirac impulse positions.\n            yticks (list or 'auto' or None): Y-axis tick positions.\n                - Same behavior as `xticks`.\n            xtick_labels (list or 'auto' or None): Custom labels for xticks (must match length of xticks).\n            ytick_labels (list or 'auto' or None): Same for yticks.\n\n        Examples:\n            &gt;&gt;&gt; self.draw_ticks(xticks='auto', yticks=[-1, 0, 1], ytick_labels=['-1', '0', '1'])\n        \"\"\"\n\n        # Helper: filter duplicate values with tolerance\n        def unique_sorted(values, tol):\n            unique = []\n            for v in values:\n                if not any(abs(v - u) &lt;= tol for u in unique):\n                    unique.append(v)\n            return sorted(unique)\n\n        # Helper: get impulse locations and amplitudes within range (with periodic extension if needed)\n        def get_impulse_positions_and_areas(t_min, t_max, tol):\n            impulse_positions = []\n            impulse_positions_areas = []\n            if self.impulse_locs:\n                if self.period is None:\n                    # Non-periodic case: keep impulses in visible range\n                    for base_loc, base_area in zip(self.impulse_locs, self.impulse_areas):\n                        if t_min - tol &lt;= base_loc &lt;= t_max + tol:\n                            impulse_positions.append(base_loc)\n                            impulse_positions_areas.append(base_area)\n                else:\n                    # Periodic case: replicate impulses across periods\n                    T = self.period\n                    for base_loc, base_area in zip(self.impulse_locs, self.impulse_areas):\n                        k_min = int(np.floor((t_min - base_loc) / T))\n                        k_max = int(np.ceil((t_max - base_loc) / T))\n                        for k in range(k_min, k_max + 1):\n                            t_k = base_loc + k * T\n                            if t_min - tol &lt;= t_k &lt;= t_max + tol:\n                                impulse_positions.append(t_k)\n                                impulse_positions_areas.append(base_area)\n            # Eliminate duplicates within tolerance\n            unique_pos = []\n            unique_area = []\n            for loc, area in zip(impulse_positions, impulse_positions_areas):\n                if not any(abs(loc - u) &lt;= tol for u in unique_pos):\n                    unique_pos.append(loc)\n                    unique_area.append(area)\n            if unique_pos:\n                idx_sort = np.argsort(unique_pos)\n                impulse_positions = [unique_pos[i] for i in idx_sort]\n                impulse_positions_areas = [unique_area[i] for i in idx_sort]\n            else:\n                impulse_positions, impulse_positions_areas = [], []\n            return impulse_positions, impulse_positions_areas\n\n        # Helper: validate tick list\n        def has_valid_ticks(ticks):\n            if ticks is None:\n                return False\n            try:\n                arr = np.array(ticks)\n                return arr.ndim &gt;= 1 and arr.size &gt;= 1\n            except Exception:\n                return False\n\n        # Helper: generate xticks and labels\n        def generate_xticks(effective_xticks, impulse_positions, tol, t_min, t_max):\n            raw_xticks = []\n            manual_xticks = []\n            manual_xlabels = []\n\n            has_init_xticks = has_valid_ticks(getattr(self, 'xticks', None))\n            xticks_delta = getattr(self, 'xticks_delta', None)  # Nuevo atributo opcional\n\n            if isinstance(effective_xticks, str) and effective_xticks == 'auto':\n                if has_init_xticks:\n                    raw_xticks = list(self.xticks)\n                    if self.xtick_labels is not None:\n                        if len(self.xticks) != len(self.xtick_labels):\n                            raise ValueError(\"xtick_labels and xticks from init must have the same length\")\n                        manual_xticks = list(self.xticks)\n                        manual_xlabels = list(self.xtick_labels)\n                else:\n                    if xticks_delta is not None:\n                        n_left = int(np.floor((0 - t_min) / xticks_delta))\n                        n_right = int(np.floor((t_max - 0) / xticks_delta))\n                        base_ticks = [k * xticks_delta for k in range(-n_left, n_right + 1)]\n                    else:\n                        base_ticks = list(np.linspace(t_min, t_max, 5))\n                    raw_xticks = base_ticks.copy()\n\n                # Add impulses\n                for loc in impulse_positions:\n                    if t_min - tol &lt;= loc &lt;= t_max + tol and not any(abs(loc - x0) &lt;= tol for x0 in raw_xticks):\n                        raw_xticks.append(loc)\n\n            else:\n                if xticks_delta is not None:\n                    warnings.warn(\"xticks_delta will be ignored because xticks not in 'auto' mode\", stacklevel=2)\n                raw_xticks = list(effective_xticks)\n                if xtick_labels not in (None, 'auto'):\n                    if len(raw_xticks) != len(xtick_labels):\n                        raise ValueError(\"xtick_labels and xticks must have the same length\")\n                    manual_xticks = list(raw_xticks)\n                    manual_xlabels = list(xtick_labels)\n                elif self.xtick_labels is not None:\n                    if len(raw_xticks) != len(self.xtick_labels):\n                        raise ValueError(\"xtick_labels and xticks from init must have the same length\")\n                    manual_xticks = list(raw_xticks)\n                    manual_xlabels = list(self.xtick_labels)\n\n                for loc in impulse_positions:\n                    if t_min - tol &lt;= loc &lt;= t_max + tol and not any(abs(loc - x0) &lt;= tol for x0 in raw_xticks):\n                        raw_xticks.append(loc)\n\n            raw_xticks = unique_sorted(raw_xticks, tol)\n\n            # Gnerate labels\n            xlabels = []\n            for x in raw_xticks:\n                label = None\n                for xm, lbl in zip(manual_xticks, manual_xlabels):\n                    if abs(xm - x) &lt;= tol:\n                        label = lbl\n                        break\n                if label is None:\n                    if getattr(self, 'pi_mode', False):\n                        f = Fraction(x / np.pi).limit_denominator(24)\n                        if abs(float(f) * np.pi - x) &gt; tol:\n                            label = f'{x:g}'\n                        elif f == 0:\n                            label = '0'\n                        elif f == 1:\n                            label = r'\\pi'\n                        elif f == -1:\n                            label = r'-\\pi'\n                        else:\n                            num = f.numerator\n                            denom = f.denominator\n                            prefix = '-' if num * denom &lt; 0 else ''\n                            num, denom = abs(num), abs(denom)\n                            if denom == 1:\n                                label = rf\"{prefix}{num}\\pi\"\n                            elif num == 1:\n                                label = rf\"{prefix}\\frac{{\\pi}}{{{denom}}}\"\n                            else:\n                                label = rf\"{prefix}\\frac{{{num}\\pi}}{{{denom}}}\"\n                    elif getattr(self, 'fraction_ticks', False):\n                        f = Fraction(x).limit_denominator(24)\n                        label = f\"{f.numerator}/{f.denominator}\" if f.denominator != 1 else f\"{f.numerator}\"\n                    else:\n                        label = f'{x:g}'\n                xlabels.append(label)\n\n            return raw_xticks, xlabels\n\n        # Helper: generate yticks and labels\n        def generate_yticks(effective_yticks, tol):\n            raw_yticks = []\n            manual_yticks = []\n            manual_ylabels = []\n\n            has_init_yticks = has_valid_ticks(getattr(self, 'yticks', None))\n            ytick_labels = getattr(self, 'ytick_labels', None)\n            ydelta = getattr(self, 'yticks_delta', None)\n\n            if effective_yticks is None:\n                raw_yticks = []\n            elif isinstance(effective_yticks, str) and effective_yticks == 'auto':\n                if has_init_yticks:\n                    raw_yticks = list(self.yticks)\n                    if self.ytick_labels is not None:\n                        if len(self.yticks) != len(self.ytick_labels):\n                            raise ValueError(\"ytick_labels and yticks from init must have the same length\")\n                        manual_yticks = list(self.yticks)\n                        manual_ylabels = list(self.ytick_labels)\n                    if ydelta is not None:\n                        warnings.warn(\"yticks_delta ignored because yticks where specified at init\")\n                else:\n                    if ydelta is not None and ydelta &gt; 0:\n                        y_start = np.ceil(self.y_min / ydelta)\n                        y_end = np.floor(self.y_max / ydelta)\n                        raw_yticks = [k * ydelta for k in range(int(y_start), int(y_end) + 1)]\n                    else:\n                        y0 = np.floor(self.y_min)\n                        y1 = np.ceil(self.y_max)\n                        if abs(y1 - y0) &lt; 1e-6:\n                            raw_yticks = [y0 - 1, y0, y0 + 1]\n                        else:\n                            raw_yticks = list(np.linspace(y0, y1, 3))\n            else:\n                raw_yticks = list(effective_yticks)\n                if ydelta is not None:\n                    warnings.warn(\"yticks_delta ignored because yticks is not in 'auto' mode\")\n\n                if ytick_labels not in (None, 'auto'):\n                    if len(raw_yticks) != len(ytick_labels):\n                        raise ValueError(\"ytick_labels and yticks must have the same length\")\n                    manual_yticks = list(raw_yticks)\n                    manual_ylabels = list(ytick_labels)\n                elif self.ytick_labels is not None:\n                    if len(raw_yticks) != len(self.ytick_labels):\n                        raise ValueError(\"ytick_labels and yticks from init must have the same length\")\n                    manual_yticks = list(raw_yticks)\n                    manual_ylabels = list(self.ytick_labels)\n\n            raw_yticks = unique_sorted(raw_yticks, tol)\n\n            ylabels = []\n            for y in raw_yticks:\n                label = None\n                for ym, lbl in zip(manual_yticks, manual_ylabels):\n                    if abs(ym - y) &lt;= tol:\n                        label = lbl\n                        break\n                if label is None:\n                    if self.pi_mode:\n                        f = Fraction(y / np.pi).limit_denominator(24)\n                        if abs(float(f) * np.pi - y) &gt; tol:\n                            label = f'{y:.3g}'\n                        elif f == 0:\n                            label = '0'\n                        elif f == 1:\n                            label = r'\\pi'\n                        elif f == -1:\n                            label = r'-\\pi'\n                        else:\n                            num = f.numerator\n                            denom = f.denominator\n                            prefix = '-' if num * denom &lt; 0 else ''\n                            num, denom = abs(num), abs(denom)\n                            if denom == 1:\n                                label = rf\"{prefix}{num}\\pi\"\n                            elif num == 1:\n                                label = rf\"{prefix}\\frac{{\\pi}}{{{denom}}}\"\n                            else:\n                                label = rf\"{prefix}\\frac{{{num}\\pi}}{{{denom}}}\"\n                    elif self.fraction_ticks:\n                        f = Fraction(y).limit_denominator(24)\n                        label = f\"{f.numerator}/{f.denominator}\" if f.denominator != 1 else f\"{f.numerator}\"\n                    else:\n                        label = f'{y:.3g}'\n                ylabels.append(label)\n\n            return raw_yticks, ylabels\n\n        # Helper: hide y=0 label if x=0 tick exists\n        def filter_yticks(raw_yticks, ylabels, raw_xticks, tol):\n            has_xtick_zero = any(abs(x) &lt;= tol for x in raw_xticks)\n            if has_xtick_zero:\n                filtered_yticks = []\n                filtered_ylabels = []\n                for y, lbl in zip(raw_yticks, ylabels):\n                    if abs(y) &lt;= tol:\n                        continue\n                    filtered_yticks.append(y)\n                    filtered_ylabels.append(lbl)\n                return filtered_yticks, filtered_ylabels\n            else:\n                return raw_yticks, ylabels\n\n        # Helper: convert pixel length to data coordinates\n        def px_to_data_length(tick_px):\n            origin_disp = self.ax.transData.transform((0, 0))\n            up_disp = origin_disp + np.array([0, tick_px])\n            right_disp = origin_disp + np.array([tick_px, 0])\n            origin_data = np.array(self.ax.transData.inverted().transform(origin_disp))\n            up_data = np.array(self.ax.transData.inverted().transform(up_disp))\n            right_data = np.array(self.ax.transData.inverted().transform(right_disp))\n            dy = up_data[1] - origin_data[1]\n            dx = right_data[0] - origin_data[0]\n            return dx, dy\n\n        # Helper: draw xticks and labels\n        def draw_xticks(raw_xticks, xlabels, impulse_positions, impulse_positions_areas, dx, dy, tol):\n            xlim = self.ax.get_xlim()\n            for x, lbl in zip(raw_xticks, xlabels):\n                if xlim[0] &lt;= x &lt;= xlim[1]:\n                    self.ax.plot([x, x], [0 - dy/2, 0 + dy/2], transform=self.ax.transData,\n                                color='black', linewidth=1.2, clip_on=False)\n                    area = None\n                    for loc, a in zip(impulse_positions, impulse_positions_areas):\n                        if abs(loc - x) &lt;= tol:\n                            area = a\n                            break\n                    y_off = +8 if (area is not None and area &lt; 0) else -8\n                    offset = (-8, y_off) if abs(x) &lt; tol else (0, y_off)\n                    va = 'bottom' if y_off &gt; 0 else 'top'\n                    self.ax.annotate(rf'${lbl}$', xy=(x, 0), xycoords='data',\n                                    textcoords='offset points', xytext=offset,\n                                    ha='center', va=va, fontsize=12, zorder=10,\n                                    bbox=dict(boxstyle='round,pad=0.1', facecolor='white',\n                                            edgecolor='none', alpha=self.alpha))\n\n        # Helper: draw yticks and labels\n        def draw_yticks(raw_yticks, ylabels, dx, dy):\n            ylim = self.ax.get_ylim()\n            for y, lbl in zip(raw_yticks, ylabels):\n                if ylim[0] &lt;= y &lt;= ylim[1]:\n                    self.ax.plot([0 - dx/2, 0 + dx/2], [y, y], transform=self.ax.transData,\n                                color='black', linewidth=1.2, clip_on=False)\n                    offset = (-4, -16) if abs(y) &lt; 1e-10 else (-4, 0)\n                    self.ax.annotate(rf'${lbl}$', xy=(0, y), xycoords='data',\n                                    textcoords='offset points', xytext=offset,\n                                    ha='right', va='center', fontsize=12, zorder=10,\n                                    bbox=dict(boxstyle='round,pad=0.1', facecolor='white',\n                                            edgecolor='none', alpha=self.alpha))\n\n         # === MAIN LOGIC ===\n\n        # 0. Use constructor defaults if nothing passed explicitly\n        effective_xticks = xticks if xticks is not None else getattr(self, 'init_xticks_arg', None)\n        effective_yticks = yticks if yticks is not None else getattr(self, 'init_yticks_arg', None)\n\n        # 1. Determine tick size in pixels\n        tick_px = tick_size_px if tick_size_px is not None else self.tick_size_px\n\n        # 2. Get plotting range and numeric tolerance\n        t_min, t_max = self.horiz_range\n        tol = 1e-8 * max(1.0, abs(t_max - t_min))\n\n        # 3. Get impulse positions in the current range\n        impulse_positions, impulse_positions_areas = get_impulse_positions_and_areas(t_min, t_max, tol)\n\n        # 4. Generate x ticks and labels\n        raw_xticks, xlabels = generate_xticks(effective_xticks, impulse_positions, tol, t_min, t_max)\n\n        # 5. Generate y ticks and labels\n        raw_yticks, ylabels = generate_yticks(effective_yticks, tol)\n\n        # 6. Remove y=0 label if x=0 tick exists\n        raw_yticks, ylabels = filter_yticks(raw_yticks, ylabels, raw_xticks, tol)\n\n        # 7. Convert tick length in px to data coordinates\n        dx, dy = px_to_data_length(tick_px)\n\n        # 8. Draw x-axis ticks and labels\n        draw_xticks(raw_xticks, xlabels, impulse_positions, impulse_positions_areas, dx, dy, tol)\n\n        # 9. Draw y-axis ticks and labels\n        draw_yticks(raw_yticks, ylabels, dx, dy)\n\n\n    def draw_labels(self):\n        \"\"\"\n        Adds axis labels to the x and y axes using the current signal variable and name.\n        This method is typically called after `draw_ticks()`.\n        This method is usually called internally from `plot()`, but can also be used manually.\n\n        This method:\n        - Retrieves the current axis limits.\n        - Places the x-axis label slightly to the right of the horizontal axis arrow.\n        - Places the y-axis label slightly below the top of the vertical axis arrow.\n        - Uses LaTeX formatting for the labels (e.g., \"x(t)\", \"y(\\\\tau)\", etc.).\n        - The labels use the values of `self.xlabel` and `self.ylabel`.\n\n        Notes:\n        - This method is called automatically in `plot()` after drawing ticks and arrows.\n        - Rotation for y-axis label is disabled to keep it horizontal.\n\n        Examples:\n            &gt;&gt;&gt; self.draw_labels()\n        \"\"\"\n        # Get the current x and y axis limits\n        x_lim = self.ax.get_xlim()\n        y_lim = self.ax.get_ylim()\n\n        # X-axis label: slightly to the right of the rightmost x limit\n        x_pos = x_lim[1] - 0.01 * (x_lim[1] - x_lim[0])\n        y_pos = 0.02 * (y_lim[1] - y_lim[0])\n        self.ax.text(x_pos, y_pos, rf'${self.xlabel}$', fontsize=16, ha='right', va='bottom')\n\n        # Y-axis label: slightly below the top y limit (still inside the figure)\n        x_pos = 0.01 * (x_lim[1] - x_lim[0])\n        y_pos = y_lim[1] - 0.1 * (y_lim[1] - y_lim[0])\n        self.ax.text(x_pos, y_pos, rf'${self.ylabel}$', fontsize=16, ha='left', va='bottom', rotation=0)\n\n    def _update_expression_and_func(self, expr, var):\n        \"\"\"\n        Internal helper to update self.expr, self.expr_cont and self.func\n        for plotting, safely removing any DiracDelta terms.\n        \"\"\"\n        self.expr = expr\n        self.var = var\n        self.expr_cont = self._remove_dirac_terms()\n        self.func = sp.lambdify(self.var, self.expr_cont, modules=[\"numpy\", self._get_local_dict()])\n        self.impulse_locs, self.impulse_areas = self._extract_impulses()\n\n    def show(self):\n        \"\"\"\n        Displays or saves the final plot, depending on configuration.\n        This method is typically called after `draw_labels()`.\n        This method is usually called internally from `plot()`, but can also be used manually.\n\n        This method:\n        - Disables the background grid.\n        - Applies tight layout to reduce unnecessary whitespace.\n        - If `self.save_path` is set, saves the figure to the given file (PNG, PDF, etc.).\n        - If `self.show_plot` is True, opens a plot window (interactive view).\n        - Finally, closes the figure to free up memory (especially important in batch plotting).\n\n        Notes:\n        - `self.save_path` and `self.show_plot` are set in the constructor.\n        - If both are enabled, the plot is shown and saved.\n        - The output file format is inferred from the file extension.\n\n        Examples:\n            &gt;&gt;&gt; self.show()  # Typically called at the end of plot()\n        \"\"\"\n        self.ax.grid(False)\n        plt.tight_layout()\n        if self.save_path:\n            self.fig.savefig(self.save_path, dpi=300, bbox_inches='tight')\n        if self.show_plot:\n            plt.show()\n        plt.close(self.fig)\n\n    def plot(self, name=None):\n        \"\"\"\n        Plots the signal specified by name (or the default if defined via expr_str in constructor).\n\n        This method:\n        - Initializes the expression from `expr_str_pending` (if any), only once.\n        - Looks up the signal in the internal dictionary (`self.signal_defs`) using its name.\n        - Sets up symbolic and numeric representations of the signal.\n        - Removes DiracDelta terms from the continuous part.\n        - Extracts impulses and prepares data for plotting.\n        - Calls the full sequence: axis setup, function drawing, impulses, ticks, labels, and final display/save.\n\n        Args:\n            name (str, optional): Name of the signal to plot, e.g., \"x1\". If None and `expr_str` was given at init,\n                        it uses the last-added expression.\n\n        Raises:\n            ValueError: If the signal is not defined or its variable cannot be determined.\n\n        Examples:\n            &gt;&gt;&gt; SignalPlotter(\"x(t)=rect(t-1)\").plot()\n            &gt;&gt;&gt; sp1 = SignalPlotter(\"x(t)=rect(t-1)\", period=2)\n            &gt;&gt;&gt; sp1.plot(\"x\")\n            &gt;&gt;&gt; sp2 = SignalPlotter()\n            &gt;&gt;&gt; sp2.add_signal(\"x(t) = rect(t)\")\n            &gt;&gt;&gt; sp2.plot(\"x\")\n        \"\"\"\n        # Initialize from expr_str (only once), if provided at construction\n        if (hasattr(self, 'expr_str_pending') and \n            self.expr_str_pending is not None and \n            isinstance(self.expr_str_pending, str) and \n            not getattr(self, '_initialized_from_expr', False)):\n            expr_str = self.expr_str_pending\n            self._initialized_from_expr = True\n            self.add_signal(expr_str, period=self.period)\n            name = list(self.signal_defs.keys())[-1]\n\n        if name:\n            if name not in self.signal_defs:\n                raise ValueError(f\"Signal '{name}' is not defined.\")\n            self.current_name = name\n            self.func_name = name\n\n            # Use declared variable or infer it\n            expr = self.signal_defs[name]\n            var = self.var_symbols.get(name, None)\n            if var is None:\n                free_vars = list(expr.free_symbols)\n                if not free_vars:\n                    raise ValueError(f\"Could not determine the variable for signal '{name}'.\")\n                var = free_vars[0]\n\n            # Update expression and lambdified function, remove Dirac terms, extract impulses\n            self._update_expression_and_func(expr, var)\n\n            # Use declared variable or infer it\n            expr = self.signal_defs[name]\n            var = self.var_symbols.get(name, None)\n            if var is None:\n                free_vars = list(expr.free_symbols)\n                if not free_vars:\n                    raise ValueError(f\"Could not determine the variable for signal '{name}'.\")\n                var = free_vars[0]\n\n            # Update expression and lambdified function, remove Dirac terms, extract impulses\n            self._update_expression_and_func(expr, var)\n\n            # Set axis labels\n            self.xlabel = str(var)\n            self.ylabel = f\"{self.func_name}({self.xlabel})\"\n            if hasattr(self, 'custom_labels') and self.func_name in self.custom_labels:\n                self.ylabel = self.custom_labels[self.func_name]\n\n            # Time discretization for plotting\n            self.t_vals = np.linspace(*self.horiz_range, self.num_points)\n\n            # Create figure and compute y-range\n            self.fig, self.ax = plt.subplots(figsize=self.figsize)\n            self._prepare_plot()\n\n        # Draw all components of the plot\n        self.setup_axes()\n        self.draw_function()\n        self.draw_impulses()\n        self.ax.relim()\n        self.ax.autoscale_view()\n        self.draw_ticks()\n        self.draw_labels()\n        self.show()\n\n    # Definir las transformaciones a nivel global para uso posterior\n    # def _get_transformations(self):\n    #     return self.transformations\n\n    ## Convolution-specific methods\n\n    def _setup_figure(self):\n        \"\"\"\n        Initializes the Matplotlib figure and axes for plotting.\n\n        This method:\n        - Creates a new figure and axis using the configured `figsize`.\n        - Calls `_prepare_plot()` to compute vertical bounds for plotting based on the signal.\n        - Applies padding to the layout using `subplots_adjust` to avoid clipping of labels and arrows.\n\n        Notes:\n        - This method is typically used in convolution plotting routines where a clean figure is needed.\n        - For standard plotting, `plot()` uses its own setup sequence and may not rely on this method.\n\n        Examples:\n            &gt;&gt;&gt; self._setup_figure()\n            &gt;&gt;&gt; self.draw_function()\n            &gt;&gt;&gt; self.show()\n        \"\"\"\n        self.fig, self.ax = plt.subplots(figsize=self.figsize)\n        self._prepare_plot()\n        self.fig.subplots_adjust(right=0.9, top=0.85, bottom=0.15)\n\n\n    def plot_convolution_view(self, expr_str, t_val, label=None, tau=None, t=None):\n        \"\"\"\n        Plots an intermediate signal in the convolution process, such as x(t\u2212\u03c4), h(\u03c4+t), etc.\n\n        This method:\n        - Substitutes the convolution variable t with a fixed value `t_val` in a symbolic expression.\n        - Evaluates the resulting signal in terms of \u03c4.\n        - Optionally adjusts x-axis direction and labels if the expression has a form like (t \u2212 \u03c4) or (t + \u03c4).\n        - Automatically handles periodic xtick reversal or shift based on convolution expression.\n        - Renders the function using existing plot methods (function, impulses, ticks, etc.).\n\n        Args:\n            expr_str (str): A symbolic expression involving \u03c4 and t, e.g. \"x(t - tau)\" or \"h(t + tau)\".\n                        The base signal must already be defined with `add_signal(...)`.\n            t_val (float): The value of the time variable `t` at which the expression is evaluated.\n            label (str, optional): Custom y-axis label to display (default is derived from the expression).\n            tau (sympy.Symbol or str, optional): Symbol to use as integration variable (default: 'tau').\n            t (sympy.Symbol or str, optional): Symbol used in shifting (default: 't').\n\n        Raises:\n            ValueError: If the base signal is not defined or the expression format is invalid.\n\n        Examples:\n            &gt;&gt;&gt; sp = SignalPlotter(xticks=[-1, 0, 3], num_points=200, fraction_ticks=True)\n            &gt;&gt;&gt; sp.add_signal(\"x(t)=exp(-2t)*u(t)\")\n            &gt;&gt;&gt; sp.add_signal(\"h(t)=u(t)\")\n            &gt;&gt;&gt; sp.plot_convolution_view(\"x(t - tau)\", t_val=1)\n            &gt;&gt;&gt; sp.plot_convolution_view(\"h(t + tau)\", t_val=2, tau='lambda', t='omega')\n        \"\"\"\n        import re\n        local_dict = self._get_local_dict()\n\n        # Define symbolic variables for \u03c4 and t\n        if tau is None:\n            tau = local_dict.get('tau')\n        elif isinstance(tau, str):\n            tau = sp.Symbol(tau)\n        if t is None:\n            t = local_dict.get('t')\n        elif isinstance(t, str):\n            t = sp.Symbol(t)\n\n        local_dict.update({'tau': tau, 't': t, str(tau): tau, str(t): t})\n\n        # Extract base signal name and ensure it's defined\n        if \"(\" in expr_str:\n            name = expr_str.split(\"(\")[0].strip()\n            if name not in self.signal_defs:\n                raise ValueError(f\"Signal '{name}' is not defined.\")\n            expr_base = self.signal_defs[name]\n            var_base = self.var_symbols.get(name, t)\n        else:\n            raise ValueError(\"Invalid expression: expected something like 'x(t - tau)'.\")\n\n        # Parse expression and apply to base\n        parsed_expr = parse_expr(expr_str.replace(name, \"\", 1), local_dict)\n        expr = expr_base.subs(var_base, parsed_expr)\n\n        # Analyze structure to adapt axis\n        xticks = self.init_xticks_arg\n        horiz_range = self.horiz_range\n        xticks_custom = None\n        xtick_labels_custom = None\n\n        if isinstance(parsed_expr, sp.Expr):\n            diff1 = parsed_expr - tau\n            if diff1.has(t):\n                diff2 = parsed_expr - t\n                coef = diff2.coeff(tau)\n                if coef == -1:\n                    # Case t - tau \u21d2 reverse x-axis\n                    if xticks == 'auto':\n                        xticks_custom = [t_val]\n                        xtick_labels_custom = [sp.latex(t)]\n                    elif isinstance(xticks, (list, tuple)):\n                        xticks_custom = [t_val - v for v in xticks][::-1]\n                        xtick_labels_custom = [\n                            f\"{sp.latex(t)}\" if v == 0 else f\"{sp.latex(t)}{'-' if v &gt; 0 else '+'}{abs(v)}\"\n                            for v in xticks\n                        ][::-1]\n                    horiz_range = (t_val - np.array(self.horiz_range)[::-1]).tolist()\n                elif coef == 1:\n                    # Case t + tau \u21d2 shift axis\n                    if xticks == 'auto':\n                        xticks_custom = [- t_val]\n                        xtick_labels_custom = [sp.latex(t)]\n                    elif isinstance(xticks, (list, tuple)):\n                        xticks_custom = [- t_val + v for v in xticks]\n                        xtick_labels_custom = [\n                            f\"-{sp.latex(t)}\" if v == 0 else f\"-{sp.latex(t)}{'+' if v &gt; 0 else '-'}{abs(v)}\"\n                            for v in xticks\n                        ]\n                    horiz_range = (np.array(self.horiz_range) - t_val).tolist()\n\n        # Evaluate the expression at t = t_val\n        expr_evaluated = expr.subs(t, t_val)\n\n        # Update expression and lambdified function\n        self._update_expression_and_func(expr_evaluated, tau)\n\n        # Axis labels\n        self.xlabel = sp.latex(tau)\n        tau_str = sp.latex(tau)\n        t_str = sp.latex(t)\n        self.ylabel = label if label else expr_str.replace(\"tau\", tau_str).replace(\"t\", t_str)\n\n        # Discretize time\n        self.t_vals = np.linspace(*horiz_range, self.num_points)\n\n        # Prepare and render plot\n        self._setup_figure()\n        self.setup_axes(horiz_range)\n        self.draw_function(horiz_range)\n        self.draw_impulses()\n        self.draw_ticks(xticks=xticks_custom, xtick_labels=xtick_labels_custom)\n        self.draw_labels()\n        self.show()\n\n\n\n    def plot_convolution_steps(self, x_name, h_name, t_val, tau=None, t=None):\n        \"\"\"\n        Plots four key signals involved in a convolution step at a fixed time `t_val`:\n        x(tau), x(t-tau), h(tau), h(t-tau)., all in terms of \u03c4.\n\n        This method is particularly useful for visualizing the time-reversed and shifted\n        versions of the input signals used in the convolution integral.\n\n        Notes:\n        - The horizontal axis is adjusted for time-reversed signals (e.g., t\u2212\u03c4),\n        and tick labels are shifted accordingly.\n        - Four separate plots are generated in sequence, with labels and axes automatically set.\n\n        Args:\n            x_name (str): Name of the signal x, previously defined with `add_signal(...)`.\n            h_name (str): Name of the signal h, previously defined with `add_signal(...)`.\n            t_val (float): The fixed time t at which the convolution step is evaluated.\n            tau (sympy.Symbol or str, optional): Symbol for the integration variable (default: 'tau').\n            t (sympy.Symbol or str, optional): Symbol for the time variable (default: 't').\n\n        Examples:\n            &gt;&gt;&gt; sp = SignalPlotter()\n            &gt;&gt;&gt; sp.add_signal(\"x(t)=sinc(t)\")\n            &gt;&gt;&gt; sp.add_signal(\"h(t)=sinc(t/2)\")\n            &gt;&gt;&gt; sp.plot_convolution_steps(\"x\", \"h\", t_val=1)\n        \"\"\"\n        local_dict = self._get_local_dict()\n\n        # Use default symbols if not provided\n        if tau is None:\n            tau = local_dict.get('tau')\n        elif isinstance(tau, str):\n            tau = sp.Symbol(tau)\n\n        if t is None:\n            t = local_dict.get('t')\n        elif isinstance(t, str):\n            t = sp.Symbol(t)\n\n        # Evaluate x(\u03c4) and h(\u03c4) using their respective symbolic variable\n        x_expr = self.signal_defs[x_name].subs(self.var_symbols[x_name], tau)\n        h_expr = self.signal_defs[h_name].subs(self.var_symbols[h_name], tau)\n\n        # Compute x(t\u2212\u03c4) and h(t\u2212\u03c4), and substitute t = t_val\n        x_shift = x_expr.subs(tau, t - tau).subs(t, t_val)\n        h_shift = h_expr.subs(tau, t - tau).subs(t, t_val)\n\n        # Convert to LaTeX strings for labeling\n        tau_str = sp.latex(tau)\n        t_str = sp.latex(t)\n\n        # Generate custom xticks and labels for the shifted signals\n        xticks = self.init_xticks_arg\n        if xticks == 'auto':\n            xticks_shifted = [t_val]\n            xtick_labels_shifted = [f\"{t_str}\"]\n        elif isinstance(xticks, (list, tuple)):\n            xticks_shifted = [t_val - v for v in xticks]\n            xtick_labels_shifted = []\n            for v in xticks:\n                delta = - v\n                if delta == 0:\n                    label = fr\"{t_str}\"\n                elif delta &gt; 0:\n                    label = fr\"{t_str}+{delta}\"\n                else:\n                    label = fr\"{t_str}{delta}\"  # delta is already negative\n                xtick_labels_shifted.append(label)\n        else:\n            xticks_shifted = None\n            xtick_labels_shifted = None\n\n        horiz_range = self.horiz_range\n        # Compute reversed horizontal range for time-reversed signals\n        horiz_range_shifted = t_val - np.array(horiz_range)[::-1]\n\n        # Define all 4 signals to be plotted with labels and optional custom ticks\n        items = [\n            (x_expr, fr\"{x_name}({tau_str})\", None, None, horiz_range),\n            (h_expr, fr\"{h_name}({tau_str})\", None, None, horiz_range),\n            (x_shift, fr\"{x_name}({t_str}-{tau_str})\", xticks_shifted, xtick_labels_shifted, horiz_range_shifted),\n            (h_shift, fr\"{h_name}({t_str}-{tau_str})\", xticks_shifted, xtick_labels_shifted, horiz_range_shifted),\n        ]\n\n        for expr, label, xticks_custom, xtick_labels_custom, horiz_range_custom in items:\n            # Prepare expression and plot configuration\n            self._update_expression_and_func(expr, tau)\n            self.xlabel = fr\"\\{tau}\"\n            self.ylabel = label\n            self.t_vals = np.linspace(*horiz_range_custom, self.num_points)\n\n            self._setup_figure()\n            self.setup_axes(horiz_range_custom)\n            self.draw_function(horiz_range_custom)\n            self.draw_impulses()\n            self.draw_ticks(xticks=xticks_custom, xtick_labels=xtick_labels_custom)\n            self.draw_labels()\n            self.show()\n\n    def plot_convolution_result(self, x_name, h_name, num_points=None, show_expr=False):\n        \"\"\"\n        Computes and plots the convolution result y(t) = (x * h)(t) between two signals x(t) and h(t).\n\n        This method automatically:\n        - Detects if either x(\u03c4) or h(t\u2212\u03c4) consists only of Dirac deltas, and applies the convolution property for impulses.\n        - Otherwise, performs numerical integration over \u03c4 for a given range of t values.\n        - Displays the resulting function y(t), including impulses if present.\n\n        Notes:\n        - Impulse responses are handled symbolically, while general functions are integrated numerically.\n        - Uses scipy.integrate.quad for general convolution integrals.\n\n        Args:\n            x_name (str): Name of the signal x(t), previously defined via `add_signal(...)`.\n            h_name (str): Name of the signal h(t), previously defined via `add_signal(...)`.\n            num_points (int, optional): Number of time samples to compute for numerical integration. Defaults to self.num_points.\n            show_expr (bool, optional): Reserved for future use; currently unused.\n        \"\"\"\n\n        t = sp.Symbol('t')\n        tau = sp.Symbol('tau')\n\n        if num_points is None:\n            num_points = self.num_points\n\n        x_expr = self.signal_defs[x_name]\n        h_expr = self.signal_defs[h_name]\n        var_x = self.var_symbols[x_name]\n        var_h = self.var_symbols[h_name]\n\n        x_tau_expr = x_expr.subs(var_x, tau)\n        h_t_tau_expr = h_expr.subs(var_h, t - tau)\n\n        local_dict = self._get_local_dict()\n        t_vals = np.linspace(*self.horiz_range, num_points)\n        y_vals = []\n\n        # Case 1: Dirac in x(t)\n        if x_tau_expr.has(sp.DiracDelta):\n            y_expr = 0\n            for term in x_tau_expr.as_ordered_terms():\n                if term.has(sp.DiracDelta):\n                    args = term.args if term.func == sp.Mul else [term]\n                    scale = 1\n                    for a in args:\n                        if a.func == sp.DiracDelta:\n                            delta_arg = a.args[0]\n                        else:\n                            scale *= a\n                    shift = sp.solve(delta_arg, tau)\n                    if shift:\n                        y_expr += scale * h_expr.subs(var_h, t - shift[0])\n\n            # Extract impulses from y_expr\n            impulse_locs = []\n            impulse_areas = []\n            for term in y_expr.as_ordered_terms():\n                if term.has(sp.DiracDelta):\n                    args = term.args if term.func == sp.Mul else [term]\n                    area = 1\n                    shift = 0\n                    for a in args:\n                        if a.func == sp.DiracDelta:\n                            sol = sp.solve(a.args[0], t)\n                            if sol:\n                                shift = float(sol[0])\n                        else:\n                            area *= a\n                    impulse_locs.append(shift)\n                    impulse_areas.append(float(area))\n\n            self._update_expression_and_func(y_expr, t)\n            self.impulse_locs = impulse_locs\n            self.impulse_areas = impulse_areas\n\n        # Case 2: Dirac in h(t)\n        elif h_t_tau_expr.has(sp.DiracDelta):\n            y_expr = 0\n            for term in h_t_tau_expr.as_ordered_terms():\n                if term.has(sp.DiracDelta):\n                    args = term.args if term.func == sp.Mul else [term]\n                    scale = 1\n                    for a in args:\n                        if a.func == sp.DiracDelta:\n                            delta_arg = a.args[0]\n                        else:\n                            scale *= a\n                    shift = sp.solve(delta_arg, tau)\n                    if shift:\n                        y_expr += scale * x_tau_expr.subs(tau, shift[0])\n\n            impulse_locs = []\n            impulse_areas = []\n            for term in y_expr.as_ordered_terms():\n                if term.has(sp.DiracDelta):\n                    args = term.args if term.func == sp.Mul else [term]\n                    area = 1\n                    shift = 0\n                    for a in args:\n                        if a.func == sp.DiracDelta:\n                            sol = sp.solve(a.args[0], t)\n                            if sol:\n                                shift = float(sol[0])\n                        else:\n                            area *= a\n                    impulse_locs.append(shift)\n                    impulse_areas.append(float(area))\n\n            self._update_expression_and_func(y_expr, t)\n            self.impulse_locs = impulse_locs\n            self.impulse_areas = impulse_areas\n\n        # Case 3: General convolution via numerical integration\n        else:\n            x_func_tau = sp.lambdify(tau, x_tau_expr, modules=[\"numpy\", local_dict])\n\n            def h_func_tau_shifted(tau_val, t_val):\n                h_t_tau = h_t_tau_expr.subs(t, t_val)\n                h_func = sp.lambdify(tau, h_t_tau, modules=[\"numpy\", local_dict])\n                return h_func(tau_val)\n\n            support_x = self.horiz_range\n            support_h = self.horiz_range\n\n            for t_val in t_vals:\n                a = max(support_x[0], t_val - support_h[1])\n                b = min(support_x[1], t_val - support_h[0])\n                if a &gt;= b:\n                    y_vals.append(0)\n                    continue\n                integrand = lambda tau_val: x_func_tau(tau_val) * h_func_tau_shifted(tau_val, t_val)\n                try:\n                    val, _ = integrate.quad(integrand, a, b)\n                except Exception:\n                    val = 0\n                y_vals.append(val)\n\n            self.func = lambda t_: np.interp(t_, t_vals, y_vals)\n            self.impulse_locs = []\n            self.impulse_areas = []\n            self.expr = None\n\n        # Final settings and plot\n        self.t_vals = t_vals\n        self.xlabel = \"t\"\n        self.ylabel = r\"y(t)\"\n\n        self._setup_figure()\n        self.setup_axes()\n        self.draw_function()\n        self.draw_impulses()\n        self.draw_ticks()\n        self.draw_labels()\n        self.show()\n</code></pre>"},{"location":"reference/#signalblocks.SignalPlotter.SignalPlotter.__init__","title":"<code>__init__(expr_str=None, horiz_range=(-5, 5), vert_range=None, period=None, num_points=1000, figsize=(8, 3), tick_size_px=5, xticks='auto', yticks='auto', xtick_labels=None, ytick_labels=None, xticks_delta=None, yticks_delta=None, pi_mode=False, fraction_ticks=False, save_path=None, show_plot=True, color='black', alpha=0.5)</code>","text":"<p>(Private) Creator of the SignalPlotter class.</p> Source code in <code>signalblocks\\SignalPlotter.py</code> <pre><code>def __init__(\n    self,\n    expr_str=None, \n    horiz_range=(-5, 5),\n    vert_range=None,\n    period=None,\n    num_points=1000,\n    figsize=(8, 3), \n    tick_size_px=5,\n    xticks='auto',\n    yticks='auto',\n    xtick_labels=None,\n    ytick_labels=None,\n    xticks_delta=None,\n    yticks_delta=None,\n    pi_mode=False,\n    fraction_ticks=False,\n    save_path=None, \n    show_plot=True,\n    color='black', \n    alpha=0.5 \n):\n    \"\"\"\n    (Private) Creator of the SignalPlotter class.\n    \"\"\"\n    self.signal_defs = {}\n    self.var_symbols = {}\n    self.current_name = None\n    self.horiz_range = horiz_range\n    self.vert_range = vert_range\n    self.num_points = num_points\n    self.figsize = figsize\n    self.tick_size_px = tick_size_px\n    self.color = color\n    self.alpha = alpha\n    self.period = period\n    self.save_path = save_path\n    self.show_plot = show_plot\n\n    self.fraction_ticks = fraction_ticks\n\n    # Preserve original tick arguments to differentiate None / [] / 'auto'\n    self.init_xticks_arg = xticks\n    self.init_yticks_arg = yticks\n\n    if isinstance(xticks, (list, tuple, np.ndarray)) and len(xticks) &gt; 0:\n        self.xticks = np.array(xticks)\n    else:\n        self.xticks = None\n    if isinstance(yticks, (list, tuple, np.ndarray)) and len(yticks) &gt; 0:\n        self.yticks = np.array(yticks)\n    else:\n        self.yticks = None\n\n    self.pi_mode = pi_mode\n\n    self.xtick_labels = xtick_labels\n    self.ytick_labels = ytick_labels\n\n    if self.xtick_labels is not None:\n        if self.xticks is None:\n            raise ValueError(\"xtick_labels provided without xticks positions\")\n        if len(self.xtick_labels) != len(self.xticks):\n            raise ValueError(\"xtick_labels and xticks must have the same length\")\n    if self.ytick_labels is not None:\n        if self.yticks is None:\n            raise ValueError(\"ytick_labels provided without yticks positions\")\n        if len(self.ytick_labels) != len(self.yticks):\n            raise ValueError(\"ytick_labels and yticks must have the same length\")\n\n    self.xticks_delta = xticks_delta\n    self.yticks_delta = yticks_delta\n\n    self.expr_str_pending = expr_str  # Expression to initialize later if plot() is called first\n\n    self.transformations = (standard_transformations + (implicit_multiplication_application,))\n</code></pre>"},{"location":"reference/#signalblocks.SignalPlotter.SignalPlotter.add_signal","title":"<code>add_signal(expr_str, label=None, period=None)</code>","text":"<p>Adds a new signal to the internal dictionary for later plotting. - The expression is parsed symbolically using SymPy. - If other signals are referenced, their definitions are recursively substituted. - If <code>period</code> is set, the signal will be expanded as a sum of time-shifted versions over the full horizontal range.</p> <p>Parameters:</p> Name Type Description Default <code>expr_str</code> <code>str</code> <p>Signal definition in the form \"name(var) = expression\",</p> required <p>e.g. \"x(t) = rect(t) + delta(t-1)\". The expression may include previously defined signals.     label (str, optional): Custom label for the vertical axis when plotting this signal.     period (float, optional): If provided, the signal will be treated as periodic with this period.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sp = SignalPlotter(horiz_range=(-1, 1), fraction_ticks=True, figsize=(12, 4))\n&gt;&gt;&gt; sp.add_signal(\"x1(t) = tri(t)\")\n&gt;&gt;&gt; sp.add_signal(\"x2(t) = delta(t)\", period=0.2)\n&gt;&gt;&gt; sp.add_signal(\"x3(t) = x1(t) * (1 + x2(t))\", label=\"x_3(t)\")\n&gt;&gt;&gt; sp.plot(\"x3\")\n&gt;&gt;&gt; sp.add_signal(\"x4(t) = exp((-2+j*8*pi)*t)*u(t)\")\n&gt;&gt;&gt; sp.add_signal(\"x5(t) = re(x4(t))\", label=\"\\Re\\{x_4(t)\\}\")\n&gt;&gt;&gt; sp.plot('x5')\n</code></pre> Source code in <code>signalblocks\\SignalPlotter.py</code> <pre><code>def add_signal(self, expr_str, label=None, period=None):\n    \"\"\"\n    Adds a new signal to the internal dictionary for later plotting.\n    - The expression is parsed symbolically using SymPy.\n    - If other signals are referenced, their definitions are recursively substituted.\n    - If `period` is set, the signal will be expanded as a sum of time-shifted versions over the full horizontal range.\n\n    Args:\n        expr_str (str): Signal definition in the form \"name(var) = expression\",\n    e.g. \"x(t) = rect(t) + delta(t-1)\". The expression may include previously defined signals.\n        label (str, optional): Custom label for the vertical axis when plotting this signal.\n        period (float, optional): If provided, the signal will be treated as periodic with this period.\n\n    Examples:\n        &gt;&gt;&gt; sp = SignalPlotter(horiz_range=(-1, 1), fraction_ticks=True, figsize=(12, 4))\n        &gt;&gt;&gt; sp.add_signal(\"x1(t) = tri(t)\")\n        &gt;&gt;&gt; sp.add_signal(\"x2(t) = delta(t)\", period=0.2)\n        &gt;&gt;&gt; sp.add_signal(\"x3(t) = x1(t) * (1 + x2(t))\", label=\"x_3(t)\")\n        &gt;&gt;&gt; sp.plot(\"x3\")\n        &gt;&gt;&gt; sp.add_signal(\"x4(t) = exp((-2+j*8*pi)*t)*u(t)\")\n        &gt;&gt;&gt; sp.add_signal(\"x5(t) = re(x4(t))\", label=\"\\Re\\{x_4(t)\\}\")\n        &gt;&gt;&gt; sp.plot('x5')\n    \"\"\"\n    m = re.match(r\"^(?P&lt;fn&gt;\\w+)\\((?P&lt;vr&gt;\\w+)\\)\\s*=\\s*(?P&lt;ex&gt;.+)$\", expr_str)\n\n    replacements = {'\\\\omega': '\u03c9', '\\\\tau': '\u03c4'}\n    for latex_var, unicode_var in replacements.items():\n        expr_str = expr_str.replace(latex_var, unicode_var)\n    m = re.match(r\"^(?P&lt;fn&gt;\\w+)\\((?P&lt;vr&gt;\\w+)\\)\\s*=\\s*(?P&lt;ex&gt;.+)$\", expr_str)\n\n    name = m.group('fn')\n    var = m.group('vr')\n    body = m.group('ex')\n\n    if var not in self.var_symbols:\n        self.var_symbols[var] = sp.Symbol(var)\n    var_sym = self.var_symbols[var]\n\n    local_dict = self._get_local_dict()\n    for other_name in self.signal_defs:\n        local_dict[other_name] = sp.Function(other_name)\n\n    transformations = standard_transformations + (implicit_multiplication_application,)\n    parsed_expr = parse_expr(body, local_dict=local_dict, transformations=transformations)\n\n    for other_name, other_expr in self.signal_defs.items():\n        f = sp.Function(other_name)\n        matches = parsed_expr.find(f)\n        for call in matches:\n            if isinstance(call, sp.Function):\n                arg = call.args[0]\n                replaced = other_expr.subs(var_sym, arg)\n                parsed_expr = parsed_expr.subs(call, replaced)\n\n    self.signal_defs[name] = parsed_expr\n    self.var_symbols[name] = var_sym\n\n    if label is not None:\n        if not hasattr(self, 'custom_labels'):\n            self.custom_labels = {}\n        self.custom_labels[name] = label\n\n    if period is not None:\n        if not hasattr(self, 'signal_periods'):\n            self.signal_periods = {}\n        self.signal_periods[name] = period\n\n        # Expand signal as sum of shifts within range\n        horiz_min, horiz_max = self.horiz_range\n        num_periods = int(np.ceil((horiz_max - horiz_min) / period))\n        k_range = range(-num_periods - 2, num_periods + 3)  # m\u00e1rgenes extra\n\n        # Expanded as sum of shifted expressions (in SymPy)\n        expanded_expr = sum(parsed_expr.subs(var_sym, var_sym - period * k) for k in k_range)\n\n        self.signal_defs[name] = expanded_expr\n    else:\n        self.signal_defs[name] = parsed_expr\n</code></pre>"},{"location":"reference/#signalblocks.SignalPlotter.SignalPlotter.draw_function","title":"<code>draw_function(horiz_range=None)</code>","text":"<p>Plots the continuous part of the signal over the specified horizontal range. This method is typically called after <code>setup_axes()</code>. This method is usually called internally from <code>plot()</code>, but can also be used manually.</p> <p>This method: - Evaluates the function defined in <code>self.func</code> across <code>self.t_vals</code>. - Plots the result as a smooth curve using the configured color and linewidth. - Automatically detects and adds ellipsis (\"\u22ef\") on the left/right ends if:     - The signal is marked as periodic, or     - Significant energy exists just outside the plotting range.</p> <p>Notes: - This method does not draw delta impulses. Use <code>draw_impulses()</code> for that. - Ellipsis are drawn at 5% beyond the plot edges when appropriate.</p> <p>Parameters:</p> Name Type Description Default <code>horiz_range</code> <code>tuple</code> <p>Tuple (t_min, t_max) to override the default horizontal range. If None, uses <code>self.horiz_range</code>.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; self.draw_function()\n&gt;&gt;&gt; self.draw_impulses()  # to add deltas on top of the curve\n</code></pre> Source code in <code>signalblocks\\SignalPlotter.py</code> <pre><code>def draw_function(self, horiz_range=None):\n    \"\"\"\n    Plots the continuous part of the signal over the specified horizontal range.\n    This method is typically called after `setup_axes()`.\n    This method is usually called internally from `plot()`, but can also be used manually.\n\n    This method:\n    - Evaluates the function defined in `self.func` across `self.t_vals`.\n    - Plots the result as a smooth curve using the configured color and linewidth.\n    - Automatically detects and adds ellipsis (\"\u22ef\") on the left/right ends if:\n        - The signal is marked as periodic, or\n        - Significant energy exists just outside the plotting range.\n\n    Notes:\n    - This method does not draw delta impulses. Use `draw_impulses()` for that.\n    - Ellipsis are drawn at 5% beyond the plot edges when appropriate.\n\n    Args:\n        horiz_range (tuple, optional): Tuple (t_min, t_max) to override the default horizontal range. If None, uses `self.horiz_range`.\n\n    Examples:\n        &gt;&gt;&gt; self.draw_function()\n        &gt;&gt;&gt; self.draw_impulses()  # to add deltas on top of the curve\n    \"\"\"\n\n    if horiz_range is None:\n        horiz_range = self.horiz_range\n\n    t0, t1 = horiz_range\n    t_plot = self.t_vals\n    y_plot = self._eval_func_array(t_plot)\n\n    # Assure arrays and format\n    t_plot = np.array(t_plot)\n    y_plot = np.array(y_plot)\n    if y_plot.ndim == 0:\n        y_plot = np.full_like(t_plot, y_plot, dtype=float)\n\n    # Plot curve\n    self.ax.plot(t_plot, y_plot, color=self.color, linewidth=2.5, zorder=5)\n\n    # Decide whether to draw ellipsis\n    delta = (t1 - t0) * 0.05\n    tol = 1e-3\n    span = t1 - t0\n    draw_left = draw_right = False\n\n    # Show alwais if periodic\n    if hasattr(self, 'signal_periods') and self.current_name in self.signal_periods:\n        draw_left = draw_right = True\n    else:\n        N = max(10, int(0.05 * self.num_points))\n        xs_left = np.linspace(t0 - 0.05 * span, t0, N)\n        ys_left = np.abs(self._eval_func_array(xs_left))\n        if np.trapz(ys_left, xs_left) &gt; tol:\n            draw_left = True\n\n        xs_right = np.linspace(t1, t1 + 0.05 * span, N)\n        ys_right = np.abs(self._eval_func_array(xs_right))\n        if np.trapz(ys_right, xs_right) &gt; tol:\n            draw_right = True\n\n    # Draw ellipsis if needed\n    y_mid = (self.y_min + 2 * self.y_max) / 3\n    if draw_left:\n        self.ax.text(t0 - delta, y_mid, r'$\\cdots$', ha='left', va='center',\n                    color=self.color, fontsize=14, zorder=10)\n    if draw_right:\n        self.ax.text(t1 + delta, y_mid, r'$\\cdots$', ha='right', va='center',\n                    color=self.color, fontsize=14, zorder=10)\n</code></pre>"},{"location":"reference/#signalblocks.SignalPlotter.SignalPlotter.draw_impulses","title":"<code>draw_impulses()</code>","text":"<p>Draws Dirac delta impulses at the extracted positions and amplitudes. This method is typically called after <code>draw_functions()</code>. This method is usually called internally from <code>plot()</code>, but can also be used manually.</p> <p>This method: - Iterates over the list of impulse locations (<code>self.impulse_locs</code>) and their corresponding amplitudes (<code>self.impulse_areas</code>). - Calls <code>_draw_single_impulse()</code> for each impulse located within the current horizontal plotting range (<code>self.horiz_range</code>).</p> <p>Notes: - This method only draws impulses that are visible within the plotting window. - Periodicity is not assumed. Use <code>add_signal(..., period=...)</code> to manually expand periodic impulses. - The drawing includes both a vertical arrow and a bold label showing the impulse area.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; self.draw_function()\n&gt;&gt;&gt; self.draw_impulses()\n</code></pre> Source code in <code>signalblocks\\SignalPlotter.py</code> <pre><code>def draw_impulses(self):\n    \"\"\"\n    Draws Dirac delta impulses at the extracted positions and amplitudes.\n    This method is typically called after `draw_functions()`.\n    This method is usually called internally from `plot()`, but can also be used manually.\n\n    This method:\n    - Iterates over the list of impulse locations (`self.impulse_locs`)\n    and their corresponding amplitudes (`self.impulse_areas`).\n    - Calls `_draw_single_impulse()` for each impulse located within\n    the current horizontal plotting range (`self.horiz_range`).\n\n    Notes:\n    - This method only draws impulses that are visible within the plotting window.\n    - Periodicity is not assumed. Use `add_signal(..., period=...)` to manually expand periodic impulses.\n    - The drawing includes both a vertical arrow and a bold label showing the impulse area.\n\n    Examples:\n        &gt;&gt;&gt; self.draw_function()\n        &gt;&gt;&gt; self.draw_impulses()\n    \"\"\"\n    t_min, t_max = self.horiz_range\n    for t0, amp in zip(self.impulse_locs, self.impulse_areas):\n        if t_min &lt;= t0 &lt;= t_max:\n            self._draw_single_impulse(t0, amp)\n</code></pre>"},{"location":"reference/#signalblocks.SignalPlotter.SignalPlotter.draw_labels","title":"<code>draw_labels()</code>","text":"<p>Adds axis labels to the x and y axes using the current signal variable and name. This method is typically called after <code>draw_ticks()</code>. This method is usually called internally from <code>plot()</code>, but can also be used manually.</p> <p>This method: - Retrieves the current axis limits. - Places the x-axis label slightly to the right of the horizontal axis arrow. - Places the y-axis label slightly below the top of the vertical axis arrow. - Uses LaTeX formatting for the labels (e.g., \"x(t)\", \"y(\\tau)\", etc.). - The labels use the values of <code>self.xlabel</code> and <code>self.ylabel</code>.</p> <p>Notes: - This method is called automatically in <code>plot()</code> after drawing ticks and arrows. - Rotation for y-axis label is disabled to keep it horizontal.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; self.draw_labels()\n</code></pre> Source code in <code>signalblocks\\SignalPlotter.py</code> <pre><code>def draw_labels(self):\n    \"\"\"\n    Adds axis labels to the x and y axes using the current signal variable and name.\n    This method is typically called after `draw_ticks()`.\n    This method is usually called internally from `plot()`, but can also be used manually.\n\n    This method:\n    - Retrieves the current axis limits.\n    - Places the x-axis label slightly to the right of the horizontal axis arrow.\n    - Places the y-axis label slightly below the top of the vertical axis arrow.\n    - Uses LaTeX formatting for the labels (e.g., \"x(t)\", \"y(\\\\tau)\", etc.).\n    - The labels use the values of `self.xlabel` and `self.ylabel`.\n\n    Notes:\n    - This method is called automatically in `plot()` after drawing ticks and arrows.\n    - Rotation for y-axis label is disabled to keep it horizontal.\n\n    Examples:\n        &gt;&gt;&gt; self.draw_labels()\n    \"\"\"\n    # Get the current x and y axis limits\n    x_lim = self.ax.get_xlim()\n    y_lim = self.ax.get_ylim()\n\n    # X-axis label: slightly to the right of the rightmost x limit\n    x_pos = x_lim[1] - 0.01 * (x_lim[1] - x_lim[0])\n    y_pos = 0.02 * (y_lim[1] - y_lim[0])\n    self.ax.text(x_pos, y_pos, rf'${self.xlabel}$', fontsize=16, ha='right', va='bottom')\n\n    # Y-axis label: slightly below the top y limit (still inside the figure)\n    x_pos = 0.01 * (x_lim[1] - x_lim[0])\n    y_pos = y_lim[1] - 0.1 * (y_lim[1] - y_lim[0])\n    self.ax.text(x_pos, y_pos, rf'${self.ylabel}$', fontsize=16, ha='left', va='bottom', rotation=0)\n</code></pre>"},{"location":"reference/#signalblocks.SignalPlotter.SignalPlotter.draw_ticks","title":"<code>draw_ticks(tick_size_px=None, xticks=None, yticks=None, xtick_labels='auto', ytick_labels='auto')</code>","text":"<p>Draws tick marks and labels on both x- and y-axes, using automatic or manual configurations. This method is typically called after <code>draw_impulses()</code>. This method is usually called internally from <code>plot()</code>, but can also be used manually.</p> <p>Features: - Adds tick marks and LaTeX-formatted labels. - Integrates impulse positions into xticks automatically, unless explicitly overridden. - Supports:     - <code>pi_mode</code>: labels as multiples of \u03c0.     - <code>fraction_ticks</code>: labels as rational fractions.     - Hiding y=0 label if x=0 tick is shown (to avoid overlapping at the origin). - Avoids duplicate tick values based on numerical tolerance.</p> <p>Notes: - If <code>xticks_delta</code> or <code>yticks_delta</code> are provided (in constructor), evenly spaced ticks are placed at multiples. - If custom labels are passed and their count does not match the tick list, raises ValueError. - Labels are drawn on white rounded boxes for visibility over plots.</p> <p>Parameters:</p> Name Type Description Default <code>tick_size_px</code> <code>int</code> <p>Length of tick marks in pixels. If None, uses self.tick_size_px.</p> <code>None</code> <code>xticks</code> <code>list or auto or None</code> <p>X-axis tick positions. - 'auto': automatically computed ticks (even spacing or using xticks_delta). - list: manually specified tick positions. - None: ticks are shown only at Dirac impulse positions.</p> <code>None</code> <code>yticks</code> <code>list or auto or None</code> <p>Y-axis tick positions. - Same behavior as <code>xticks</code>.</p> <code>None</code> <code>xtick_labels</code> <code>list or auto or None</code> <p>Custom labels for xticks (must match length of xticks).</p> <code>'auto'</code> <code>ytick_labels</code> <code>list or auto or None</code> <p>Same for yticks.</p> <code>'auto'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; self.draw_ticks(xticks='auto', yticks=[-1, 0, 1], ytick_labels=['-1', '0', '1'])\n</code></pre> Source code in <code>signalblocks\\SignalPlotter.py</code> <pre><code>def draw_ticks(self,\n            tick_size_px=None,\n            xticks=None,\n            yticks=None,\n            xtick_labels='auto',\n            ytick_labels='auto'):\n    \"\"\"\n    Draws tick marks and labels on both x- and y-axes, using automatic or manual configurations.\n    This method is typically called after `draw_impulses()`.\n    This method is usually called internally from `plot()`, but can also be used manually.\n\n    Features:\n    - Adds tick marks and LaTeX-formatted labels.\n    - Integrates impulse positions into xticks automatically, unless explicitly overridden.\n    - Supports:\n        - `pi_mode`: labels as multiples of \u03c0.\n        - `fraction_ticks`: labels as rational fractions.\n        - Hiding y=0 label if x=0 tick is shown (to avoid overlapping at the origin).\n    - Avoids duplicate tick values based on numerical tolerance.\n\n    Notes:\n    - If `xticks_delta` or `yticks_delta` are provided (in constructor), evenly spaced ticks are placed at multiples.\n    - If custom labels are passed and their count does not match the tick list, raises ValueError.\n    - Labels are drawn on white rounded boxes for visibility over plots.\n\n    Args:\n        tick_size_px (int, optional): Length of tick marks in pixels. If None, uses self.tick_size_px.\n        xticks (list or 'auto' or None): X-axis tick positions.\n            - 'auto': automatically computed ticks (even spacing or using xticks_delta).\n            - list: manually specified tick positions.\n            - None: ticks are shown only at Dirac impulse positions.\n        yticks (list or 'auto' or None): Y-axis tick positions.\n            - Same behavior as `xticks`.\n        xtick_labels (list or 'auto' or None): Custom labels for xticks (must match length of xticks).\n        ytick_labels (list or 'auto' or None): Same for yticks.\n\n    Examples:\n        &gt;&gt;&gt; self.draw_ticks(xticks='auto', yticks=[-1, 0, 1], ytick_labels=['-1', '0', '1'])\n    \"\"\"\n\n    # Helper: filter duplicate values with tolerance\n    def unique_sorted(values, tol):\n        unique = []\n        for v in values:\n            if not any(abs(v - u) &lt;= tol for u in unique):\n                unique.append(v)\n        return sorted(unique)\n\n    # Helper: get impulse locations and amplitudes within range (with periodic extension if needed)\n    def get_impulse_positions_and_areas(t_min, t_max, tol):\n        impulse_positions = []\n        impulse_positions_areas = []\n        if self.impulse_locs:\n            if self.period is None:\n                # Non-periodic case: keep impulses in visible range\n                for base_loc, base_area in zip(self.impulse_locs, self.impulse_areas):\n                    if t_min - tol &lt;= base_loc &lt;= t_max + tol:\n                        impulse_positions.append(base_loc)\n                        impulse_positions_areas.append(base_area)\n            else:\n                # Periodic case: replicate impulses across periods\n                T = self.period\n                for base_loc, base_area in zip(self.impulse_locs, self.impulse_areas):\n                    k_min = int(np.floor((t_min - base_loc) / T))\n                    k_max = int(np.ceil((t_max - base_loc) / T))\n                    for k in range(k_min, k_max + 1):\n                        t_k = base_loc + k * T\n                        if t_min - tol &lt;= t_k &lt;= t_max + tol:\n                            impulse_positions.append(t_k)\n                            impulse_positions_areas.append(base_area)\n        # Eliminate duplicates within tolerance\n        unique_pos = []\n        unique_area = []\n        for loc, area in zip(impulse_positions, impulse_positions_areas):\n            if not any(abs(loc - u) &lt;= tol for u in unique_pos):\n                unique_pos.append(loc)\n                unique_area.append(area)\n        if unique_pos:\n            idx_sort = np.argsort(unique_pos)\n            impulse_positions = [unique_pos[i] for i in idx_sort]\n            impulse_positions_areas = [unique_area[i] for i in idx_sort]\n        else:\n            impulse_positions, impulse_positions_areas = [], []\n        return impulse_positions, impulse_positions_areas\n\n    # Helper: validate tick list\n    def has_valid_ticks(ticks):\n        if ticks is None:\n            return False\n        try:\n            arr = np.array(ticks)\n            return arr.ndim &gt;= 1 and arr.size &gt;= 1\n        except Exception:\n            return False\n\n    # Helper: generate xticks and labels\n    def generate_xticks(effective_xticks, impulse_positions, tol, t_min, t_max):\n        raw_xticks = []\n        manual_xticks = []\n        manual_xlabels = []\n\n        has_init_xticks = has_valid_ticks(getattr(self, 'xticks', None))\n        xticks_delta = getattr(self, 'xticks_delta', None)  # Nuevo atributo opcional\n\n        if isinstance(effective_xticks, str) and effective_xticks == 'auto':\n            if has_init_xticks:\n                raw_xticks = list(self.xticks)\n                if self.xtick_labels is not None:\n                    if len(self.xticks) != len(self.xtick_labels):\n                        raise ValueError(\"xtick_labels and xticks from init must have the same length\")\n                    manual_xticks = list(self.xticks)\n                    manual_xlabels = list(self.xtick_labels)\n            else:\n                if xticks_delta is not None:\n                    n_left = int(np.floor((0 - t_min) / xticks_delta))\n                    n_right = int(np.floor((t_max - 0) / xticks_delta))\n                    base_ticks = [k * xticks_delta for k in range(-n_left, n_right + 1)]\n                else:\n                    base_ticks = list(np.linspace(t_min, t_max, 5))\n                raw_xticks = base_ticks.copy()\n\n            # Add impulses\n            for loc in impulse_positions:\n                if t_min - tol &lt;= loc &lt;= t_max + tol and not any(abs(loc - x0) &lt;= tol for x0 in raw_xticks):\n                    raw_xticks.append(loc)\n\n        else:\n            if xticks_delta is not None:\n                warnings.warn(\"xticks_delta will be ignored because xticks not in 'auto' mode\", stacklevel=2)\n            raw_xticks = list(effective_xticks)\n            if xtick_labels not in (None, 'auto'):\n                if len(raw_xticks) != len(xtick_labels):\n                    raise ValueError(\"xtick_labels and xticks must have the same length\")\n                manual_xticks = list(raw_xticks)\n                manual_xlabels = list(xtick_labels)\n            elif self.xtick_labels is not None:\n                if len(raw_xticks) != len(self.xtick_labels):\n                    raise ValueError(\"xtick_labels and xticks from init must have the same length\")\n                manual_xticks = list(raw_xticks)\n                manual_xlabels = list(self.xtick_labels)\n\n            for loc in impulse_positions:\n                if t_min - tol &lt;= loc &lt;= t_max + tol and not any(abs(loc - x0) &lt;= tol for x0 in raw_xticks):\n                    raw_xticks.append(loc)\n\n        raw_xticks = unique_sorted(raw_xticks, tol)\n\n        # Gnerate labels\n        xlabels = []\n        for x in raw_xticks:\n            label = None\n            for xm, lbl in zip(manual_xticks, manual_xlabels):\n                if abs(xm - x) &lt;= tol:\n                    label = lbl\n                    break\n            if label is None:\n                if getattr(self, 'pi_mode', False):\n                    f = Fraction(x / np.pi).limit_denominator(24)\n                    if abs(float(f) * np.pi - x) &gt; tol:\n                        label = f'{x:g}'\n                    elif f == 0:\n                        label = '0'\n                    elif f == 1:\n                        label = r'\\pi'\n                    elif f == -1:\n                        label = r'-\\pi'\n                    else:\n                        num = f.numerator\n                        denom = f.denominator\n                        prefix = '-' if num * denom &lt; 0 else ''\n                        num, denom = abs(num), abs(denom)\n                        if denom == 1:\n                            label = rf\"{prefix}{num}\\pi\"\n                        elif num == 1:\n                            label = rf\"{prefix}\\frac{{\\pi}}{{{denom}}}\"\n                        else:\n                            label = rf\"{prefix}\\frac{{{num}\\pi}}{{{denom}}}\"\n                elif getattr(self, 'fraction_ticks', False):\n                    f = Fraction(x).limit_denominator(24)\n                    label = f\"{f.numerator}/{f.denominator}\" if f.denominator != 1 else f\"{f.numerator}\"\n                else:\n                    label = f'{x:g}'\n            xlabels.append(label)\n\n        return raw_xticks, xlabels\n\n    # Helper: generate yticks and labels\n    def generate_yticks(effective_yticks, tol):\n        raw_yticks = []\n        manual_yticks = []\n        manual_ylabels = []\n\n        has_init_yticks = has_valid_ticks(getattr(self, 'yticks', None))\n        ytick_labels = getattr(self, 'ytick_labels', None)\n        ydelta = getattr(self, 'yticks_delta', None)\n\n        if effective_yticks is None:\n            raw_yticks = []\n        elif isinstance(effective_yticks, str) and effective_yticks == 'auto':\n            if has_init_yticks:\n                raw_yticks = list(self.yticks)\n                if self.ytick_labels is not None:\n                    if len(self.yticks) != len(self.ytick_labels):\n                        raise ValueError(\"ytick_labels and yticks from init must have the same length\")\n                    manual_yticks = list(self.yticks)\n                    manual_ylabels = list(self.ytick_labels)\n                if ydelta is not None:\n                    warnings.warn(\"yticks_delta ignored because yticks where specified at init\")\n            else:\n                if ydelta is not None and ydelta &gt; 0:\n                    y_start = np.ceil(self.y_min / ydelta)\n                    y_end = np.floor(self.y_max / ydelta)\n                    raw_yticks = [k * ydelta for k in range(int(y_start), int(y_end) + 1)]\n                else:\n                    y0 = np.floor(self.y_min)\n                    y1 = np.ceil(self.y_max)\n                    if abs(y1 - y0) &lt; 1e-6:\n                        raw_yticks = [y0 - 1, y0, y0 + 1]\n                    else:\n                        raw_yticks = list(np.linspace(y0, y1, 3))\n        else:\n            raw_yticks = list(effective_yticks)\n            if ydelta is not None:\n                warnings.warn(\"yticks_delta ignored because yticks is not in 'auto' mode\")\n\n            if ytick_labels not in (None, 'auto'):\n                if len(raw_yticks) != len(ytick_labels):\n                    raise ValueError(\"ytick_labels and yticks must have the same length\")\n                manual_yticks = list(raw_yticks)\n                manual_ylabels = list(ytick_labels)\n            elif self.ytick_labels is not None:\n                if len(raw_yticks) != len(self.ytick_labels):\n                    raise ValueError(\"ytick_labels and yticks from init must have the same length\")\n                manual_yticks = list(raw_yticks)\n                manual_ylabels = list(self.ytick_labels)\n\n        raw_yticks = unique_sorted(raw_yticks, tol)\n\n        ylabels = []\n        for y in raw_yticks:\n            label = None\n            for ym, lbl in zip(manual_yticks, manual_ylabels):\n                if abs(ym - y) &lt;= tol:\n                    label = lbl\n                    break\n            if label is None:\n                if self.pi_mode:\n                    f = Fraction(y / np.pi).limit_denominator(24)\n                    if abs(float(f) * np.pi - y) &gt; tol:\n                        label = f'{y:.3g}'\n                    elif f == 0:\n                        label = '0'\n                    elif f == 1:\n                        label = r'\\pi'\n                    elif f == -1:\n                        label = r'-\\pi'\n                    else:\n                        num = f.numerator\n                        denom = f.denominator\n                        prefix = '-' if num * denom &lt; 0 else ''\n                        num, denom = abs(num), abs(denom)\n                        if denom == 1:\n                            label = rf\"{prefix}{num}\\pi\"\n                        elif num == 1:\n                            label = rf\"{prefix}\\frac{{\\pi}}{{{denom}}}\"\n                        else:\n                            label = rf\"{prefix}\\frac{{{num}\\pi}}{{{denom}}}\"\n                elif self.fraction_ticks:\n                    f = Fraction(y).limit_denominator(24)\n                    label = f\"{f.numerator}/{f.denominator}\" if f.denominator != 1 else f\"{f.numerator}\"\n                else:\n                    label = f'{y:.3g}'\n            ylabels.append(label)\n\n        return raw_yticks, ylabels\n\n    # Helper: hide y=0 label if x=0 tick exists\n    def filter_yticks(raw_yticks, ylabels, raw_xticks, tol):\n        has_xtick_zero = any(abs(x) &lt;= tol for x in raw_xticks)\n        if has_xtick_zero:\n            filtered_yticks = []\n            filtered_ylabels = []\n            for y, lbl in zip(raw_yticks, ylabels):\n                if abs(y) &lt;= tol:\n                    continue\n                filtered_yticks.append(y)\n                filtered_ylabels.append(lbl)\n            return filtered_yticks, filtered_ylabels\n        else:\n            return raw_yticks, ylabels\n\n    # Helper: convert pixel length to data coordinates\n    def px_to_data_length(tick_px):\n        origin_disp = self.ax.transData.transform((0, 0))\n        up_disp = origin_disp + np.array([0, tick_px])\n        right_disp = origin_disp + np.array([tick_px, 0])\n        origin_data = np.array(self.ax.transData.inverted().transform(origin_disp))\n        up_data = np.array(self.ax.transData.inverted().transform(up_disp))\n        right_data = np.array(self.ax.transData.inverted().transform(right_disp))\n        dy = up_data[1] - origin_data[1]\n        dx = right_data[0] - origin_data[0]\n        return dx, dy\n\n    # Helper: draw xticks and labels\n    def draw_xticks(raw_xticks, xlabels, impulse_positions, impulse_positions_areas, dx, dy, tol):\n        xlim = self.ax.get_xlim()\n        for x, lbl in zip(raw_xticks, xlabels):\n            if xlim[0] &lt;= x &lt;= xlim[1]:\n                self.ax.plot([x, x], [0 - dy/2, 0 + dy/2], transform=self.ax.transData,\n                            color='black', linewidth=1.2, clip_on=False)\n                area = None\n                for loc, a in zip(impulse_positions, impulse_positions_areas):\n                    if abs(loc - x) &lt;= tol:\n                        area = a\n                        break\n                y_off = +8 if (area is not None and area &lt; 0) else -8\n                offset = (-8, y_off) if abs(x) &lt; tol else (0, y_off)\n                va = 'bottom' if y_off &gt; 0 else 'top'\n                self.ax.annotate(rf'${lbl}$', xy=(x, 0), xycoords='data',\n                                textcoords='offset points', xytext=offset,\n                                ha='center', va=va, fontsize=12, zorder=10,\n                                bbox=dict(boxstyle='round,pad=0.1', facecolor='white',\n                                        edgecolor='none', alpha=self.alpha))\n\n    # Helper: draw yticks and labels\n    def draw_yticks(raw_yticks, ylabels, dx, dy):\n        ylim = self.ax.get_ylim()\n        for y, lbl in zip(raw_yticks, ylabels):\n            if ylim[0] &lt;= y &lt;= ylim[1]:\n                self.ax.plot([0 - dx/2, 0 + dx/2], [y, y], transform=self.ax.transData,\n                            color='black', linewidth=1.2, clip_on=False)\n                offset = (-4, -16) if abs(y) &lt; 1e-10 else (-4, 0)\n                self.ax.annotate(rf'${lbl}$', xy=(0, y), xycoords='data',\n                                textcoords='offset points', xytext=offset,\n                                ha='right', va='center', fontsize=12, zorder=10,\n                                bbox=dict(boxstyle='round,pad=0.1', facecolor='white',\n                                        edgecolor='none', alpha=self.alpha))\n\n     # === MAIN LOGIC ===\n\n    # 0. Use constructor defaults if nothing passed explicitly\n    effective_xticks = xticks if xticks is not None else getattr(self, 'init_xticks_arg', None)\n    effective_yticks = yticks if yticks is not None else getattr(self, 'init_yticks_arg', None)\n\n    # 1. Determine tick size in pixels\n    tick_px = tick_size_px if tick_size_px is not None else self.tick_size_px\n\n    # 2. Get plotting range and numeric tolerance\n    t_min, t_max = self.horiz_range\n    tol = 1e-8 * max(1.0, abs(t_max - t_min))\n\n    # 3. Get impulse positions in the current range\n    impulse_positions, impulse_positions_areas = get_impulse_positions_and_areas(t_min, t_max, tol)\n\n    # 4. Generate x ticks and labels\n    raw_xticks, xlabels = generate_xticks(effective_xticks, impulse_positions, tol, t_min, t_max)\n\n    # 5. Generate y ticks and labels\n    raw_yticks, ylabels = generate_yticks(effective_yticks, tol)\n\n    # 6. Remove y=0 label if x=0 tick exists\n    raw_yticks, ylabels = filter_yticks(raw_yticks, ylabels, raw_xticks, tol)\n\n    # 7. Convert tick length in px to data coordinates\n    dx, dy = px_to_data_length(tick_px)\n\n    # 8. Draw x-axis ticks and labels\n    draw_xticks(raw_xticks, xlabels, impulse_positions, impulse_positions_areas, dx, dy, tol)\n\n    # 9. Draw y-axis ticks and labels\n    draw_yticks(raw_yticks, ylabels, dx, dy)\n</code></pre>"},{"location":"reference/#signalblocks.SignalPlotter.SignalPlotter.plot","title":"<code>plot(name=None)</code>","text":"<p>Plots the signal specified by name (or the default if defined via expr_str in constructor).</p> <p>This method: - Initializes the expression from <code>expr_str_pending</code> (if any), only once. - Looks up the signal in the internal dictionary (<code>self.signal_defs</code>) using its name. - Sets up symbolic and numeric representations of the signal. - Removes DiracDelta terms from the continuous part. - Extracts impulses and prepares data for plotting. - Calls the full sequence: axis setup, function drawing, impulses, ticks, labels, and final display/save.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the signal to plot, e.g., \"x1\". If None and <code>expr_str</code> was given at init,         it uses the last-added expression.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the signal is not defined or its variable cannot be determined.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; SignalPlotter(\"x(t)=rect(t-1)\").plot()\n&gt;&gt;&gt; sp1 = SignalPlotter(\"x(t)=rect(t-1)\", period=2)\n&gt;&gt;&gt; sp1.plot(\"x\")\n&gt;&gt;&gt; sp2 = SignalPlotter()\n&gt;&gt;&gt; sp2.add_signal(\"x(t) = rect(t)\")\n&gt;&gt;&gt; sp2.plot(\"x\")\n</code></pre> Source code in <code>signalblocks\\SignalPlotter.py</code> <pre><code>def plot(self, name=None):\n    \"\"\"\n    Plots the signal specified by name (or the default if defined via expr_str in constructor).\n\n    This method:\n    - Initializes the expression from `expr_str_pending` (if any), only once.\n    - Looks up the signal in the internal dictionary (`self.signal_defs`) using its name.\n    - Sets up symbolic and numeric representations of the signal.\n    - Removes DiracDelta terms from the continuous part.\n    - Extracts impulses and prepares data for plotting.\n    - Calls the full sequence: axis setup, function drawing, impulses, ticks, labels, and final display/save.\n\n    Args:\n        name (str, optional): Name of the signal to plot, e.g., \"x1\". If None and `expr_str` was given at init,\n                    it uses the last-added expression.\n\n    Raises:\n        ValueError: If the signal is not defined or its variable cannot be determined.\n\n    Examples:\n        &gt;&gt;&gt; SignalPlotter(\"x(t)=rect(t-1)\").plot()\n        &gt;&gt;&gt; sp1 = SignalPlotter(\"x(t)=rect(t-1)\", period=2)\n        &gt;&gt;&gt; sp1.plot(\"x\")\n        &gt;&gt;&gt; sp2 = SignalPlotter()\n        &gt;&gt;&gt; sp2.add_signal(\"x(t) = rect(t)\")\n        &gt;&gt;&gt; sp2.plot(\"x\")\n    \"\"\"\n    # Initialize from expr_str (only once), if provided at construction\n    if (hasattr(self, 'expr_str_pending') and \n        self.expr_str_pending is not None and \n        isinstance(self.expr_str_pending, str) and \n        not getattr(self, '_initialized_from_expr', False)):\n        expr_str = self.expr_str_pending\n        self._initialized_from_expr = True\n        self.add_signal(expr_str, period=self.period)\n        name = list(self.signal_defs.keys())[-1]\n\n    if name:\n        if name not in self.signal_defs:\n            raise ValueError(f\"Signal '{name}' is not defined.\")\n        self.current_name = name\n        self.func_name = name\n\n        # Use declared variable or infer it\n        expr = self.signal_defs[name]\n        var = self.var_symbols.get(name, None)\n        if var is None:\n            free_vars = list(expr.free_symbols)\n            if not free_vars:\n                raise ValueError(f\"Could not determine the variable for signal '{name}'.\")\n            var = free_vars[0]\n\n        # Update expression and lambdified function, remove Dirac terms, extract impulses\n        self._update_expression_and_func(expr, var)\n\n        # Use declared variable or infer it\n        expr = self.signal_defs[name]\n        var = self.var_symbols.get(name, None)\n        if var is None:\n            free_vars = list(expr.free_symbols)\n            if not free_vars:\n                raise ValueError(f\"Could not determine the variable for signal '{name}'.\")\n            var = free_vars[0]\n\n        # Update expression and lambdified function, remove Dirac terms, extract impulses\n        self._update_expression_and_func(expr, var)\n\n        # Set axis labels\n        self.xlabel = str(var)\n        self.ylabel = f\"{self.func_name}({self.xlabel})\"\n        if hasattr(self, 'custom_labels') and self.func_name in self.custom_labels:\n            self.ylabel = self.custom_labels[self.func_name]\n\n        # Time discretization for plotting\n        self.t_vals = np.linspace(*self.horiz_range, self.num_points)\n\n        # Create figure and compute y-range\n        self.fig, self.ax = plt.subplots(figsize=self.figsize)\n        self._prepare_plot()\n\n    # Draw all components of the plot\n    self.setup_axes()\n    self.draw_function()\n    self.draw_impulses()\n    self.ax.relim()\n    self.ax.autoscale_view()\n    self.draw_ticks()\n    self.draw_labels()\n    self.show()\n</code></pre>"},{"location":"reference/#signalblocks.SignalPlotter.SignalPlotter.plot_convolution_result","title":"<code>plot_convolution_result(x_name, h_name, num_points=None, show_expr=False)</code>","text":"<p>Computes and plots the convolution result y(t) = (x * h)(t) between two signals x(t) and h(t).</p> <p>This method automatically: - Detects if either x(\u03c4) or h(t\u2212\u03c4) consists only of Dirac deltas, and applies the convolution property for impulses. - Otherwise, performs numerical integration over \u03c4 for a given range of t values. - Displays the resulting function y(t), including impulses if present.</p> <p>Notes: - Impulse responses are handled symbolically, while general functions are integrated numerically. - Uses scipy.integrate.quad for general convolution integrals.</p> <p>Parameters:</p> Name Type Description Default <code>x_name</code> <code>str</code> <p>Name of the signal x(t), previously defined via <code>add_signal(...)</code>.</p> required <code>h_name</code> <code>str</code> <p>Name of the signal h(t), previously defined via <code>add_signal(...)</code>.</p> required <code>num_points</code> <code>int</code> <p>Number of time samples to compute for numerical integration. Defaults to self.num_points.</p> <code>None</code> <code>show_expr</code> <code>bool</code> <p>Reserved for future use; currently unused.</p> <code>False</code> Source code in <code>signalblocks\\SignalPlotter.py</code> <pre><code>def plot_convolution_result(self, x_name, h_name, num_points=None, show_expr=False):\n    \"\"\"\n    Computes and plots the convolution result y(t) = (x * h)(t) between two signals x(t) and h(t).\n\n    This method automatically:\n    - Detects if either x(\u03c4) or h(t\u2212\u03c4) consists only of Dirac deltas, and applies the convolution property for impulses.\n    - Otherwise, performs numerical integration over \u03c4 for a given range of t values.\n    - Displays the resulting function y(t), including impulses if present.\n\n    Notes:\n    - Impulse responses are handled symbolically, while general functions are integrated numerically.\n    - Uses scipy.integrate.quad for general convolution integrals.\n\n    Args:\n        x_name (str): Name of the signal x(t), previously defined via `add_signal(...)`.\n        h_name (str): Name of the signal h(t), previously defined via `add_signal(...)`.\n        num_points (int, optional): Number of time samples to compute for numerical integration. Defaults to self.num_points.\n        show_expr (bool, optional): Reserved for future use; currently unused.\n    \"\"\"\n\n    t = sp.Symbol('t')\n    tau = sp.Symbol('tau')\n\n    if num_points is None:\n        num_points = self.num_points\n\n    x_expr = self.signal_defs[x_name]\n    h_expr = self.signal_defs[h_name]\n    var_x = self.var_symbols[x_name]\n    var_h = self.var_symbols[h_name]\n\n    x_tau_expr = x_expr.subs(var_x, tau)\n    h_t_tau_expr = h_expr.subs(var_h, t - tau)\n\n    local_dict = self._get_local_dict()\n    t_vals = np.linspace(*self.horiz_range, num_points)\n    y_vals = []\n\n    # Case 1: Dirac in x(t)\n    if x_tau_expr.has(sp.DiracDelta):\n        y_expr = 0\n        for term in x_tau_expr.as_ordered_terms():\n            if term.has(sp.DiracDelta):\n                args = term.args if term.func == sp.Mul else [term]\n                scale = 1\n                for a in args:\n                    if a.func == sp.DiracDelta:\n                        delta_arg = a.args[0]\n                    else:\n                        scale *= a\n                shift = sp.solve(delta_arg, tau)\n                if shift:\n                    y_expr += scale * h_expr.subs(var_h, t - shift[0])\n\n        # Extract impulses from y_expr\n        impulse_locs = []\n        impulse_areas = []\n        for term in y_expr.as_ordered_terms():\n            if term.has(sp.DiracDelta):\n                args = term.args if term.func == sp.Mul else [term]\n                area = 1\n                shift = 0\n                for a in args:\n                    if a.func == sp.DiracDelta:\n                        sol = sp.solve(a.args[0], t)\n                        if sol:\n                            shift = float(sol[0])\n                    else:\n                        area *= a\n                impulse_locs.append(shift)\n                impulse_areas.append(float(area))\n\n        self._update_expression_and_func(y_expr, t)\n        self.impulse_locs = impulse_locs\n        self.impulse_areas = impulse_areas\n\n    # Case 2: Dirac in h(t)\n    elif h_t_tau_expr.has(sp.DiracDelta):\n        y_expr = 0\n        for term in h_t_tau_expr.as_ordered_terms():\n            if term.has(sp.DiracDelta):\n                args = term.args if term.func == sp.Mul else [term]\n                scale = 1\n                for a in args:\n                    if a.func == sp.DiracDelta:\n                        delta_arg = a.args[0]\n                    else:\n                        scale *= a\n                shift = sp.solve(delta_arg, tau)\n                if shift:\n                    y_expr += scale * x_tau_expr.subs(tau, shift[0])\n\n        impulse_locs = []\n        impulse_areas = []\n        for term in y_expr.as_ordered_terms():\n            if term.has(sp.DiracDelta):\n                args = term.args if term.func == sp.Mul else [term]\n                area = 1\n                shift = 0\n                for a in args:\n                    if a.func == sp.DiracDelta:\n                        sol = sp.solve(a.args[0], t)\n                        if sol:\n                            shift = float(sol[0])\n                    else:\n                        area *= a\n                impulse_locs.append(shift)\n                impulse_areas.append(float(area))\n\n        self._update_expression_and_func(y_expr, t)\n        self.impulse_locs = impulse_locs\n        self.impulse_areas = impulse_areas\n\n    # Case 3: General convolution via numerical integration\n    else:\n        x_func_tau = sp.lambdify(tau, x_tau_expr, modules=[\"numpy\", local_dict])\n\n        def h_func_tau_shifted(tau_val, t_val):\n            h_t_tau = h_t_tau_expr.subs(t, t_val)\n            h_func = sp.lambdify(tau, h_t_tau, modules=[\"numpy\", local_dict])\n            return h_func(tau_val)\n\n        support_x = self.horiz_range\n        support_h = self.horiz_range\n\n        for t_val in t_vals:\n            a = max(support_x[0], t_val - support_h[1])\n            b = min(support_x[1], t_val - support_h[0])\n            if a &gt;= b:\n                y_vals.append(0)\n                continue\n            integrand = lambda tau_val: x_func_tau(tau_val) * h_func_tau_shifted(tau_val, t_val)\n            try:\n                val, _ = integrate.quad(integrand, a, b)\n            except Exception:\n                val = 0\n            y_vals.append(val)\n\n        self.func = lambda t_: np.interp(t_, t_vals, y_vals)\n        self.impulse_locs = []\n        self.impulse_areas = []\n        self.expr = None\n\n    # Final settings and plot\n    self.t_vals = t_vals\n    self.xlabel = \"t\"\n    self.ylabel = r\"y(t)\"\n\n    self._setup_figure()\n    self.setup_axes()\n    self.draw_function()\n    self.draw_impulses()\n    self.draw_ticks()\n    self.draw_labels()\n    self.show()\n</code></pre>"},{"location":"reference/#signalblocks.SignalPlotter.SignalPlotter.plot_convolution_steps","title":"<code>plot_convolution_steps(x_name, h_name, t_val, tau=None, t=None)</code>","text":"<p>Plots four key signals involved in a convolution step at a fixed time <code>t_val</code>: x(tau), x(t-tau), h(tau), h(t-tau)., all in terms of \u03c4.</p> <p>This method is particularly useful for visualizing the time-reversed and shifted versions of the input signals used in the convolution integral.</p> <p>Notes: - The horizontal axis is adjusted for time-reversed signals (e.g., t\u2212\u03c4), and tick labels are shifted accordingly. - Four separate plots are generated in sequence, with labels and axes automatically set.</p> <p>Parameters:</p> Name Type Description Default <code>x_name</code> <code>str</code> <p>Name of the signal x, previously defined with <code>add_signal(...)</code>.</p> required <code>h_name</code> <code>str</code> <p>Name of the signal h, previously defined with <code>add_signal(...)</code>.</p> required <code>t_val</code> <code>float</code> <p>The fixed time t at which the convolution step is evaluated.</p> required <code>tau</code> <code>Symbol or str</code> <p>Symbol for the integration variable (default: 'tau').</p> <code>None</code> <code>t</code> <code>Symbol or str</code> <p>Symbol for the time variable (default: 't').</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sp = SignalPlotter()\n&gt;&gt;&gt; sp.add_signal(\"x(t)=sinc(t)\")\n&gt;&gt;&gt; sp.add_signal(\"h(t)=sinc(t/2)\")\n&gt;&gt;&gt; sp.plot_convolution_steps(\"x\", \"h\", t_val=1)\n</code></pre> Source code in <code>signalblocks\\SignalPlotter.py</code> <pre><code>def plot_convolution_steps(self, x_name, h_name, t_val, tau=None, t=None):\n    \"\"\"\n    Plots four key signals involved in a convolution step at a fixed time `t_val`:\n    x(tau), x(t-tau), h(tau), h(t-tau)., all in terms of \u03c4.\n\n    This method is particularly useful for visualizing the time-reversed and shifted\n    versions of the input signals used in the convolution integral.\n\n    Notes:\n    - The horizontal axis is adjusted for time-reversed signals (e.g., t\u2212\u03c4),\n    and tick labels are shifted accordingly.\n    - Four separate plots are generated in sequence, with labels and axes automatically set.\n\n    Args:\n        x_name (str): Name of the signal x, previously defined with `add_signal(...)`.\n        h_name (str): Name of the signal h, previously defined with `add_signal(...)`.\n        t_val (float): The fixed time t at which the convolution step is evaluated.\n        tau (sympy.Symbol or str, optional): Symbol for the integration variable (default: 'tau').\n        t (sympy.Symbol or str, optional): Symbol for the time variable (default: 't').\n\n    Examples:\n        &gt;&gt;&gt; sp = SignalPlotter()\n        &gt;&gt;&gt; sp.add_signal(\"x(t)=sinc(t)\")\n        &gt;&gt;&gt; sp.add_signal(\"h(t)=sinc(t/2)\")\n        &gt;&gt;&gt; sp.plot_convolution_steps(\"x\", \"h\", t_val=1)\n    \"\"\"\n    local_dict = self._get_local_dict()\n\n    # Use default symbols if not provided\n    if tau is None:\n        tau = local_dict.get('tau')\n    elif isinstance(tau, str):\n        tau = sp.Symbol(tau)\n\n    if t is None:\n        t = local_dict.get('t')\n    elif isinstance(t, str):\n        t = sp.Symbol(t)\n\n    # Evaluate x(\u03c4) and h(\u03c4) using their respective symbolic variable\n    x_expr = self.signal_defs[x_name].subs(self.var_symbols[x_name], tau)\n    h_expr = self.signal_defs[h_name].subs(self.var_symbols[h_name], tau)\n\n    # Compute x(t\u2212\u03c4) and h(t\u2212\u03c4), and substitute t = t_val\n    x_shift = x_expr.subs(tau, t - tau).subs(t, t_val)\n    h_shift = h_expr.subs(tau, t - tau).subs(t, t_val)\n\n    # Convert to LaTeX strings for labeling\n    tau_str = sp.latex(tau)\n    t_str = sp.latex(t)\n\n    # Generate custom xticks and labels for the shifted signals\n    xticks = self.init_xticks_arg\n    if xticks == 'auto':\n        xticks_shifted = [t_val]\n        xtick_labels_shifted = [f\"{t_str}\"]\n    elif isinstance(xticks, (list, tuple)):\n        xticks_shifted = [t_val - v for v in xticks]\n        xtick_labels_shifted = []\n        for v in xticks:\n            delta = - v\n            if delta == 0:\n                label = fr\"{t_str}\"\n            elif delta &gt; 0:\n                label = fr\"{t_str}+{delta}\"\n            else:\n                label = fr\"{t_str}{delta}\"  # delta is already negative\n            xtick_labels_shifted.append(label)\n    else:\n        xticks_shifted = None\n        xtick_labels_shifted = None\n\n    horiz_range = self.horiz_range\n    # Compute reversed horizontal range for time-reversed signals\n    horiz_range_shifted = t_val - np.array(horiz_range)[::-1]\n\n    # Define all 4 signals to be plotted with labels and optional custom ticks\n    items = [\n        (x_expr, fr\"{x_name}({tau_str})\", None, None, horiz_range),\n        (h_expr, fr\"{h_name}({tau_str})\", None, None, horiz_range),\n        (x_shift, fr\"{x_name}({t_str}-{tau_str})\", xticks_shifted, xtick_labels_shifted, horiz_range_shifted),\n        (h_shift, fr\"{h_name}({t_str}-{tau_str})\", xticks_shifted, xtick_labels_shifted, horiz_range_shifted),\n    ]\n\n    for expr, label, xticks_custom, xtick_labels_custom, horiz_range_custom in items:\n        # Prepare expression and plot configuration\n        self._update_expression_and_func(expr, tau)\n        self.xlabel = fr\"\\{tau}\"\n        self.ylabel = label\n        self.t_vals = np.linspace(*horiz_range_custom, self.num_points)\n\n        self._setup_figure()\n        self.setup_axes(horiz_range_custom)\n        self.draw_function(horiz_range_custom)\n        self.draw_impulses()\n        self.draw_ticks(xticks=xticks_custom, xtick_labels=xtick_labels_custom)\n        self.draw_labels()\n        self.show()\n</code></pre>"},{"location":"reference/#signalblocks.SignalPlotter.SignalPlotter.plot_convolution_view","title":"<code>plot_convolution_view(expr_str, t_val, label=None, tau=None, t=None)</code>","text":"<p>Plots an intermediate signal in the convolution process, such as x(t\u2212\u03c4), h(\u03c4+t), etc.</p> <p>This method: - Substitutes the convolution variable t with a fixed value <code>t_val</code> in a symbolic expression. - Evaluates the resulting signal in terms of \u03c4. - Optionally adjusts x-axis direction and labels if the expression has a form like (t \u2212 \u03c4) or (t + \u03c4). - Automatically handles periodic xtick reversal or shift based on convolution expression. - Renders the function using existing plot methods (function, impulses, ticks, etc.).</p> <p>Parameters:</p> Name Type Description Default <code>expr_str</code> <code>str</code> <p>A symbolic expression involving \u03c4 and t, e.g. \"x(t - tau)\" or \"h(t + tau)\".         The base signal must already be defined with <code>add_signal(...)</code>.</p> required <code>t_val</code> <code>float</code> <p>The value of the time variable <code>t</code> at which the expression is evaluated.</p> required <code>label</code> <code>str</code> <p>Custom y-axis label to display (default is derived from the expression).</p> <code>None</code> <code>tau</code> <code>Symbol or str</code> <p>Symbol to use as integration variable (default: 'tau').</p> <code>None</code> <code>t</code> <code>Symbol or str</code> <p>Symbol used in shifting (default: 't').</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the base signal is not defined or the expression format is invalid.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sp = SignalPlotter(xticks=[-1, 0, 3], num_points=200, fraction_ticks=True)\n&gt;&gt;&gt; sp.add_signal(\"x(t)=exp(-2t)*u(t)\")\n&gt;&gt;&gt; sp.add_signal(\"h(t)=u(t)\")\n&gt;&gt;&gt; sp.plot_convolution_view(\"x(t - tau)\", t_val=1)\n&gt;&gt;&gt; sp.plot_convolution_view(\"h(t + tau)\", t_val=2, tau='lambda', t='omega')\n</code></pre> Source code in <code>signalblocks\\SignalPlotter.py</code> <pre><code>def plot_convolution_view(self, expr_str, t_val, label=None, tau=None, t=None):\n    \"\"\"\n    Plots an intermediate signal in the convolution process, such as x(t\u2212\u03c4), h(\u03c4+t), etc.\n\n    This method:\n    - Substitutes the convolution variable t with a fixed value `t_val` in a symbolic expression.\n    - Evaluates the resulting signal in terms of \u03c4.\n    - Optionally adjusts x-axis direction and labels if the expression has a form like (t \u2212 \u03c4) or (t + \u03c4).\n    - Automatically handles periodic xtick reversal or shift based on convolution expression.\n    - Renders the function using existing plot methods (function, impulses, ticks, etc.).\n\n    Args:\n        expr_str (str): A symbolic expression involving \u03c4 and t, e.g. \"x(t - tau)\" or \"h(t + tau)\".\n                    The base signal must already be defined with `add_signal(...)`.\n        t_val (float): The value of the time variable `t` at which the expression is evaluated.\n        label (str, optional): Custom y-axis label to display (default is derived from the expression).\n        tau (sympy.Symbol or str, optional): Symbol to use as integration variable (default: 'tau').\n        t (sympy.Symbol or str, optional): Symbol used in shifting (default: 't').\n\n    Raises:\n        ValueError: If the base signal is not defined or the expression format is invalid.\n\n    Examples:\n        &gt;&gt;&gt; sp = SignalPlotter(xticks=[-1, 0, 3], num_points=200, fraction_ticks=True)\n        &gt;&gt;&gt; sp.add_signal(\"x(t)=exp(-2t)*u(t)\")\n        &gt;&gt;&gt; sp.add_signal(\"h(t)=u(t)\")\n        &gt;&gt;&gt; sp.plot_convolution_view(\"x(t - tau)\", t_val=1)\n        &gt;&gt;&gt; sp.plot_convolution_view(\"h(t + tau)\", t_val=2, tau='lambda', t='omega')\n    \"\"\"\n    import re\n    local_dict = self._get_local_dict()\n\n    # Define symbolic variables for \u03c4 and t\n    if tau is None:\n        tau = local_dict.get('tau')\n    elif isinstance(tau, str):\n        tau = sp.Symbol(tau)\n    if t is None:\n        t = local_dict.get('t')\n    elif isinstance(t, str):\n        t = sp.Symbol(t)\n\n    local_dict.update({'tau': tau, 't': t, str(tau): tau, str(t): t})\n\n    # Extract base signal name and ensure it's defined\n    if \"(\" in expr_str:\n        name = expr_str.split(\"(\")[0].strip()\n        if name not in self.signal_defs:\n            raise ValueError(f\"Signal '{name}' is not defined.\")\n        expr_base = self.signal_defs[name]\n        var_base = self.var_symbols.get(name, t)\n    else:\n        raise ValueError(\"Invalid expression: expected something like 'x(t - tau)'.\")\n\n    # Parse expression and apply to base\n    parsed_expr = parse_expr(expr_str.replace(name, \"\", 1), local_dict)\n    expr = expr_base.subs(var_base, parsed_expr)\n\n    # Analyze structure to adapt axis\n    xticks = self.init_xticks_arg\n    horiz_range = self.horiz_range\n    xticks_custom = None\n    xtick_labels_custom = None\n\n    if isinstance(parsed_expr, sp.Expr):\n        diff1 = parsed_expr - tau\n        if diff1.has(t):\n            diff2 = parsed_expr - t\n            coef = diff2.coeff(tau)\n            if coef == -1:\n                # Case t - tau \u21d2 reverse x-axis\n                if xticks == 'auto':\n                    xticks_custom = [t_val]\n                    xtick_labels_custom = [sp.latex(t)]\n                elif isinstance(xticks, (list, tuple)):\n                    xticks_custom = [t_val - v for v in xticks][::-1]\n                    xtick_labels_custom = [\n                        f\"{sp.latex(t)}\" if v == 0 else f\"{sp.latex(t)}{'-' if v &gt; 0 else '+'}{abs(v)}\"\n                        for v in xticks\n                    ][::-1]\n                horiz_range = (t_val - np.array(self.horiz_range)[::-1]).tolist()\n            elif coef == 1:\n                # Case t + tau \u21d2 shift axis\n                if xticks == 'auto':\n                    xticks_custom = [- t_val]\n                    xtick_labels_custom = [sp.latex(t)]\n                elif isinstance(xticks, (list, tuple)):\n                    xticks_custom = [- t_val + v for v in xticks]\n                    xtick_labels_custom = [\n                        f\"-{sp.latex(t)}\" if v == 0 else f\"-{sp.latex(t)}{'+' if v &gt; 0 else '-'}{abs(v)}\"\n                        for v in xticks\n                    ]\n                horiz_range = (np.array(self.horiz_range) - t_val).tolist()\n\n    # Evaluate the expression at t = t_val\n    expr_evaluated = expr.subs(t, t_val)\n\n    # Update expression and lambdified function\n    self._update_expression_and_func(expr_evaluated, tau)\n\n    # Axis labels\n    self.xlabel = sp.latex(tau)\n    tau_str = sp.latex(tau)\n    t_str = sp.latex(t)\n    self.ylabel = label if label else expr_str.replace(\"tau\", tau_str).replace(\"t\", t_str)\n\n    # Discretize time\n    self.t_vals = np.linspace(*horiz_range, self.num_points)\n\n    # Prepare and render plot\n    self._setup_figure()\n    self.setup_axes(horiz_range)\n    self.draw_function(horiz_range)\n    self.draw_impulses()\n    self.draw_ticks(xticks=xticks_custom, xtick_labels=xtick_labels_custom)\n    self.draw_labels()\n    self.show()\n</code></pre>"},{"location":"reference/#signalblocks.SignalPlotter.SignalPlotter.setup_axes","title":"<code>setup_axes(horiz_range=None)</code>","text":"<p>Configures the plot axes: hides borders, sets limits, and draws arrow-like axes. This method is typically called after <code>_prepare_plot()</code> to finalize the plot appearance. This method is usually called internally from <code>plot()</code>, but can also be used manually.</p> <p>This method: - Hides the default box (spines) around the plot. - Clears all default ticks. - Sets the horizontal and vertical limits based on the signal range. - Adds margin space around the plotted data to improve visual clarity. - Draws custom x- and y-axis arrows using <code>annotate</code>. - Calls <code>tight_layout()</code> to prevent label clipping.</p> <p>Notes: - The horizontal axis includes a 20% margin on both sides. - The vertical axis includes 30% below and 60% above the data range. - The vertical range must be computed beforehand via <code>_prepare_plot()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>horiz_range</code> <code>tuple</code> <p>If provided, overrides the default horizontal range.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; self._prepare_plot()\n&gt;&gt;&gt; self.setup_axes()\n</code></pre> Source code in <code>signalblocks\\SignalPlotter.py</code> <pre><code>def setup_axes(self, horiz_range=None):\n    \"\"\"\n    Configures the plot axes: hides borders, sets limits, and draws arrow-like axes.\n    This method is typically called after `_prepare_plot()` to finalize the plot appearance.\n    This method is usually called internally from `plot()`, but can also be used manually.\n\n    This method:\n    - Hides the default box (spines) around the plot.\n    - Clears all default ticks.\n    - Sets the horizontal and vertical limits based on the signal range.\n    - Adds margin space around the plotted data to improve visual clarity.\n    - Draws custom x- and y-axis arrows using `annotate`.\n    - Calls `tight_layout()` to prevent label clipping.\n\n    Notes:\n    - The horizontal axis includes a 20% margin on both sides.\n    - The vertical axis includes 30% below and 60% above the data range.\n    - The vertical range must be computed beforehand via `_prepare_plot()`.\n\n    Args:\n        horiz_range (tuple, optional): If provided, overrides the default horizontal range.\n\n    Examples:\n        &gt;&gt;&gt; self._prepare_plot()\n        &gt;&gt;&gt; self.setup_axes()\n    \"\"\"\n    # Hide all axis spines (borders)\n    for spine in self.ax.spines.values():\n        spine.set_color('none')\n\n    # Remove default ticks\n    self.ax.set_xticks([])\n    self.ax.set_yticks([])\n\n    if horiz_range is None:\n        horiz_range = self.horiz_range\n\n    # Compute horizontal range and margin\n    x0, x1 = horiz_range\n    x_range = x1 - x0\n    # You can adjust this value if needed\n    x_margin = 0.2 * x_range\n\n    # Use vertical range computed in _prepare_plot\n    y_min, y_max = self.y_min, self.y_max\n    y_range = y_max - y_min\n\n    # Add a 30% margin below and 60% margin above the signal range\n    if y_range &lt;= 0:\n        # In degenerate cases, ensure a minimum visible height\n        y_margin = 1.0\n    else:\n        y_margin = 0.3 * y_range\n\n    self.ax.set_xlim(horiz_range[0] - x_margin, horiz_range[1] + x_margin)\n    self.ax.set_ylim(self.y_min - y_margin, self.y_max + 1.6 * y_margin)\n\n    # Draw x-axis arrow\n    self.ax.annotate('', xy=(self.ax.get_xlim()[1], 0), xytext=(self.ax.get_xlim()[0], 0),\n                     arrowprops=dict(arrowstyle='-|&gt;', linewidth=1.5, color='black',\n                                     mutation_scale=16, mutation_aspect=0.8, fc='black'))\n\n    # Draw x-axis arrow\n    self.ax.annotate('', xy=(0, self.ax.get_ylim()[1]), xytext=(0, self.ax.get_ylim()[0]),\n                     arrowprops=dict(arrowstyle='-|&gt;', linewidth=1.5, color='black',\n                                     mutation_scale=12, mutation_aspect=2, fc='black'))\n\n    # Prevent labels from being clipped\n    self.fig.tight_layout()\n</code></pre>"},{"location":"reference/#signalblocks.SignalPlotter.SignalPlotter.show","title":"<code>show()</code>","text":"<p>Displays or saves the final plot, depending on configuration. This method is typically called after <code>draw_labels()</code>. This method is usually called internally from <code>plot()</code>, but can also be used manually.</p> <p>This method: - Disables the background grid. - Applies tight layout to reduce unnecessary whitespace. - If <code>self.save_path</code> is set, saves the figure to the given file (PNG, PDF, etc.). - If <code>self.show_plot</code> is True, opens a plot window (interactive view). - Finally, closes the figure to free up memory (especially important in batch plotting).</p> <p>Notes: - <code>self.save_path</code> and <code>self.show_plot</code> are set in the constructor. - If both are enabled, the plot is shown and saved. - The output file format is inferred from the file extension.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; self.show()  # Typically called at the end of plot()\n</code></pre> Source code in <code>signalblocks\\SignalPlotter.py</code> <pre><code>def show(self):\n    \"\"\"\n    Displays or saves the final plot, depending on configuration.\n    This method is typically called after `draw_labels()`.\n    This method is usually called internally from `plot()`, but can also be used manually.\n\n    This method:\n    - Disables the background grid.\n    - Applies tight layout to reduce unnecessary whitespace.\n    - If `self.save_path` is set, saves the figure to the given file (PNG, PDF, etc.).\n    - If `self.show_plot` is True, opens a plot window (interactive view).\n    - Finally, closes the figure to free up memory (especially important in batch plotting).\n\n    Notes:\n    - `self.save_path` and `self.show_plot` are set in the constructor.\n    - If both are enabled, the plot is shown and saved.\n    - The output file format is inferred from the file extension.\n\n    Examples:\n        &gt;&gt;&gt; self.show()  # Typically called at the end of plot()\n    \"\"\"\n    self.ax.grid(False)\n    plt.tight_layout()\n    if self.save_path:\n        self.fig.savefig(self.save_path, dpi=300, bbox_inches='tight')\n    if self.show_plot:\n        plt.show()\n    plt.close(self.fig)\n</code></pre>"}]}